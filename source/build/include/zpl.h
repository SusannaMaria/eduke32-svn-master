/*

  ZPL - Global module

Usage:
  #define ZPL_IMPLEMENTATION exactly in ONE source file right BEFORE including the library, like:

  #define ZPL_IMPLEMENTATION
  #include "zpl.h"

Options:

  ZPL_PREFIX_TYPES - to make sure all ZPL defined types have a prefix to avoid cluttering the global namespace.
  ZPL_DEFINE_NULL_MACRO - to let ZPL define what NULL stands for in case it is undefined.
  ZPL_NO_MATH_H - disables the use of math.h library and replaces it with custom routines or SIMD.


Credits:
  Read AUTHORS.md

GitHub:
  https://github.com/zpl-c/zpl

  This Software is dual licensed under the following licenses:

  Unlicense
  This is free and unencumbered software released into the public domain.

  Anyone is free to copy, modify, publish, use, compile, sell, or
  distribute this software, either in source code form or as a compiled
  binary, for any purpose, commercial or non-commercial, and by any
  means.

  In jurisdictions that recognize copyright laws, the author or authors
  of this software dedicate any and all copyright interest in the
  software to the public domain. We make this dedication for the benefit
  of the public at large and to the detriment of our heirs and
  successors. We intend this dedication to be an overt act of
  relinquishment in perpetuity of all present and future rights to this
  software under copyright law.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.

  For more information, please refer to <http://unlicense.org/>

  Apache 2.0
  Copyright 2017-2019 Dominik Madar√°sz <zaklaus@outlook.com>
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

*/

//
// TOP
//

//
// This file was generated by build.py script. Do not modify it!
// Instead, visit a specific module and edit it, then execute build.py to generate this file.
//

#ifndef ZPL_INCLUDE_ZPL_H
#define ZPL_INCLUDE_ZPL_H

#if defined(__GCC__) || defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-function"
#endif

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4201)
#pragma warning(disable : 4127) // Conditional expression is constant
#endif


#if defined(__cplusplus)
extern "C" {
#endif

    /** @file header.c
@brief Macro helpers and symbols
@defgroup header Macro helpers and symbols

 This module contains many useful macros helpful for debugging as well as development itself.

 @{
 */

#if defined(__cplusplus)
    #define ZPL_EXTERN extern "C"
#else
    #define ZPL_EXTERN extern
#endif

#if defined(_WIN32)
    #define ZPL_DLL_EXPORT ZPL_EXTERN __declspec(dllexport)
    #define ZPL_DLL_IMPORT ZPL_EXTERN __declspec(dllimport)
#else
    #define ZPL_DLL_EXPORT ZPL_EXTERN __attribute__((visibility("default")))
    #define ZPL_DLL_IMPORT ZPL_EXTERN
#endif

#ifndef ZPL_DEF
    #ifdef ZPL_STATIC
        #define ZPL_DEF static
    #else
        #define ZPL_DEF extern
    #endif
#endif

#ifdef ZPL_IMPL
    #define ZPL_IMPLEMENTATION
#endif

#ifdef ZPL_DEFINE
    #define ZPL_IMPLEMENTATION
#endif

#if defined(_WIN64) || defined(__x86_64__) || defined(_M_X64) || defined(__64BIT__) || defined(__powerpc64__) ||       \
defined(__ppc64__) || defined(__aarch64__)
    #ifndef ZPL_ARCH_64_BIT
        #define ZPL_ARCH_64_BIT 1
    #endif
#else
    #ifndef ZPL_ARCH_32_BIT
        #define ZPL_ARCH_32_BIT 1
    #endif
#endif

#ifndef ZPL_ENDIAN_ORDER
    #define ZPL_ENDIAN_ORDER
    #define ZPL_IS_BIG_ENDIAN (!*(zpl_u8 *)&(zpl_u16){ 1 })
    #define ZPL_IS_LITTLE_ENDIAN (!ZPL_IS_BIG_ENDIAN)
#endif

#if defined(_WIN32) || defined(_WIN64)
    #ifndef ZPL_SYSTEM_WINDOWS
        #define ZPL_SYSTEM_WINDOWS 1
    #endif
#elif defined(__APPLE__) && defined(__MACH__)
    #ifndef ZPL_SYSTEM_OSX
        #define ZPL_SYSTEM_OSX 1
    #endif
    #ifndef ZPL_SYSTEM_MACOS
        #define ZPL_SYSTEM_MACOS 1
    #endif
    #include <TargetConditionals.h>
    #if TARGET_IPHONE_SIMULATOR == 1 || TARGET_OS_IPHONE == 1
        #ifndef ZPL_SYSTEM_IOS
            #define ZPL_SYSTEM_IOS 1
        #endif
    #endif
#elif defined(__unix__)
    #ifndef ZPL_SYSTEM_UNIX
        #define ZPL_SYSTEM_UNIX 1
    #endif
    #if defined(ANDROID) || defined(__ANDROID__)
        #ifndef ZPL_SYSTEM_ANDROID
            #define ZPL_SYSTEM_ANDROID 1
        #endif
        #ifndef ZPL_SYSTEM_LINUX
            #define ZPL_SYSTEM_LINUX 1
        #endif
    #elif defined(__linux__)
    #ifndef ZPL_SYSTEM_LINUX
        #define ZPL_SYSTEM_LINUX 1
    #endif
    #elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
        #ifndef ZPL_SYSTEM_FREEBSD
            #define ZPL_SYSTEM_FREEBSD 1
        #endif
    #elif defined(__EMSCRIPTEN__)
        #ifndef ZPL_SYSTEM_EMSCRIPTEN
            #define ZPL_SYSTEM_EMSCRIPTEN 1
        #endif
    #else
        #error This UNIX operating system is not supported
    #endif
#else
    #error This operating system is not supported
#endif


#if defined(_MSC_VER)
    #define ZPL_COMPILER_MSVC 1
#elif defined(__GNUC__)
    #define ZPL_COMPILER_GCC 1
#elif defined(__clang__)
    #define ZPL_COMPILER_CLANG 1
#else
    #error Unknown compiler
#endif

#if defined(__arm__) || defined(__aarch64__)
    #ifndef ZPL_CPU_ARM
        #define ZPL_CPU_ARM 1
    #endif
    #ifndef ZPL_CACHE_LINE_SIZE
        #define ZPL_CACHE_LINE_SIZE 64
    #endif
#elif defined(_M_IX86) || defined(_M_X64) || defined(__i386__) || defined(__x86_64__) || defined(ZPL_SYSTEM_EMSCRIPTEN)
    #ifndef ZPL_CPU_X86
        #define ZPL_CPU_X86 1
    #endif
    #ifndef ZPL_CACHE_LINE_SIZE
        #define ZPL_CACHE_LINE_SIZE 64
    #endif
#elif defined(_M_PPC) || defined(__powerpc__) || defined(__powerpc64__)
    #ifndef ZPL_CPU_PPC
        #define ZPL_CPU_PPC 1
    #endif
    #ifndef ZPL_CACHE_LINE_SIZE
        #define ZPL_CACHE_LINE_SIZE 128
    #endif
#elif defined(__MIPSEL__) || defined(__mips_isa_rev)
    #ifndef ZPL_CPU_MIPS
        #define ZPL_CPU_MIPS 1
    #endif
    #ifndef ZPL_CACHE_LINE_SIZE
        #define ZPL_CACHE_LINE_SIZE 64
    #endif
#else
    #error Unknown CPU Type
#endif

#if !defined(ZPL_SYSTEM_EMSCRIPTEN) && !defined(ZPL_CPU_ARM) // disabled for __EMSCRIPTEN__
    #ifndef ZPL_THREADING
        #define ZPL_THREADING 1
    #else
        #if ZPL_THREADING == 0 || defined(ZPL_NO_THREADING)
            #undef ZPL_THREADING
        #endif
    #endif
#endif

#ifndef ZPL_STATIC_ASSERT
    #define ZPL_STATIC_ASSERT3(cond, msg) typedef char static_assertion_##msg[(!!(cond)) * 2 - 1]
    #define ZPL_STATIC_ASSERT2(cond, line) ZPL_STATIC_ASSERT3(cond, static_assertion_at_line_##line)
    #define ZPL_STATIC_ASSERT1(cond, line) ZPL_STATIC_ASSERT2(cond, line)
    #define ZPL_STATIC_ASSERT(cond) ZPL_STATIC_ASSERT1(cond, __LINE__)
#endif

////////////////////////////////////////////////////////////////
//
// Headers
//
//

#if defined(ZPL_SYSTEM_UNIX)
    #ifndef _GNU_SOURCE
        #define _GNU_SOURCE
    #endif
    #ifndef _LARGEFILE64_SOURCE
        #define _LARGEFILE64_SOURCE
    #endif
#endif

#include <math.h>

#if defined(ZPL_SYSTEM_WINDOWS)
#include <direct.h> // TODO: remove and use native winapi methods
#include <io.h>
#include <stdio.h>

#define ZPL_WINMAIN( )                                                                                                 \
int CALLBACK WinMain(_In_ HINSTANCE hInstance, _In_ HINSTANCE hPrevInstance, _In_ LPSTR lpCmdLine,                 \
_In_ int nCmdShow)

#if !defined(ZPL_NO_WINDOWS_H)
    #ifndef WIN32_LEAN_AND_MEAN
        #define NOMINMAX
        #define WIN32_LEAN_AND_MEAN
        #define WIN32_MEAN_AND_LEAN
        #define VC_EXTRALEAN
    #endif
    #include <windows.h>
    #undef NOMINMAX
    #undef WIN32_LEAN_AND_MEAN
    #undef WIN32_MEAN_AND_LEAN
    #undef VC_EXTRALEAN
#endif

#include <malloc.h> // NOTE: _aligned_*()

#if !defined(ZPL_NO_SIMD)
    #include <intrin.h>
#endif

// TODO(ZaKlaus): Find a better way to get this flag in MinGW.
#if defined(ZPL_COMPILER_GCC) && !defined(WC_ERR_INVALID_CHARS)
    #define WC_ERR_INVALID_CHARS 0x0080
#endif

#if defined(ZPL_COMPILER_GCC) && defined(ZPL_SYSTEM_WINDOWS)
    // assume we use mingw as a compiler
    #define ZPL_COMPILER_MINGW
#endif

// include errno.h for MinGW
#if defined(ZPL_COMPILER_GCC)
    #include <errno.h>
#endif

#else

#define ZPL_WINMAIN int main(void)

#if !defined(ZPL_SYSTEM_EMSCRIPTEN)
    #include <pthread.h>
#endif

#include <dlfcn.h>
#include <errno.h>
#include <fcntl.h>
#ifndef _IOSC11_SOURCE
    #define _IOSC11_SOURCE
#endif
#include <stdlib.h> // NOTE: malloc on linux
#include <sys/mman.h>

#if !defined(ZPL_SYSTEM_OSX)
    #include <sys/sendfile.h>
#endif

#include <dirent.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/types.h>
#include <time.h>
#include <string.h>
#include <unistd.h>

#if !defined(ZPL_SYSTEM_ANDROID)
    #include <spawn.h>
#endif

#if !defined(ZPL_NO_SIMD)
    #if !defined(ZPL_SYSTEM_ANDROID) && !defined(ZPL_SYSTEM_IOS)
        #if !defined(ZPL_SYSTEM_EMSCRIPTEN)
            #include <emmintrin.h>
        #elif defined(ZPL_CPU_X86) && !defined(ZPL_SYSTEM_EMSCRIPTEN)
            #include <xmmintrin.h>
        #else
            #include <sched.h>
        #endif
    #endif
#endif

#endif

#if defined(ZPL_SYSTEM_OSX)
    #include <copyfile.h>
    #include <mach/clock.h>
    #include <mach/mach.h>
    #include <mach/mach_init.h>
    #include <mach/mach_time.h>
    #include <mach/thread_act.h>
    #include <mach/thread_policy.h>
    #include <stdio.h>
    #include <sys/sysctl.h>
#endif

#if defined(ZPL_SYSTEM_UNIX)
    #include <semaphore.h>
#endif

#if !defined(ZPL_SYSTEM_WINDOWS)
    #include <stdarg.h>
    #include <stddef.h>
#endif

////////////////////////////////////////////////////////////////
//
// Base Types
//
//

#if defined(ZPL_COMPILER_MSVC)
#if _MSC_VER < 1300
typedef unsigned char zpl_u8;
typedef signed char zpl_i8;
typedef unsigned short zpl_u16;
typedef signed short zpl_i16;
typedef unsigned int zpl_u32;
typedef signed int zpl_i32;
#else
typedef unsigned __int8 zpl_u8;
typedef signed __int8 zpl_i8;
typedef unsigned __int16 zpl_u16;
typedef signed __int16 zpl_i16;
typedef unsigned __int32 zpl_u32;
typedef signed __int32 zpl_i32;
#endif
typedef unsigned __int64 zpl_u64;
typedef signed __int64 zpl_i64;
#else
#include <stdint.h>
typedef uint8_t zpl_u8;
typedef int8_t zpl_i8;
typedef uint16_t zpl_u16;
typedef int16_t zpl_i16;
typedef uint32_t zpl_u32;
typedef int32_t zpl_i32;
typedef uint64_t zpl_u64;
typedef int64_t zpl_i64;
#endif

ZPL_STATIC_ASSERT(sizeof(zpl_u8) == sizeof(zpl_i8));
ZPL_STATIC_ASSERT(sizeof(zpl_u16) == sizeof(zpl_i16));
ZPL_STATIC_ASSERT(sizeof(zpl_u32) == sizeof(zpl_i32));
ZPL_STATIC_ASSERT(sizeof(zpl_u64) == sizeof(zpl_i64));

ZPL_STATIC_ASSERT(sizeof(zpl_u8) == 1);
ZPL_STATIC_ASSERT(sizeof(zpl_u16) == 2);
ZPL_STATIC_ASSERT(sizeof(zpl_u32) == 4);
ZPL_STATIC_ASSERT(sizeof(zpl_u64) == 8);

typedef size_t zpl_usize;
typedef ptrdiff_t zpl_isize;

ZPL_STATIC_ASSERT(sizeof(zpl_usize) == sizeof(zpl_isize));

// NOTE: (u)zpl_intptr is only here for semantic reasons really as this library will only support 32/64 bit OSes.
#if defined(_WIN64)
    typedef signed __int64 zpl_intptr;
    typedef unsigned __int64 zpl_uintptr;
#elif defined(_WIN32)
    // NOTE; To mark types changing their size, e.g. zpl_intptr
    #ifndef _W64
        #if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && _MSC_VER >= 1300
            #define _W64 __w64
        #else
            #define _W64
        #endif
    #endif
    typedef _W64 signed int zpl_intptr;
    typedef _W64 unsigned int zpl_uintptr;
#else
    typedef uintptr_t zpl_uintptr;
    typedef intptr_t zpl_intptr;
#endif

ZPL_STATIC_ASSERT(sizeof(zpl_uintptr) == sizeof(zpl_intptr));

typedef float zpl_f32;
typedef double zpl_f64;

ZPL_STATIC_ASSERT(sizeof(zpl_f32) == 4);
ZPL_STATIC_ASSERT(sizeof(zpl_f64) == 8);

typedef zpl_i32 zpl_rune; // NOTE: Unicode codepoint
typedef zpl_i32 zpl_char32;
#define ZPL_RUNE_INVALID cast(zpl_rune)(0xfffd)
#define ZPL_RUNE_MAX cast(zpl_rune)(0x0010ffff)
#define ZPL_RUNE_BOM cast(zpl_rune)(0xfeff)
#define ZPL_RUNE_EOF cast(zpl_rune)(-1)

typedef zpl_i8 zpl_b8;
typedef zpl_i16 zpl_b16;
typedef zpl_i32 zpl_b32;

#if !defined(__cplusplus)
    #if (defined(_MSC_VER) && _MSC_VER < 1800) || (!defined(_MSC_VER) && !defined(__STDC_VERSION__))
    #ifndef true
        #define true(0 == 0)
    #endif
    #ifndef false
        #define false(0 != 0)
    #endif
    typedef zpl_b8 bool;
    #else
        #include <stdbool.h>
    #endif
#endif

#ifndef ZPL_U8_MIN
#define ZPL_U8_MIN 0u
#define ZPL_U8_MAX 0xffu
#define ZPL_I8_MIN (-0x7f - 1)
#define ZPL_I8_MAX 0x7f

#define ZPL_U16_MIN 0u
#define ZPL_U16_MAX 0xffffu
#define ZPL_I16_MIN (-0x7fff - 1)
#define ZPL_I16_MAX 0x7fff

#define ZPL_U32_MIN 0u
#define ZPL_U32_MAX 0xffffffffu
#define ZPL_I32_MIN (-0x7fffffff - 1)
#define ZPL_I32_MAX 0x7fffffff

#define ZPL_U64_MIN 0ull
#define ZPL_U64_MAX 0xffffffffffffffffull
#define ZPL_I64_MIN (-0x7fffffffffffffffll - 1)
#define ZPL_I64_MAX 0x7fffffffffffffffll

#if defined(ZPL_ARCH_32_BIT)
    #define ZPL_USIZE_MIN ZPL_U32_MIN
    #define ZPL_USIZE_MAX ZPL_U32_MAX

    #define ZPL_ISIZE_MIN ZPL_S32_MIN
#define ZPL_ISIZE_MAX ZPL_S32_MAX
    #elif defined(ZPL_ARCH_64_BIT)
    #define ZPL_USIZE_MIN ZPL_U64_MIN
    #define ZPL_USIZE_MAX ZPL_U64_MAX

    #define ZPL_ISIZE_MIN ZPL_I64_MIN
    #define ZPL_ISIZE_MAX ZPL_I64_MAX
#else
    #error Unknown architecture size. This library only supports 32 bit and 64 bit architectures.
#endif

#define ZPL_F32_MIN 1.17549435e-38f
#define ZPL_F32_MAX 3.40282347e+38f

#define ZPL_F64_MIN 2.2250738585072014e-308
#define ZPL_F64_MAX 1.7976931348623157e+308

#endif

#ifdef ZPL_DEFINE_NULL_MACRO
    #ifndef NULL
        #if defined(__cplusplus)
            #if __cplusplus >= 201103L
                #define NULL nullptr
            #else
                #define NULL 0
            #endif
        #else
            #define NULL ((void *)0)
        #endif
    #endif
#endif

#if !defined(__cplusplus)
    #if defined(_MSC_VER) && _MSC_VER <= 1800
        #define inline __inline
    #elif !defined(__STDC_VERSION__)
        #define inline __inline__
    #else
        #define inline
    #endif
#endif

#if !defined(zpl_restrict)
    #if defined(_MSC_VER)
        #define zpl_restrict __restrict
    #elif defined(__STDC_VERSION__)
        #define zpl_restrict restrict
    #else
        #define zpl_restrict
    #endif
#endif

#if !defined(zpl_inline)
    #if defined(_MSC_VER)
        #if _MSC_VER < 1300
            #define zpl_inline
        #else
            #define zpl_inline __forceinline
        #endif
    #else
        #define zpl_inline inline //__attribute__ ((__always_inline__)) inline
    #endif
#endif

#if !defined(zpl_no_inline)
    #if defined(_MSC_VER)
        #define zpl_no_inline __declspec(noinline)
    #else
        #define zpl_no_inline __attribute__((noinline))
    #endif
#endif

#if !defined(zpl_thread_local)
    #if defined(_MSC_VER) && _MSC_VER >= 1300
        #define zpl_thread_local __declspec(thread)
    #elif defined(__GNUC__)
        #define zpl_thread_local __thread
    #else
        #define zpl_thread_local thread_local
    #endif
#endif

#ifndef cast
    #define cast(Type) (Type)
#endif

#ifndef zpl_size_of
    #define zpl_size_of(x) (zpl_isize)(sizeof(x))
#endif

#ifndef zpl_count_of
    #define zpl_count_of(x) ((zpl_size_of(x) / zpl_size_of(0 [x])) / ((zpl_isize)(!(zpl_size_of(x) % zpl_size_of(0 [x])))))
#endif

#ifndef zpl_offset_of
#ifdef _MSC_VER
    #define zpl_offset_of(Type, element) ((zpl_isize) & (((Type *)0)->element))
#else
    #define zpl_offset_of(Type, element) __builtin_offsetof(Type, element)
#endif
#endif

#if defined(__cplusplus)
    #ifndef zpl_align_of
        #if __cplusplus >= 201103L
            #define zpl_align_of(Type) (zpl_isize)alignof(Type)
        #else
            extern "C++" {
                template <typename T> struct zpl_alignment_trick {
                    char c;
                    T member;
                };
            }
            #define zpl_align_of(Type) zpl_offset_of(zpl_alignment_trick<Type>, member)
        #endif
    #endif
#else
    #ifndef zpl_align_of
        #define zpl_align_of(Type)                                                                                             \
        zpl_offset_of(                                                                                                     \
        struct {                                                                                                       \
            char c;                                                                                                    \
            Type member;                                                                                               \
        },                                                                                                             \
        member)
    #endif
#endif

#ifndef zpl_swap
    #define zpl_swap(Type, a, b)                                                                                           \
    do {                                                                                                               \
        Type tmp = (a);                                                                                                \
        (a) = (b);                                                                                                     \
        (b) = tmp;                                                                                                     \
    } while (0)
#endif

#ifndef zpl_global
    #define zpl_global static        // Global variables
    #define zpl_internal static      // Internal linkage
    #define zpl_local_persist static // Local Persisting variables
#endif

#ifndef zpl_unused
    #if defined(_MSC_VER)
        #define zpl_unused(x) (__pragma(warning(suppress : 4100))(x))
    #elif defined(__GCC__)
        #define zpl_unused(x) __attribute__((__unused__))(x)
    #else
        #define zpl_unused(x) ((void)(zpl_size_of(x)))
    #endif
#endif

////////////////////////////////////////////////////////////////
//
// Macro Fun!
//
//

#ifndef ZPL_JOIN_MACROS
#define ZPL_JOIN_MACROS
#define ZPL_JOIN2_IND(a, b) a##b

#define ZPL_JOIN2(a, b) ZPL_JOIN2_IND(a, b)
#define ZPL_JOIN3(a, b, c) ZPL_JOIN2(ZPL_JOIN2(a, b), c)
#define ZPL_JOIN4(a, b, c, d) ZPL_JOIN2(ZPL_JOIN2(ZPL_JOIN2(a, b), c), d)
#endif

#ifndef ZPL_BIT
#define ZPL_BIT(x) (1 << (x))
#endif

#ifndef zpl_min
#define zpl_min(a, b) ((a) < (b) ? (a) : (b))
#endif

#ifndef zpl_max
#define zpl_max(a, b) ((a) > (b) ? (a) : (b))
#endif

#ifndef zpl_min3
#define zpl_min3(a, b, c) zpl_min(zpl_min(a, b), c)
#endif

#ifndef zpl_max3
#define zpl_max3(a, b, c) zpl_max(zpl_max(a, b), c)
#endif

#ifndef zpl_clamp
#define zpl_clamp(x, lower, upper) zpl_min(zpl_max((x), (lower)), (upper))
#endif

#ifndef zpl_clamp01
#define zpl_clamp01(x) zpl_clamp((x), 0, 1)
#endif

#ifndef zpl_is_between
#define zpl_is_between(x, lower, upper) (((lower) <= (x)) && ((x) <= (upper)))
#endif

#ifndef zpl_abs
#define zpl_abs(x) ((x) < 0 ? -(x) : (x))
#endif

#ifndef hard_cast
#define hard_cast(type) *cast(type) &
#endif

// WARN(ZaKlaus): Supported only on GCC via GNU extensions!!!
#ifndef zpl_lambda
#define zpl_lambda(b_) ({ b_ _; })
#endif

#ifndef zpl_when
#define zpl_when(init, type, name)                                                                                     \
type name = init;                                                                                                  \
if (name)
#endif

/* NOTE: Very useful bit setting */
#ifndef ZPL_MASK_SET
#define ZPL_MASK_SET(var, set, mask)                                                                                   \
do {                                                                                                               \
    if (set)                                                                                                       \
    (var) |= (mask);                                                                                           \
    else                                                                                                           \
    (var) &= ~(mask);                                                                                          \
} while (0)
#endif

// NOTE: Some compilers support applying printf-style warnings to user functions.
#if !defined(ZPL_COMPILER_MINGW) && (defined(__clang__) || defined(__GNUC__))
#define ZPL_PRINTF_ARGS(FMT) __attribute__((format(printf, FMT, (FMT + 1))))
#else
#define ZPL_PRINTF_ARGS(FMT)
#endif

// Multiline string literals in C99!
#ifndef ZPL_MULTILINE
#define ZPL_MULTILINE(...) #__VA_ARGS__
#endif

////////////////////////////////////////////////////////////////
//
// Debug
//
//

#ifndef ZPL_DEBUG_TRAP
    #if defined(_MSC_VER)
        #if _MSC_VER < 1300
            #define ZPL_DEBUG_TRAP( ) __asm int 3 /* Trap to debugger! */
        #else
            #define ZPL_DEBUG_TRAP( ) __debugbreak( )
        #endif
    #else
        #define ZPL_DEBUG_TRAP( ) __builtin_trap( )
    #endif
#endif

#ifndef ZPL_ASSERT_MSG
#define ZPL_ASSERT_MSG(cond, msg, ...)                                                                                 \
do {                                                                                                               \
    if (!(cond)) {                                                                                                 \
        zpl_assert_handler(#cond, __FILE__, cast(zpl_i64) __LINE__, msg, ##__VA_ARGS__);                               \
        ZPL_DEBUG_TRAP( );                                                                                         \
    }                                                                                                              \
} while (0)
#endif

#ifndef ZPL_ASSERT
#define ZPL_ASSERT(cond) ZPL_ASSERT_MSG(cond, NULL)
#endif

#ifndef ZPL_ASSERT_NOT_NULL
#define ZPL_ASSERT_NOT_NULL(ptr) ZPL_ASSERT_MSG((ptr) != NULL, #ptr " must not be NULL")
#endif

// NOTE: Things that shouldn't happen with a message!
#ifndef ZPL_PANIC
#define ZPL_PANIC(msg, ...) ZPL_ASSERT_MSG(0, msg, ##__VA_ARGS__)
#endif

#ifndef ZPL_NOT_IMPLEMENTED
#define ZPL_NOT_IMPLEMENTED ZPL_PANIC("not implemented")
#endif

ZPL_DEF void    zpl_assert_handler(char const *condition, char const *file, zpl_i32 line, char const *msg, ...);
ZPL_DEF zpl_i32 zpl_assert_crash(char const *condition);

//! @}
/** @file mem.c
@brief Memory manipulation and helpers.
@defgroup memman Memory management

 Consists of pointer arithmetic methods, virtual memory management and custom memory allocators.

 @{
 */

//! Checks if value is power of 2.
ZPL_DEF zpl_b32 zpl_is_power_of_two(zpl_isize x);

//! Aligns address to specified alignment.
ZPL_DEF void *zpl_align_forward(void *ptr, zpl_isize alignment);

//! Moves pointer forward by bytes.
ZPL_DEF void *zpl_pointer_add(void *ptr, zpl_isize bytes);

//! Moves pointer backward by bytes.
ZPL_DEF void *zpl_pointer_sub(void *ptr, zpl_isize bytes);

//! Moves pointer forward by bytes.
ZPL_DEF void const *zpl_pointer_add_const(void const *ptr, zpl_isize bytes);

//! Moves pointer backward by bytes.
ZPL_DEF void const *zpl_pointer_sub_const(void const *ptr, zpl_isize bytes);

//! Calculates difference between two addresses.
ZPL_DEF zpl_isize zpl_pointer_diff(void const *begin, void const *end);

#define zpl_ptr_add zpl_pointer_add
#define zpl_ptr_sub zpl_pointer_sub
#define zpl_ptr_add_const zpl_pointer_add_const
#define zpl_ptr_sub_const zpl_pointer_sub_const
#define zpl_ptr_diff zpl_pointer_diff

//! Clears up memory at location by specified size.

//! @param ptr Memory location to clear up.
//! @param size The size to clear up with.
ZPL_DEF void zpl_zero_size(void *ptr, zpl_isize size);

#ifndef zpl_zero_item
//! Clears up an item.
#define zpl_zero_item(t) zpl_zero_size((t), zpl_size_of(*(t))) // NOTE: Pass pointer of struct

//! Clears up an array.
#define zpl_zero_array(a, count) zpl_zero_size((a), zpl_size_of(*(a)) * count)
#endif

//! Copy non-overlapping memory from source to destination.
ZPL_DEF void *zpl_memcopy(void *dest, void const *source, zpl_isize size);

//! Copy memory from source to destination.
ZPL_DEF void *zpl_memmove(void *dest, void const *source, zpl_isize size);

//! Set constant value at memory location with specified size.
ZPL_DEF void *zpl_memset(void *data, zpl_u8 byte_value, zpl_isize size);

//! Compare two memory locations with specified size.
ZPL_DEF zpl_i32 zpl_memcompare(void const *s1, void const *s2, zpl_isize size);

//! Swap memory contents between 2 locations with size.
ZPL_DEF void zpl_memswap(void *i, void *j, zpl_isize size);

//! Search for a constant value within the size limit at memory location.
ZPL_DEF void const *zpl_memchr(void const *data, zpl_u8 byte_value, zpl_isize size);

//! Search for a constant value within the size limit at memory location in backwards.
ZPL_DEF void const *zpl_memrchr(void const *data, zpl_u8 byte_value, zpl_isize size);

#ifndef zpl_memcopy_array

//! Copy non-overlapping array.
#define zpl_memcopy_array(dst, src, count) zpl_memcopy((dst), (src), zpl_size_of(*(dst)) * (count))
#endif

//! Copy an array.
#ifndef zpl_memmove_array
#define zpl_memmove_array(dst, src, count) zpl_memmove((dst), (src), zpl_size_of(*(dst)) * (count))
#endif

#ifndef ZPL_BIT_CAST
#define ZPL_BIT_CAST(dest, source)                                                                                     \
do {                                                                                                               \
    ZPL_STATIC_ASSERT(zpl_size_of(*(dest)) <= zpl_size_of(source));                                                \
    zpl_memcopy((dest), &(source), zpl_size_of(*dest));                                                            \
} while (0)
#endif

#ifndef zpl_kilobytes
#define zpl_kilobytes(x) ((x)              * (zpl_i64)(1024))
#define zpl_megabytes(x) (zpl_kilobytes(x) * (zpl_i64)(1024))
#define zpl_gigabytes(x) (zpl_megabytes(x) * (zpl_i64)(1024))
#define zpl_terabytes(x) (zpl_gigabytes(x) * (zpl_i64)(1024))
#endif

////////////////////////////////////////////////////////////////
//
// Virtual Memory
//
//


typedef struct zpl_virtual_memory {
    void *data;
    zpl_isize size;
} zpl_virtual_memory;

//! Initialize virtual memory from existing data.
ZPL_DEF zpl_virtual_memory zpl_vm(void *data, zpl_isize size);

//! Allocate virtual memory at address with size.

//! @param addr The starting address of the region to reserve. If NULL, it lets operating system to decide where to allocate it.
//! @param size The size to server.
ZPL_DEF zpl_virtual_memory zpl_vm_alloc(void *addr, zpl_isize size);

//! Release the virtual memory.
ZPL_DEF zpl_b32 zpl_vm_free(zpl_virtual_memory vm);

//! Trim virtual memory.
ZPL_DEF zpl_virtual_memory zpl_vm_trim(zpl_virtual_memory vm, zpl_isize lead_size, zpl_isize size);

//! Purge virtual memory.
ZPL_DEF zpl_b32 zpl_vm_purge(zpl_virtual_memory vm);

//! Retrieve VM's page size and alignment.
ZPL_DEF zpl_isize zpl_virtual_memory_page_size(zpl_isize *alignment_out);

////////////////////////////////////////////////////////////////
//
// Custom Allocation
//
//

typedef enum zplAllocationType {
    ZPL_ALLOCATION_ALLOC,
    ZPL_ALLOCATION_FREE,
    ZPL_ALLOCATION_FREE_ALL,
    ZPL_ALLOCATION_RESIZE,
} zplAllocationType;

// NOTE: This is useful so you can define an allocator of the same type and parameters
#define ZPL_ALLOCATOR_PROC(name)                                                                                       \
void *name(void *allocator_data, zplAllocationType type, zpl_isize size, zpl_isize alignment, void *old_memory,            \
zpl_isize old_size, zpl_u64 flags)
typedef ZPL_ALLOCATOR_PROC(zpl_allocator_proc);


typedef struct zpl_allocator {
    zpl_allocator_proc *proc;
    void *data;
} zpl_allocator;

typedef enum zplAllocatorFlag {
    ZPL_ALLOCATOR_FLAG_CLEAR_TO_ZERO = ZPL_BIT(0),
} zplAllocatorFlag;

#ifndef ZPL_DEFAULT_MEMORY_ALIGNMENT
#define ZPL_DEFAULT_MEMORY_ALIGNMENT (2 * zpl_size_of(void *))
#endif

#ifndef ZPL_DEFAULT_ALLOCATOR_FLAGS
#define ZPL_DEFAULT_ALLOCATOR_FLAGS (ZPL_ALLOCATOR_FLAG_CLEAR_TO_ZERO)
#endif

//! Allocate memory with specified alignment.
ZPL_DEF void *zpl_alloc_align(zpl_allocator a, zpl_isize size, zpl_isize alignment);

//! Allocate memory with default alignment.
ZPL_DEF void *zpl_alloc(zpl_allocator a, zpl_isize size);

//! Free allocated memory.
ZPL_DEF void zpl_free(zpl_allocator a, void *ptr);

//! Free all memory allocated by an allocator.
ZPL_DEF void zpl_free_all(zpl_allocator a);

//! Resize an allocated memory.
ZPL_DEF void *zpl_resize(zpl_allocator a, void *ptr, zpl_isize old_size, zpl_isize new_size);

//! Resize an allocated memory with specified alignment.
ZPL_DEF void *zpl_resize_align(zpl_allocator a, void *ptr, zpl_isize old_size, zpl_isize new_size, zpl_isize alignment);

//! Allocate memory and copy data into it.
ZPL_DEF void *zpl_alloc_copy(zpl_allocator a, void const *src, zpl_isize size);

//! Allocate memory with specified alignment and copy data into it.
ZPL_DEF void *zpl_alloc_copy_align(zpl_allocator a, void const *src, zpl_isize size, zpl_isize alignment);

//! Allocate memory for null-terminated C-String.
ZPL_DEF char *zpl_alloc_str(zpl_allocator a, char const *str);

//! Allocate memory for C-String with specified size.
ZPL_DEF char *zpl_alloc_str_len(zpl_allocator a, char const *str, zpl_isize len);

#ifndef zpl_alloc_item

//! Allocate memory for an item.
#define zpl_alloc_item(allocator_, Type) (Type *)zpl_alloc(allocator_, zpl_size_of(Type))

//! Allocate memory for an array of items.
#define zpl_alloc_array(allocator_, Type, count) (Type *)zpl_alloc(allocator_, zpl_size_of(Type) * (count))
#endif

//! Allocate/Resize memory using default options.

//! Use this if you don't need a "fancy" resize allocation
ZPL_DEF void *zpl_default_resize_align(zpl_allocator a, void *ptr, zpl_isize old_size, zpl_isize new_size, zpl_isize alignment);

//! The heap allocator backed by operating system's memory manager.
ZPL_DEF zpl_allocator zpl_heap_allocator(void);
ZPL_DEF ZPL_ALLOCATOR_PROC(zpl_heap_allocator_proc);

#ifndef zpl_malloc

//! Helper to allocate memory using heap allocator.
#define zpl_malloc(sz) zpl_alloc(zpl_heap_allocator( ), sz)

//! Helper to free memory allocated by heap allocator.
#define zpl_mfree(ptr) zpl_free(zpl_heap_allocator( ), ptr)

//! Alias to heap allocator.
#define zpl_heap zpl_heap_allocator
#endif

//
// Arena Allocator
//

typedef struct zpl_arena {
    zpl_allocator backing;
    void *physical_start;
    zpl_isize total_size;
    zpl_isize total_allocated;
    zpl_isize temp_count;
} zpl_arena;

//! Initialize memory arena from existing memory region.
ZPL_DEF void zpl_arena_init_from_memory(zpl_arena *arena, void *start, zpl_isize size);

//! Initialize memory arena using existing memory allocator.
ZPL_DEF void zpl_arena_init_from_allocator(zpl_arena *arena, zpl_allocator backing, zpl_isize size);

//! Initialize memory arena within an existing parent memory arena.
ZPL_DEF void zpl_arena_init_sub(zpl_arena *arena, zpl_arena *parent_arena, zpl_isize size);

//! Release the memory used by memory arena.
ZPL_DEF void zpl_arena_free(zpl_arena *arena);


//! Retrieve memory arena's aligned allocation address.
ZPL_DEF zpl_isize zpl_arena_alignment_of(zpl_arena *arena, zpl_isize alignment);

//! Retrieve memory arena's remaining size.
ZPL_DEF zpl_isize zpl_arena_size_remaining(zpl_arena *arena, zpl_isize alignment);

//! Check whether memory arena has any temporary snapshots.
ZPL_DEF void zpl_arena_check(zpl_arena *arena);

//! Allocation Types: alloc, free_all, resize
ZPL_DEF zpl_allocator zpl_arena_allocator(zpl_arena *arena);
ZPL_DEF ZPL_ALLOCATOR_PROC(zpl_arena_allocator_proc);


typedef struct zpl_temp_arena_memory {
    zpl_arena *arena;
    zpl_isize original_count;
} zpl_temp_arena_memory;

//! Capture a snapshot of used memory in a memory arena.
ZPL_DEF zpl_temp_arena_memory zpl_temp_arena_memory_begin(zpl_arena *arena);

//! Reset memory arena's usage by a captured snapshot.
ZPL_DEF void zpl_temp_arena_memory_end(zpl_temp_arena_memory tmp_mem);

//
// Pool Allocator
//


typedef struct zpl_pool {
    zpl_allocator backing;
    void *physical_start;
    void *free_list;
    zpl_isize block_size;
    zpl_isize block_align;
    zpl_isize total_size;
} zpl_pool;


//! Initialize pool allocator.
ZPL_DEF void zpl_pool_init(zpl_pool *pool, zpl_allocator backing, zpl_isize num_blocks, zpl_isize block_size);

//! Initialize pool allocator with specific block alignment.
ZPL_DEF void zpl_pool_init_align(zpl_pool *pool, zpl_allocator backing, zpl_isize num_blocks, zpl_isize block_size,
                                 zpl_isize block_align);

//! Release the resources used by pool allocator.
ZPL_DEF void zpl_pool_free(zpl_pool *pool);

//! Allocation Types: alloc, free
ZPL_DEF zpl_allocator zpl_pool_allocator(zpl_pool *pool);
ZPL_DEF ZPL_ALLOCATOR_PROC(zpl_pool_allocator_proc);


typedef struct zpl_allocation_header_ev {
    zpl_isize size;
} zpl_allocation_header_ev;

ZPL_DEF zpl_allocation_header_ev *zpl_allocation_header(void *data);
ZPL_DEF void zpl_allocation_header_fill(zpl_allocation_header_ev *header, void *data, zpl_isize size);

#if defined(ZPL_ARCH_32_BIT)
#define ZPL_ISIZE_HIGH_BIT 0x80000000
#elif defined(ZPL_ARCH_64_BIT)
#define ZPL_ISIZE_HIGH_BIT 0x8000000000000000ll
#else
#error
#endif

//
// Scratch Memory Allocator - Ring Buffer Based Arena
//


typedef struct zpl_scratch_memory {
    void *physical_start;
    zpl_isize total_size;
    void *alloc_point;
    void *free_point;
} zpl_scratch_memory;

//! Initialize ring buffer arena.
ZPL_DEF void zpl_scratch_memory_init(zpl_scratch_memory *s, void *start, zpl_isize size);

//! Check whether ring buffer arena is in use.
ZPL_DEF zpl_b32 zpl_scratch_memory_is_in_use(zpl_scratch_memory *s, void *ptr);

//! Allocation Types: alloc, free, free_all, resize
ZPL_DEF zpl_allocator zpl_scratch_allocator(zpl_scratch_memory *s);
ZPL_DEF ZPL_ALLOCATOR_PROC(zpl_scratch_allocator_proc);

//
// Stack Memory Allocator
//


typedef struct zpl_stack_memory {
    zpl_allocator backing;

    void *physical_start;
    zpl_usize total_size;
    zpl_usize allocated;
} zpl_stack_memory;

//! Initialize stack allocator from existing memory.
ZPL_DEF void zpl_stack_memory_init_from_memory(zpl_stack_memory *s, void *start, zpl_isize size);

//! Initialize stack allocator using existing memory allocator.
ZPL_DEF void zpl_stack_memory_init(zpl_stack_memory *s, zpl_allocator backing, zpl_isize size);

//! Check whether stack allocator is in use.
ZPL_DEF zpl_b32 zpl_stack_memory_is_in_use(zpl_stack_memory *s, void *ptr);

//! Release the resources used by stack allocator.
ZPL_DEF void zpl_stack_memory_free(zpl_stack_memory *s);

//! Allocation Types: alloc, free, free_all
ZPL_DEF zpl_allocator zpl_stack_allocator(zpl_stack_memory *s);
ZPL_DEF ZPL_ALLOCATOR_PROC(zpl_stack_allocator_proc);

// TODO: Fixed heap allocator
// TODO: General heap allocator. Maybe a TCMalloc like clone?

//! @}
/** @file threads.c
@brief Threading methods, blocking models...
@defgroup threads Threading management

This module features common threading and blocking principles. It contains thread merge operation based on stb_sync, as well as CPU affinity management.

@{
*/

#ifdef ZPL_THREADING
// Fences
ZPL_DEF void zpl_yield_thread(void);
ZPL_DEF void zpl_mfence      (void);
ZPL_DEF void zpl_sfence      (void);
ZPL_DEF void zpl_lfence      (void);


#if defined(ZPL_SYSTEM_WINDOWS)
    typedef struct zpl_semaphore { void *win32_handle; }     zpl_semaphore;
#elif defined(ZPL_SYSTEM_OSX)
    typedef struct zpl_semaphore { semaphore_t osx_handle; } zpl_semaphore;
#elif defined(ZPL_SYSTEM_UNIX)
    typedef struct zpl_semaphore { sem_t unix_handle; }      zpl_semaphore;
#else
    #error
#endif

ZPL_DEF void zpl_semaphore_init   (zpl_semaphore *s);
ZPL_DEF void zpl_semaphore_destroy(zpl_semaphore *s);
ZPL_DEF void zpl_semaphore_post   (zpl_semaphore *s, zpl_i32 count);
ZPL_DEF void zpl_semaphore_release(zpl_semaphore *s); // NOTE: zpl_semaphore_post(s, 1)
ZPL_DEF void zpl_semaphore_wait   (zpl_semaphore *s);


// Mutex

typedef struct zpl_mutex {
#if defined(ZPL_SYSTEM_WINDOWS)
    CRITICAL_SECTION win32_critical_section;
#else
    pthread_mutex_t pthread_mutex;
#endif
} zpl_mutex;

ZPL_DEF void     zpl_mutex_init    (zpl_mutex *m);
ZPL_DEF void     zpl_mutex_destroy (zpl_mutex *m);
ZPL_DEF void     zpl_mutex_lock    (zpl_mutex *m);
ZPL_DEF zpl_b32  zpl_mutex_try_lock(zpl_mutex *m);
ZPL_DEF void     zpl_mutex_unlock  (zpl_mutex *m);

struct zpl_thread;

typedef zpl_isize (*zpl_thread_proc)(struct zpl_thread *thread);

zpl_isize zpl__async_handler(struct zpl_thread *thread);

typedef struct zpl_thread {
#if defined(ZPL_SYSTEM_WINDOWS)
    void *        win32_handle;
#else
    pthread_t     posix_handle;
#endif

    zpl_thread_proc  proc;
    void *           user_data;
    zpl_isize        user_index;
    zpl_isize        return_value;

    zpl_semaphore    semaphore;
    zpl_isize        stack_size;
    zpl_b32          is_running;
} zpl_thread;

ZPL_DEF void     zpl_thread_init            (zpl_thread *t);
ZPL_DEF void     zpl_thread_destroy         (zpl_thread *t);
ZPL_DEF void     zpl_thread_start           (zpl_thread *t, zpl_thread_proc proc, void *data);
ZPL_DEF void     zpl_thread_start_with_stack(zpl_thread *t, zpl_thread_proc proc, void *data, zpl_isize stack_size);
ZPL_DEF void     zpl_thread_join            (zpl_thread *t);
ZPL_DEF zpl_b32  zpl_thread_is_running      (zpl_thread const *t);
ZPL_DEF zpl_u32  zpl_thread_current_id      (void);
ZPL_DEF void     zpl_thread_set_name        (zpl_thread *t, char const *name);


// NOTE: Thread Merge Operation
// Based on Sean Barrett's stb_sync

typedef struct zpl_sync {
    zpl_i32 target;  // Target Number of threads
    zpl_i32 current; // Threads to hit
    zpl_i32 waiting; // Threads waiting

    zpl_mutex start;
    zpl_mutex mutex;
    zpl_semaphore release;
} zpl_sync;

ZPL_DEF void     zpl_sync_init          (zpl_sync *s);
ZPL_DEF void     zpl_sync_destroy       (zpl_sync *s);
ZPL_DEF void     zpl_sync_set_target    (zpl_sync *s, zpl_i32 count);
ZPL_DEF void     zpl_sync_release       (zpl_sync *s);
ZPL_DEF zpl_i32  zpl_sync_reach         (zpl_sync *s);
ZPL_DEF void     zpl_sync_reach_and_wait(zpl_sync *s);



#if defined(ZPL_SYSTEM_WINDOWS)


typedef struct zpl_affinity {
    zpl_b32   is_accurate;
    zpl_isize core_count;
    zpl_isize thread_count;
#define ZPL_WIN32_MAX_THREADS (8 * zpl_size_of(zpl_usize))
    zpl_usize core_masks[ZPL_WIN32_MAX_THREADS];

} zpl_affinity;

#elif defined(ZPL_SYSTEM_OSX)

typedef struct zpl_affinity {
    zpl_b32   is_accurate;
    zpl_isize core_count;
    zpl_isize thread_count;
    zpl_isize threads_per_core;
} zpl_affinity;

#elif defined(ZPL_SYSTEM_LINUX) || defined(ZPL_SYSTEM_EMSCRIPTEN)

typedef struct zpl_affinity {
    zpl_b32   is_accurate;
    zpl_isize core_count;
    zpl_isize thread_count;
    zpl_isize threads_per_core;
} zpl_affinity;
#else
#error TODO: Unknown system
#endif

ZPL_DEF void      zpl_affinity_init   (zpl_affinity *a);
ZPL_DEF void      zpl_affinity_destroy(zpl_affinity *a);
ZPL_DEF zpl_b32   zpl_affinity_set    (zpl_affinity *a, zpl_isize core, zpl_isize thread);
ZPL_DEF zpl_isize zpl_affinity_thread_count_for_core(zpl_affinity *a, zpl_isize core);

#endif // ZPL_THREADING

//! @}
/** @file sort.c
@brief Sorting and searching methods.
@defgroup sort Sorting and searching

Methods for sorting arrays using either Quick/Merge-sort combo or Radix sort. It also contains simple implementation of binary search, as well as an easy to use API to define your own comparators.

@{
*/

#define ZPL_COMPARE_PROC(name) int name(void const *a, void const *b)
typedef ZPL_COMPARE_PROC(zpl_compare_proc);

#define ZPL_COMPARE_PROC_PTR(def) ZPL_COMPARE_PROC((*def))

// Procedure pointers
// NOTE: The offset parameter specifies the offset in the structure
// e.g. zpl_i32_cmp(zpl_offset_of(Thing, value))
// Use 0 if it's just the type instead.

ZPL_DEF ZPL_COMPARE_PROC_PTR(i16_cmp(zpl_isize offset));
ZPL_DEF ZPL_COMPARE_PROC_PTR(u8_cmp(zpl_isize offset));
ZPL_DEF ZPL_COMPARE_PROC_PTR(i32_cmp(zpl_isize offset));
ZPL_DEF ZPL_COMPARE_PROC_PTR(i64_cmp(zpl_isize offset));
ZPL_DEF ZPL_COMPARE_PROC_PTR(isize_cmp(zpl_isize offset));
ZPL_DEF ZPL_COMPARE_PROC_PTR(str_cmp(zpl_isize offset));
ZPL_DEF ZPL_COMPARE_PROC_PTR(f32_cmp(zpl_isize offset));
ZPL_DEF ZPL_COMPARE_PROC_PTR(f64_cmp(zpl_isize offset));

// TODO: Better sorting algorithms

//! Sorts an array.

//! Uses quick sort for large arrays but insertion sort for small ones.
#define zpl_sort_array(array, count, compare_proc) zpl_sort(array, count, zpl_size_of(*(array)), compare_proc)

//! Perform sorting operation on a memory location with a specified item count and size.
ZPL_DEF void zpl_sort(void *base, zpl_isize count, zpl_isize size, zpl_compare_proc compare_proc);

// NOTE: the count of temp == count of items
#define zpl_radix_sort(Type) zpl_radix_sort_##Type
#define ZPL_RADIX_SORT_PROC(Type) void zpl_radix_sort(Type)(zpl_##Type * items, zpl_##Type * temp, zpl_isize count)

ZPL_DEF ZPL_RADIX_SORT_PROC(u8);
ZPL_DEF ZPL_RADIX_SORT_PROC(u16);
ZPL_DEF ZPL_RADIX_SORT_PROC(u32);
ZPL_DEF ZPL_RADIX_SORT_PROC(u64);

//! Performs binary search on an array.

//! Returns index or -1 if not found
#define zpl_binary_search_array(array, count, key, compare_proc)                                                       \
zpl_binary_search(array, count, zpl_size_of(*(array)), key, compare_proc)

//! Performs binary search on a memory location with specified item count and size.
ZPL_DEF zpl_isize zpl_binary_search(void const *base, zpl_isize count, zpl_isize size, void const *key,
                                zpl_compare_proc compare_proc);

#define zpl_shuffle_array(array, count) zpl_shuffle(array, count, zpl_size_of(*(array)))

//! Shuffles a memory.
ZPL_DEF void zpl_shuffle(void *base, zpl_isize count, zpl_isize size);

#define zpl_reverse_array(array, count) zpl_reverse(array, count, zpl_size_of(*(array)))

//! Reverses memory's contents
ZPL_DEF void zpl_reverse(void *base, zpl_isize count, zpl_isize size);

//! @}
/** @file string.c
@brief String operations and library
@defgroup string String library

Offers methods for c-string manipulation, but also a string library based on gb_string, which is c-string friendly.

@{
*/

////////////////////////////////////////////////////////////////
//
// Char Functions
//
//

ZPL_DEF char    zpl_char_to_lower(char c);
ZPL_DEF char    zpl_char_to_upper(char c);
ZPL_DEF zpl_b32 zpl_char_is_space(char c);
ZPL_DEF zpl_b32 zpl_char_is_digit(char c);
ZPL_DEF zpl_b32 zpl_char_is_hex_digit(char c);
ZPL_DEF zpl_b32 zpl_char_is_alpha(char c);
ZPL_DEF zpl_b32 zpl_char_is_alphanumeric(char c);
ZPL_DEF zpl_i32 zpl_digit_to_int(char c);
ZPL_DEF zpl_i32 zpl_hex_digit_to_int(char c);
ZPL_DEF zpl_u8  zpl_char_to_hex_digit(char c);

// NOTE: ASCII only
ZPL_DEF void zpl_str_to_lower(char *str);
ZPL_DEF void zpl_str_to_upper(char *str);

ZPL_DEF char *zpl_str_trim(char *str, zpl_b32 skip_newline);
ZPL_DEF char *zpl_str_skip(char *str, char c);
ZPL_DEF char *zpl_str_control_skip(char *str, char c);

ZPL_DEF zpl_isize   zpl_strlen(const char *str);
ZPL_DEF zpl_isize   zpl_strnlen(const char *str, zpl_isize max_len);
ZPL_DEF zpl_i32     zpl_strcmp(const char *s1, const char *s2);
ZPL_DEF zpl_i32     zpl_strncmp(const char *s1, const char *s2, zpl_isize len);
ZPL_DEF char       *zpl_strcpy(char *dest, const char *source);
ZPL_DEF char       *zpl_strdup(zpl_allocator a, char *src, zpl_isize max_len);
ZPL_DEF char       *zpl_strncpy(char *dest, const char *source, zpl_isize len);
ZPL_DEF zpl_isize   zpl_strlcpy(char *dest, const char *source, zpl_isize len);
ZPL_DEF char       *zpl_strrev(char *str); // NOTE: ASCII only
ZPL_DEF const char *zpl_strtok(char *output, const char *src, const char *delimit);

// NOTE: This edits *source* string.
// Returns: zpl_array
ZPL_DEF char  **zpl_str_split_lines(zpl_allocator alloc, char *source, zpl_b32 strip_whitespace);

#define zpl_str_expand(str) str, zpl_strlen(str)

ZPL_DEF zpl_b32 zpl_str_has_prefix(const char *str, const char *prefix);
ZPL_DEF zpl_b32 zpl_str_has_suffix(const char *str, const char *suffix);

ZPL_DEF const char *zpl_char_first_occurence(const char *str, char c);
ZPL_DEF const char *zpl_char_last_occurence(const char *str, char c);
#define zpl_strchr zpl_char_first_occurence

ZPL_DEF void zpl_str_concat(char *dest, zpl_isize dest_len, const char *src_a, zpl_isize src_a_len, const char *src_b,
                            zpl_isize src_b_len);

ZPL_DEF zpl_u64 zpl_str_to_u64(const char *str, char **end_ptr,
                           zpl_i32 base); // TODO: Support more than just decimal and hexadecimal
ZPL_DEF zpl_i64 zpl_str_to_i64(const char *str, char **end_ptr,
                           zpl_i32 base); // TODO: Support more than just decimal and hexadecimal
ZPL_DEF zpl_f32 zpl_str_to_f32(const char *str, char **end_ptr);
ZPL_DEF zpl_f64 zpl_str_to_f64(const char *str, char **end_ptr);
ZPL_DEF void    zpl_i64_to_str(zpl_i64 value, char *string, zpl_i32 base);
ZPL_DEF void    zpl_u64_to_str(zpl_u64 value, char *string, zpl_i32 base);

////////////////////////////////////////////////////////////////
//
// UTF-8 Handling
//
//

// NOTE: Does not check if utf-8 string is valid
ZPL_DEF zpl_isize zpl_utf8_strlen(zpl_u8 const *str);
ZPL_DEF zpl_isize zpl_utf8_strnlen(zpl_u8 const *str, zpl_isize max_len);

// NOTE: Windows doesn't handle 8 bit filenames well
ZPL_DEF zpl_u16 *zpl_utf8_to_ucs2(zpl_u16 *buffer, zpl_isize len, zpl_u8 const *str);
ZPL_DEF zpl_u8  *zpl_ucs2_to_utf8(zpl_u8 *buffer, zpl_isize len, zpl_u16 const *str);
ZPL_DEF zpl_u16 *zpl_utf8_to_ucs2_buf(zpl_u8 const *str); // NOTE: Uses locally persisting buffer
ZPL_DEF zpl_u8  *zpl_ucs2_to_utf8_buf(zpl_u16 const *str); // NOTE: Uses locally persisting buffer

// NOTE: Returns size of codepoint in bytes
ZPL_DEF zpl_isize zpl_utf8_decode(zpl_u8 const *str, zpl_isize str_len, zpl_rune *codepoint);
ZPL_DEF zpl_isize zpl_utf8_codepoint_size(zpl_u8 const *str, zpl_isize str_len);
ZPL_DEF zpl_isize zpl_utf8_encode_rune(zpl_u8 buf[4], zpl_rune r);

////////////////////////////////////////////////////////////////
//
// zpl_string - C Read-Only-Compatible
//
//
/*
    Reasoning:

    By default, strings in C are null terminated which means you have to count
    the number of character up to the null character to calculate the length.
    Many "better" C string libraries will create a struct for a string.
    i.e.

    struct String {
    Allocator allocator;
    size_t    length;
    size_t    capacity;
    char *    cstring;
    };

    This library tries to augment normal C strings in a better way that is still
    compatible with C-style strings.

    +--------+-----------------------+-----------------+
    | Header | Binary C-style String | Null Terminator |
    +--------+-----------------------+-----------------+
    |
    +-> Pointer returned by functions

    Due to the meta-data being stored before the string pointer and every zpl string
    having an implicit null terminator, zpl strings are full compatible with c-style
    strings and read-only functions.

    Advantages:

    * zpl strings can be passed to C-style string functions without accessing a struct
    member of calling a function, i.e.

    zpl_printf("%s\n", zpl_str);

    Many other libraries do either of these:

    zpl_printf("%s\n", string->cstr);
    zpl_printf("%s\n", get_cstring(string));

    * You can access each character just like a C-style string:

    zpl_printf("%c %c\n", str[0], str[13]);

    * zpl strings are singularly allocated. The meta-data is next to the character
    array which is better for the cache.

    Disadvantages:

    * In the C version of these functions, many return the new string. i.e.
    str = zpl_string_appendc(str, "another string");
    This could be changed to zpl_string_appendc(&str, "another string"); but I'm still not sure.
*/

#if 0
#define ZPL_IMPLEMENTATION
#include "zpl.h"
int main(int argc, char **argv) {
    zpl_string str = zpl_string_make("Hello");
    zpl_string other_str = zpl_string_make_length(", ", 2);
    str = zpl_string_append(str, other_str);
    str = zpl_string_appendc(str, "world!");

    zpl_printf("%s\n", str); // Hello, world!

    zpl_printf("str length = %d\n", zpl_string_length(str));

    str = zpl_string_set(str, "Potato soup");
    zpl_printf("%s\n", str); // Potato soup

    str = zpl_string_set(str, "Hello");
    other_str = zpl_string_set(other_str, "Pizza");
    if (zpl_strings_are_equal(str, other_str))
        zpl_printf("Not called\n");
    else
        zpl_printf("Called\n");

    str = zpl_string_set(str, "Ab.;!...AHello World       ??");
    str = zpl_string_trim(str, "Ab.;!. ?");
    zpl_printf("%s\n", str); // "Hello World"

    zpl_string_free(str);
    zpl_string_free(other_str);

    return 0;
}
#endif


typedef char *zpl_string;

typedef struct zpl_string_header {
    zpl_allocator allocator;
    zpl_isize length;
    zpl_isize capacity;
} zpl_string_header;

#define ZPL_STRING_HEADER(str) (cast(zpl_string_header *)(str) - 1)

ZPL_DEF zpl_string zpl_string_make_reserve(zpl_allocator a, zpl_isize capacity);
ZPL_DEF zpl_string zpl_string_make(zpl_allocator a, const char *str);
ZPL_DEF zpl_string zpl_string_make_length(zpl_allocator a, void const *str, zpl_isize num_bytes);
ZPL_DEF zpl_string zpl_string_sprintf(zpl_allocator a, char *buf, zpl_isize num_bytes, const char *fmt, ...);
ZPL_DEF zpl_string zpl_string_sprintf_buf(zpl_allocator a, const char *fmt, ...); // NOTE: Uses locally persistent buffer
ZPL_DEF void       zpl_string_free(zpl_string str);
ZPL_DEF zpl_string zpl_string_duplicate(zpl_allocator a, zpl_string const str);
ZPL_DEF zpl_isize  zpl_string_length(zpl_string const str);
ZPL_DEF zpl_isize  zpl_string_capacity(zpl_string const str);
ZPL_DEF zpl_isize  zpl_string_available_space(zpl_string const str);
ZPL_DEF void       zpl_string_clear(zpl_string str);
ZPL_DEF zpl_string zpl_string_append(zpl_string str, zpl_string const other);
ZPL_DEF zpl_string zpl_string_append_length(zpl_string str, void const *other, zpl_isize num_bytes);
ZPL_DEF zpl_string zpl_string_appendc(zpl_string str, const char *other);
ZPL_DEF zpl_string zpl_string_join(zpl_allocator a, const char **parts, zpl_isize count, const char *glue);
ZPL_DEF zpl_string zpl_string_set(zpl_string str, const char *cstr);
ZPL_DEF zpl_string zpl_string_make_space_for(zpl_string str, zpl_isize add_len);
ZPL_DEF zpl_isize  zpl_string_allocation_size(zpl_string const str);
ZPL_DEF zpl_b32    zpl_string_are_equal(zpl_string const lhs, zpl_string const rhs);
ZPL_DEF zpl_string zpl_string_trim(zpl_string str, const char *cut_set);
ZPL_DEF zpl_string zpl_string_trim_space(zpl_string str); // Whitespace ` \t\r\n\v\f`
ZPL_DEF zpl_string zpl_string_append_rune(zpl_string str, zpl_rune r);
ZPL_DEF zpl_string zpl_string_append_fmt(zpl_string str, const char *fmt, ...);


//! @}
/** @file containers.c
@brief Memory containers
@defgroup containers Memory containers

Memory containers in various types: buffers, arrays, linked lists, ring buffers, ....

@{
*/

////////////////////////////////////////////////////////////////
//
// Fixed Capacity Buffer (POD Types)
//
//
// zpl_buffer(Type) works like zpl_string or zpl_array where the actual type is just a pointer to the first
// element.
//
// Available Procedures for zpl_buffer(Type)
// zpl_buffer_init
// zpl_buffer_free
// zpl_buffer_append
// zpl_buffer_appendv
// zpl_buffer_pop
// zpl_buffer_clear


typedef struct zpl_buffer_header {
    zpl_allocator backing;
    zpl_isize count;
    zpl_isize capacity;
} zpl_buffer_header;

#define zpl_buffer(Type) Type *

#define zpl_buffer_make(Type, Name, allocator, cap) Type *Name; zpl_buffer_init(Name, allocator, cap)

#define ZPL_BUFFER_HEADER(x)   (cast(zpl_buffer_header *)(x) - 1)
#define zpl_buffer_count(x)    (ZPL_BUFFER_HEADER(x)->count)
#define zpl_buffer_capacity(x) (ZPL_BUFFER_HEADER(x)->capacity)
#define zpl_buffer_end(x) (x + (zpl_buffer_count(x) - 1))

#define zpl_buffer_init(x, allocator, cap)                                                                             \
do {                                                                                                               \
    void **nx = cast(void **) & (x);                                                                               \
    zpl_buffer_header *zpl__bh =                                                                                   \
    cast(zpl_buffer_header *) zpl_alloc((allocator), sizeof(zpl_buffer_header) + (cap)*zpl_size_of(*(x)));     \
    zpl__bh->backing = allocator;                                                                                  \
    zpl__bh->count = 0;                                                                                            \
    zpl__bh->capacity = cap;                                                                                       \
    *nx = cast(void *)(zpl__bh + 1);                                                                               \
} while (0)

// DEPRECATED(zpl_buffer_free): Use zpl_buffer_free2 instead
#define zpl_buffer_free(x, allocator) (zpl_free(allocator, ZPL_BUFFER_HEADER(x)))
#define zpl_buffer_free2(x) (zpl_free(ZPL_BUFFER_HEADER(x)->backing, ZPL_BUFFER_HEADER(x)))

#define zpl_buffer_append(x, item)                                                                                     \
do { (x)[zpl_buffer_count(x)++] = (item); } while (0)

#define zpl_buffer_appendv(x, items, item_count)                                                                       \
do {                                                                                                               \
    ZPL_ASSERT(zpl_size_of(*(items)) == zpl_size_of(*(x)));                                                        \
    ZPL_ASSERT(zpl_buffer_count(x) + item_count <= zpl_buffer_capacity(x));                                        \
    zpl_memcopy(&(x)[zpl_buffer_count(x)], (items), zpl_size_of(*(x)) * (item_count));                             \
    zpl_buffer_count(x) += (item_count);                                                                           \
} while (0)

#define zpl_buffer_copy_init(y, x)                                                                                     \
do {                                                                                                               \
    zpl_buffer_init_reserve(y, zpl_buffer_allocator(x), zpl_buffer_capacity(x));                                   \
    zpl_memcopy(y, x, zpl_buffer_capacity(x) * zpl_size_of(*x));                                                   \
    zpl_buffer_count(y) = zpl_buffer_count(x);                                                                     \
} while (0)

#define zpl_buffer_pop(x)                                                                                              \
do {                                                                                                               \
    ZPL_ASSERT(zpl_buffer_count(x) > 0);                                                                           \
    zpl_buffer_count(x)--;                                                                                         \
} while (0)
#define zpl_buffer_clear(x)                                                                                            \
do { zpl_buffer_count(x) = 0; } while (0)

////////////////////////////////////////////////////////////////
//
// Linked List
//
// zpl_list encapsulates pointer to data and points to the next and the previous element in the list.
//
// Available Procedures for zpl_list
// zpl_list_init
// zpl_list_add
// zpl_list_remove

#if 0
#define ZPL_IMPLEMENTATION
#include "zpl.h"
int main(void)
{
    zpl_list s, *head, *cursor;
    zpl_list_init(&s, "it is optional to call init: ");
    head = cursor = &s;

    // since we can construct an element implicitly this way
    // the second field gets overwritten once we add it to a list.
    zpl_list a = {"hello"};
    cursor = zpl_list_add(cursor, &a);

    zpl_list b = {"world"};
    cursor = zpl_list_add(cursor, &b);

    zpl_list c = {"!!! OK"};
    cursor = zpl_list_add(cursor, &c);

    for (zpl_list *l=head; l; l=l->next) {
        zpl_printf("%s ", cast(char *)l->ptr);
    }
    zpl_printf("\n");

    return 0;
}
#endif


typedef struct zpl__list {
    void const *ptr;
    struct zpl__list *next, *prev;
} zpl_list;

ZPL_DEF void      zpl_list_init(zpl_list *list, void const *ptr);
ZPL_DEF zpl_list *zpl_list_add(zpl_list *list, zpl_list *item);

// NOTE(zaklaus): Returns a pointer to the next node (or NULL if the removed node has no trailing node.)
ZPL_DEF zpl_list *zpl_list_remove(zpl_list *list);

////////////////////////////////////////////////////////////////
//
// Dynamic Array (POD Types)
//
// zpl_array(Type) works like zpl_string or zpl_buffer where the actual type is just a pointer to the first
// element.
//
// Available Procedures for zpl_array(Type)
// zpl_array_init
// zpl_array_free
// zpl_array_set_capacity
// zpl_array_grow
// zpl_array_append
// zpl_array_appendv
// zpl_array_pop
// zpl_array_clear
// zpl_array_back
// zpl_array_front
// zpl_array_resize
// zpl_array_reserve
//

#if 0 // Example
void foo(void) {
    zpl_isize i;
    int test_values[] = {4, 2, 1, 7};
    zpl_allocator a = zpl_heap_allocator();
    zpl_array(int) items;

    zpl_array_init(items, a);

    zpl_array_append(items, 1);
    zpl_array_append(items, 4);
    zpl_array_append(items, 9);
    zpl_array_append(items, 16);

    items[1] = 3; // Manually set value
    // NOTE: No array bounds checking

    for (i = 0; i < items.count; i++)
        zpl_printf("%d\n", items[i]);
    // 1
    // 3
    // 9
    // 16

    zpl_array_clear(items);

    zpl_array_appendv(items, test_values, zpl_count_of(test_values));
    for (i = 0; i < items.count; i++)
        zpl_printf("%d\n", items[i]);
    // 4
    // 2
    // 1
    // 7

    zpl_array_free(items);
}
#endif


typedef struct zpl_array_header {
    char *data;
    zpl_isize count;
    zpl_isize capacity;
    zpl_allocator allocator;
} zpl_array_header;

#define zpl_array(Type) Type *

#define zpl_array_make(Type, Name, allocator) Type *Name; zpl_array_init(Name, allocator)

#ifndef ZPL_ARRAY_GROW_FORMULA
#define ZPL_ARRAY_GROW_FORMULA(x) (2 * (x) + 8)
#endif

ZPL_STATIC_ASSERT(ZPL_ARRAY_GROW_FORMULA(0) > 0);

#define ZPL_ARRAY_HEADER(x)    (cast(zpl_array_header *)(x) - 1)
#define zpl_array_allocator(x) (ZPL_ARRAY_HEADER(x)->allocator)
#define zpl_array_count(x)     (ZPL_ARRAY_HEADER(x)->count)
#define zpl_array_capacity(x)  (ZPL_ARRAY_HEADER(x)->capacity)
#define zpl_array_end(x)       (x + (zpl_array_count(x) - 1))

#define zpl_array_init_reserve(x, allocator_, cap)                                                                     \
do {                                                                                                               \
    void **zpl__array_ = cast(void **) & (x);                                                                      \
    zpl_array_header *zpl__ah =                                                                                    \
    cast(zpl_array_header *) zpl_alloc(allocator_, zpl_size_of(zpl_array_header) + zpl_size_of(*(x)) * (cap)); \
    zpl__ah->allocator = allocator_;                                                                               \
    zpl__ah->count = 0;                                                                                            \
    zpl__ah->data = (char *)x;                                                                                     \
    zpl__ah->capacity = cap;                                                                                       \
    *zpl__array_ = cast(void *)(zpl__ah + 1);                                                                      \
} while (0)

// NOTE: Give it an initial default capacity
#define zpl_array_init(x, allocator) zpl_array_init_reserve(x, allocator, ZPL_ARRAY_GROW_FORMULA(0))

#define zpl_array_free(x)                                                                                              \
do {                                                                                                               \
    zpl_array_header *zpl__ah = ZPL_ARRAY_HEADER(x);                                                               \
    zpl_free(zpl__ah->allocator, zpl__ah);                                                                         \
} while (0)

#define zpl_array_set_capacity(x, capacity)                                                                            \
do {                                                                                                               \
    if (x) {                                                                                                       \
        void **zpl__array_ = cast(void **) & (x);                                                                  \
        *zpl__array_ = zpl__array_set_capacity((x), (capacity), zpl_size_of(*(x)));                                \
    }                                                                                                              \
} while (0)

// NOTE: Do not use the thing below directly, use the macro
ZPL_DEF void *zpl__array_set_capacity(void *array, zpl_isize capacity, zpl_isize element_size);

#define zpl_array_grow(x, min_capacity)                                                                                \
do {                                                                                                               \
    zpl_isize new_capacity = ZPL_ARRAY_GROW_FORMULA(zpl_array_capacity(x));                                            \
    if (new_capacity < (min_capacity)) new_capacity = (min_capacity);                                              \
    zpl_array_set_capacity(x, new_capacity);                                                                       \
} while (0)

#define zpl_array_append(x, item)                                                                                      \
do {                                                                                                               \
    if (zpl_array_capacity(x) < zpl_array_count(x) + 1) zpl_array_grow(x, 0);                                      \
    (x)[zpl_array_count(x)++] = (item);                                                                            \
} while (0)

#define zpl_array_append_at(x, item, ind)                                                                              \
do {                                                                                                               \
    zpl_array_header *zpl__ah = ZPL_ARRAY_HEADER(x);                                                               \
    if (ind == zpl__ah->count) { zpl_array_append(x, item); break; }                                               \
    if (zpl_array_capacity(x) < zpl_array_count(x) + 1) zpl_array_grow(x, 0);                                      \
    zpl_memmove(&(x)[ind + 1], (x + ind), zpl_size_of(x[0]) * (zpl__ah->count - ind));                             \
    x[ind] = item;                                                                                                 \
    zpl__ah->count++;                                                                                              \
} while (0)

#define zpl_array_appendv(x, items, item_count)                                                                        \
do {                                                                                                               \
    zpl_array_header *zpl__ah = ZPL_ARRAY_HEADER(x);                                                               \
    ZPL_ASSERT(zpl_size_of((items)[0]) == zpl_size_of((x)[0]));                                                    \
    if (zpl__ah->capacity < zpl__ah->count + (item_count)) zpl_array_grow(x, zpl__ah->count + (item_count));       \
    zpl_memcopy(&(x)[zpl__ah->count], (items), zpl_size_of((x)[0]) * (item_count));                                \
    zpl__ah->count += (item_count);                                                                                \
} while (0)

#define zpl_array_remove_at(x, index)                                                                                  \
do {                                                                                                               \
    zpl_array_header *zpl__ah = ZPL_ARRAY_HEADER(x);                                                               \
    ZPL_ASSERT(index < zpl__ah->count);                                                                            \
    zpl_memmove(x + index, x + index + 1, zpl_size_of(x[0]) * (zpl__ah->count - index));                           \
    --zpl__ah->count;                                                                                              \
} while (0)

#define zpl_array_copy_init(y, x)                                                                                      \
do {                                                                                                               \
    zpl_array_init_reserve(y, zpl_array_allocator(x), zpl_array_capacity(x));                                      \
    zpl_memcopy(y, x, zpl_array_capacity(x) * zpl_size_of(*x));                                                    \
    zpl_array_count(y) = zpl_array_count(x);                                                                       \
} while (0)

#define zpl_array_pop(x)                                                                                               \
do {                                                                                                               \
    ZPL_ASSERT(ZPL_ARRAY_HEADER(x)->count > 0);                                                                    \
    ZPL_ARRAY_HEADER(x)->count--;                                                                                  \
} while (0)
#define zpl_array_back(x) x[ZPL_ARRAY_HEADER(x)->count - 1]
#define zpl_array_front(x) x[0]
#define zpl_array_clear(x)                                                                                             \
do { ZPL_ARRAY_HEADER(x)->count = 0; } while (0)

#define zpl_array_resize(x, new_count)                                                                                 \
do {                                                                                                               \
    if (ZPL_ARRAY_HEADER(x)->capacity < (new_count)) zpl_array_grow(x, (new_count));                               \
    ZPL_ARRAY_HEADER(x)->count = (new_count);                                                                      \
} while (0)

#define zpl_array_reserve(x, new_capacity)                                                                             \
do {                                                                                                               \
    if (ZPL_ARRAY_HEADER(x)->capacity < (new_capacity)) zpl_array_set_capacity(x, new_capacity);                   \
} while (0)

////////////////////////////////////////////////////////////////
//
// Instantiated Circular buffer
//
/*
int main()
{
    zpl_ring_zpl_u32 pad={0};
    zpl_ring_zpl_u32_init(&pad, zpl_heap(), 3);
    zpl_ring_zpl_u32_append(&pad, 1);
    zpl_ring_zpl_u32_append(&pad, 2);
    zpl_ring_zpl_u32_append(&pad, 3);

    while (!zpl_ring_zpl_u32_empty(&pad)) {
        zpl_printf("Result is %d\n", *zpl_ring_zpl_u32_get(&pad));
    }

    zpl_ring_zpl_u32_free(&pad);

    return 0;
}
*/

#define ZPL_RING_DECLARE(type)                                                                                         \
typedef struct {                                                                                                   \
    zpl_allocator backing;                                                                                         \
    zpl_buffer(type) buf;                                                                                          \
    zpl_usize head, tail;                                                                                              \
    zpl_usize capacity;                                                                                                \
} ZPL_JOIN2(zpl_ring_, type);                                                                                      \
\
ZPL_DEF void ZPL_JOIN3(zpl_ring_, type, _init)(ZPL_JOIN2(zpl_ring_, type) * pad, zpl_allocator a, zpl_isize max_size); \
ZPL_DEF void ZPL_JOIN3(zpl_ring_, type, _free)(ZPL_JOIN2(zpl_ring_, type) * pad);                                  \
ZPL_DEF zpl_b32 ZPL_JOIN3(zpl_ring_, type, _full)(ZPL_JOIN2(zpl_ring_, type) * pad);                                   \
ZPL_DEF zpl_b32 ZPL_JOIN3(zpl_ring_, type, _empty)(ZPL_JOIN2(zpl_ring_, type) * pad);                                  \
ZPL_DEF void ZPL_JOIN3(zpl_ring_, type, _append)(ZPL_JOIN2(zpl_ring_, type) * pad, type data);                     \
ZPL_DEF void ZPL_JOIN3(zpl_ring_, type, _append_array)(ZPL_JOIN2(zpl_ring_, type) * pad, zpl_array(type) data);    \
ZPL_DEF type *ZPL_JOIN3(zpl_ring_, type, _get)(ZPL_JOIN2(zpl_ring_, type) * pad);                                  \
ZPL_DEF zpl_array(type)                                                                                            \
ZPL_JOIN3(zpl_ring_, type, _get_array)(ZPL_JOIN2(zpl_ring_, type) * pad, zpl_usize max_size, zpl_allocator a);

#define ZPL_RING_DEFINE(type)                                                                                          \
void ZPL_JOIN3(zpl_ring_, type, _init)(ZPL_JOIN2(zpl_ring_, type) * pad, zpl_allocator a, zpl_isize max_size) {        \
    ZPL_JOIN2(zpl_ring_, type) pad_ = { 0 };                                                                       \
    *pad = pad_;                                                                                                   \
    \
    pad->backing = a;                                                                                              \
    zpl_buffer_init(pad->buf, a, max_size + 1);                                                                    \
    pad->capacity = max_size + 1;                                                                                  \
    pad->head = pad->tail = 0;                                                                                     \
}                                                                                                                  \
void ZPL_JOIN3(zpl_ring_, type, _free)(ZPL_JOIN2(zpl_ring_, type) * pad) {                                         \
    zpl_buffer_free(pad->buf, pad->backing);                                                                       \
}                                                                                                                  \
\
zpl_b32 ZPL_JOIN3(zpl_ring_, type, _full)(ZPL_JOIN2(zpl_ring_, type) * pad) {                                          \
    return ((pad->head + 1) % pad->capacity) == pad->tail;                                                         \
}                                                                                                                  \
\
zpl_b32 ZPL_JOIN3(zpl_ring_, type, _empty)(ZPL_JOIN2(zpl_ring_, type) * pad) { return pad->head == pad->tail; }        \
\
void ZPL_JOIN3(zpl_ring_, type, _append)(ZPL_JOIN2(zpl_ring_, type) * pad, type data) {                            \
    pad->buf[pad->head] = data;                                                                                    \
    pad->head = (pad->head + 1) % pad->capacity;                                                                   \
    \
    if (pad->head == pad->tail) { pad->tail = (pad->tail + 1) % pad->capacity; }                                   \
}                                                                                                                  \
\
void ZPL_JOIN3(zpl_ring_, type, _append_array)(ZPL_JOIN2(zpl_ring_, type) * pad, zpl_array(type) data) {           \
    zpl_usize c = zpl_array_count(data);                                                                               \
    for (zpl_usize i = 0; i < c; ++i) { ZPL_JOIN3(zpl_ring_, type, _append)(pad, data[i]); }                           \
}                                                                                                                  \
\
type *ZPL_JOIN3(zpl_ring_, type, _get)(ZPL_JOIN2(zpl_ring_, type) * pad) {                                         \
    if (ZPL_JOIN3(zpl_ring_, type, _empty)(pad)) { return NULL; }                                                  \
    \
    type *data = &pad->buf[pad->tail];                                                                             \
    pad->tail = (pad->tail + 1) % pad->capacity;                                                                   \
    \
    return data;                                                                                                   \
}                                                                                                                  \
\
zpl_array(type)                                                                                                    \
ZPL_JOIN3(zpl_ring_, type, _get_array)(ZPL_JOIN2(zpl_ring_, type) * pad, zpl_usize max_size, zpl_allocator a) {    \
    zpl_array(type) vals;                                                                                          \
    zpl_array_init(vals, a);                                                                                       \
    while (--max_size && !ZPL_JOIN3(zpl_ring_, type, _empty)(pad)) {                                               \
        zpl_array_append(vals, *ZPL_JOIN3(zpl_ring_, type, _get)(pad));                                            \
    }                                                                                                              \
    return vals;                                                                                                   \
}

//! @}
/** @file hashtable.c
@brief Instantiated hash table
@defgroup hashtable Instantiated hash table

@n
@n This is an attempt to implement a templated hash table
@n NOTE: The key is always a zpl_u64 for simplicity and you will _probably_ _never_ need anything bigger.
@n
@n Hash table type and function declaration, call: ZPL_TABLE_DECLARE(PREFIX, NAME, N, VALUE)
@n Hash table function definitions, call: ZPL_TABLE_DEFINE(NAME, N, VALUE)
@n
@n     PREFIX  - a prefix for function prototypes e.g. extern, static, etc.
@n     NAME    - Name of the Hash Table
@n     FUNC    - the name will prefix function names
@n     VALUE   - the type of the value to be stored
@n
@n tablename_init(NAME * h, zpl_allocator a);
@n tablename_destroy(NAME * h);
@n tablename_get(NAME * h, zpl_u64 key);
@n tablename_set(NAME * h, zpl_u64 key, VALUE value);
@n tablename_grow(NAME * h);
@n tablename_rehash(NAME * h, zpl_isize new_count);
@n tablename_remove(NAME * h, zpl_u64 key);

 @{
*/


typedef struct zpl_hash_table_find_result {
    zpl_isize hash_index;
    zpl_isize entry_prev;
    zpl_isize entry_index;
} zpl_hash_table_find_result;

#define ZPL_TABLE(PREFIX, NAME, FUNC, VALUE)                                                                           \
ZPL_TABLE_DECLARE(PREFIX, NAME, FUNC, VALUE);                                                                      \
ZPL_TABLE_DEFINE(NAME, FUNC, VALUE);

#define ZPL_TABLE_DECLARE(PREFIX, NAME, FUNC, VALUE)                                                                   \
typedef struct ZPL_JOIN2(NAME, Entry) {                                                                            \
    zpl_u64 key;                                                                                                       \
    zpl_isize next;                                                                                                    \
    VALUE value;                                                                                                   \
} ZPL_JOIN2(NAME, Entry);                                                                                          \
\
typedef struct NAME {                                                                                              \
    zpl_array(zpl_isize) hashes;                                                                                       \
    zpl_array(ZPL_JOIN2(NAME, Entry)) entries;                                                                     \
} NAME;                                                                                                            \
\
PREFIX void ZPL_JOIN2(FUNC, init)(NAME * h, zpl_allocator a);                                                      \
PREFIX void ZPL_JOIN2(FUNC, destroy)(NAME * h);                                                                    \
PREFIX VALUE *ZPL_JOIN2(FUNC, get)(NAME * h, zpl_u64 key);                                                             \
PREFIX void ZPL_JOIN2(FUNC, set)(NAME * h, zpl_u64 key, VALUE value);                                                  \
PREFIX void ZPL_JOIN2(FUNC, grow)(NAME * h);                                                                       \
PREFIX void ZPL_JOIN2(FUNC, rehash)(NAME * h, zpl_isize new_count);                                                    \
PREFIX void ZPL_JOIN2(FUNC, remove)(NAME * h, zpl_u64 key);

#define ZPL_TABLE_DEFINE(NAME, FUNC, VALUE)                                                                            \
void ZPL_JOIN2(FUNC, init)(NAME * h, zpl_allocator a) {                                                            \
    zpl_array_init(h->hashes, a);                                                                                  \
    zpl_array_init(h->entries, a);                                                                                 \
}                                                                                                                  \
\
void ZPL_JOIN2(FUNC, destroy)(NAME * h) {                                                                          \
    if (h->entries) zpl_array_free(h->entries);                                                                    \
    if (h->hashes) zpl_array_free(h->hashes);                                                                      \
}                                                                                                                  \
\
zpl_internal zpl_isize ZPL_JOIN2(FUNC, _add_entry)(NAME * h, zpl_u64 key) {                                                \
    zpl_isize index;                                                                                                   \
    ZPL_JOIN2(NAME, Entry) e = { 0 };                                                                              \
    e.key = key;                                                                                                   \
    e.next = -1;                                                                                                   \
    index = zpl_array_count(h->entries);                                                                           \
    zpl_array_append(h->entries, e);                                                                               \
    return index;                                                                                                  \
}                                                                                                                  \
\
zpl_internal zpl_hash_table_find_result ZPL_JOIN2(FUNC, _find)(NAME * h, zpl_u64 key) {                                \
    zpl_hash_table_find_result r = { -1, -1, -1 };                                                                 \
    if (zpl_array_count(h->hashes) > 0) {                                                                          \
        r.hash_index = key % zpl_array_count(h->hashes);                                                           \
        r.entry_index = h->hashes[r.hash_index];                                                                   \
        while (r.entry_index >= 0) {                                                                               \
            if (h->entries[r.entry_index].key == key) return r;                                                    \
            r.entry_prev = r.entry_index;                                                                          \
            r.entry_index = h->entries[r.entry_index].next;                                                        \
        }                                                                                                          \
    }                                                                                                              \
    return r;                                                                                                      \
}                                                                                                                  \
\
zpl_internal zpl_b32 ZPL_JOIN2(FUNC, _full)(NAME * h) {                                                                \
    return 0.75f * zpl_array_count(h->hashes) < zpl_array_count(h->entries);                                       \
}                                                                                                                  \
\
void ZPL_JOIN2(FUNC, grow)(NAME * h) {                                                                             \
    zpl_isize new_count = ZPL_ARRAY_GROW_FORMULA(zpl_array_count(h->entries));                                         \
    ZPL_JOIN2(FUNC, rehash)(h, new_count);                                                                         \
}                                                                                                                  \
\
void ZPL_JOIN2(FUNC, rehash)(NAME * h, zpl_isize new_count) {                                                          \
    zpl_isize i, j;                                                                                                    \
    NAME nh = { 0 };                                                                                               \
    ZPL_JOIN2(FUNC, init)(&nh, zpl_array_allocator(h->hashes));                                                    \
    zpl_array_resize(nh.hashes, new_count);                                                                        \
    zpl_array_reserve(nh.entries, zpl_array_count(h->entries));                                                    \
    for (i = 0; i < new_count; i++) nh.hashes[i] = -1;                                                             \
    for (i = 0; i < zpl_array_count(h->entries); i++) {                                                            \
        ZPL_JOIN2(NAME, Entry) * e;                                                                                \
        zpl_hash_table_find_result fr;                                                                             \
        if (zpl_array_count(nh.hashes) == 0) ZPL_JOIN2(FUNC, grow)(&nh);                                           \
        e = &h->entries[i];                                                                                        \
        fr = ZPL_JOIN2(FUNC, _find)(&nh, e->key);                                                                  \
        j = ZPL_JOIN2(FUNC, _add_entry)(&nh, e->key);                                                              \
        if (fr.entry_prev < 0)                                                                                     \
        nh.hashes[fr.hash_index] = j;                                                                          \
        else                                                                                                       \
        nh.entries[fr.entry_prev].next = j;                                                                    \
        nh.entries[j].next = fr.entry_index;                                                                       \
        nh.entries[j].value = e->value;                                                                            \
    }                                                                                                              \
    ZPL_JOIN2(FUNC, destroy)(h);                                                                                   \
    h->hashes = nh.hashes;                                                                                         \
    h->entries = nh.entries;                                                                                       \
}                                                                                                                  \
\
VALUE *ZPL_JOIN2(FUNC, get)(NAME * h, zpl_u64 key) {                                                                   \
    zpl_isize index = ZPL_JOIN2(FUNC, _find)(h, key).entry_index;                                                      \
    if (index >= 0) return &h->entries[index].value;                                                               \
    return NULL;                                                                                                   \
}                                                                                                                  \
\
void ZPL_JOIN2(FUNC, remove)(NAME * h, zpl_u64 key) {                                                                  \
    zpl_hash_table_find_result fr = ZPL_JOIN2(FUNC, _find)(h, key);                                                \
    if (fr.entry_index >= 0) {                                                                                     \
        if (fr.entry_prev >= 0) {                                                                                  \
            h->entries[fr.entry_prev].next = h->entries[fr.entry_index].next;                                      \
        } else {                                                                                                   \
            h->hashes[fr.hash_index] = fr.entry_index;                                                             \
        }                                                                                                          \
        zpl_array_remove_at(h->entries, fr.entry_index);                                                           \
    }                                                                                                              \
    ZPL_JOIN2(FUNC, rehash)(h, zpl_array_count(h->entries));                                                       \
}                                                                                                                  \
\
void ZPL_JOIN2(FUNC, set)(NAME * h, zpl_u64 key, VALUE value) {                                                        \
    zpl_isize index;                                                                                                   \
    zpl_hash_table_find_result fr;                                                                                 \
    if (zpl_array_count(h->hashes) == 0) ZPL_JOIN2(FUNC, grow)(h);                                                 \
    fr = ZPL_JOIN2(FUNC, _find)(h, key);                                                                           \
    if (fr.entry_index >= 0) {                                                                                     \
        index = fr.entry_index;                                                                                    \
    } else {                                                                                                       \
        index = ZPL_JOIN2(FUNC, _add_entry)(h, key);                                                               \
        if (fr.entry_prev >= 0) {                                                                                  \
            h->entries[fr.entry_prev].next = index;                                                                \
        } else {                                                                                                   \
            h->hashes[fr.hash_index] = index;                                                                      \
        }                                                                                                          \
    }                                                                                                              \
    h->entries[index].value = value;                                                                               \
    if (ZPL_JOIN2(FUNC, _full)(h)) ZPL_JOIN2(FUNC, grow)(h);                                                       \
}\

//! @}
/** @file file.c
@brief File handling
@defgroup fileio File handling

File I/O operations as well as path and folder structure manipulation methods. With threading enabled, it also offers async read/write methods.

@{
*/

typedef zpl_u32 zpl_file_mode;

#define zplFileModeFlag zpl_file_mode_flag
typedef enum zpl_file_mode_flag {
    ZPL_FILE_MODE_READ   = ZPL_BIT(0),
    ZPL_FILE_MODE_WRITE  = ZPL_BIT(1),
    ZPL_FILE_MODE_APPEND = ZPL_BIT(2),
    ZPL_FILE_MODE_RW     = ZPL_BIT(3),

    ZPL_FILE_MODES       = ZPL_FILE_MODE_READ | ZPL_FILE_MODE_WRITE | ZPL_FILE_MODE_APPEND | ZPL_FILE_MODE_RW,
} zpl_file_mode_flag;

// NOTE: Only used internally and for the file operations
#define zplSeekWhenceType zpl_seek_whence_type
typedef enum zpl_seek_whence_type {
    ZPL_SEEK_WHENCE_BEGIN   = 0,
    ZPL_SEEK_WHENCE_CURRENT = 1,
    ZPL_SEEK_WHENCE_END     = 2,
} zpl_seek_whence_type;

#define zplFileError zpl_file_error
typedef enum zpl_file_error {
    ZPL_FILE_ERROR_NONE,
    ZPL_FILE_ERROR_INVALID,
    ZPL_FILE_ERROR_INVALID_FILENAME,
    ZPL_FILE_ERROR_EXISTS,
    ZPL_FILE_ERROR_NOT_EXISTS,
    ZPL_FILE_ERROR_PERMISSION,
    ZPL_FILE_ERROR_TRUNCATION_FAILURE,
    ZPL_FILE_ERROR_NOT_EMPTY,
    ZPL_FILE_ERROR_NAME_TOO_LONG,
    ZPL_FILE_ERROR_UNKNOWN,
} zpl_file_error;


typedef union zpl_file_descriptor {
    void *p;
    zpl_intptr i;
    zpl_uintptr u;
} zpl_file_descriptor;


typedef struct zpl_file_operations zpl_file_operations;

#define ZPL_FILE_OPEN_PROC(name)                                                                                       \
zpl_file_error name(zpl_file_descriptor *fd, zpl_file_operations *ops, zpl_file_mode mode, char const *filename)
#define ZPL_FILE_READ_AT_PROC(name)                                                                                    \
zpl_b32 name(zpl_file_descriptor fd, void *buffer, zpl_isize size, zpl_i64 offset, zpl_isize *bytes_read, zpl_b32 stop_at_newline)
#define ZPL_FILE_WRITE_AT_PROC(name)                                                                                   \
zpl_b32 name(zpl_file_descriptor fd, void const *buffer, zpl_isize size, zpl_i64 offset, zpl_isize *bytes_written)
#define ZPL_FILE_SEEK_PROC(name) zpl_b32 name(zpl_file_descriptor fd, zpl_i64 offset, zpl_seek_whence_type whence, zpl_i64 *new_offset)
#define ZPL_FILE_CLOSE_PROC(name) void name(zpl_file_descriptor fd)

typedef ZPL_FILE_OPEN_PROC(zpl_file_open_proc);
typedef ZPL_FILE_READ_AT_PROC(zpl_file_read_proc);
typedef ZPL_FILE_WRITE_AT_PROC(zpl_file_write_proc);
typedef ZPL_FILE_SEEK_PROC(zpl_file_seek_proc);
typedef ZPL_FILE_CLOSE_PROC(zpl_file_close_proc);

struct zpl_file_operations {
    zpl_file_read_proc  *read_at;
    zpl_file_write_proc *write_at;
    zpl_file_seek_proc  *seek;
    zpl_file_close_proc *close;
};

extern zpl_file_operations const zpl_default_file_operations;

typedef zpl_u64 zpl_file_time;
typedef enum zpl_dir_type {
    ZPL_DIR_TYPE_FILE,
    ZPL_DIR_TYPE_FOLDER,
    ZPL_DIR_TYPE_UNKNOWN,
} zpl_dir_type;

struct zpl_dir_info;

typedef struct zpl_dir_entry {
    char const *filename;
    struct zpl_dir_info *dir_info;
    zpl_u8 type;
} zpl_dir_entry;

typedef struct zpl_dir_info {
    char const    *fullpath;
    zpl_dir_entry *entries; // zpl_array

    // Internals
    char **filenames; // zpl_array
    zpl_string buf;
} zpl_dir_info;

typedef struct zpl_file {
    zpl_file_operations ops;
    zpl_file_descriptor fd;

    char const    *filename;
    zpl_file_time last_write_time;
    zpl_dir_entry *dir;
} zpl_file;

#define zplFileStandardType zpl_file_standard_type
typedef enum zpl_file_standard_type {
    ZPL_FILE_STANDARD_INPUT,
    ZPL_FILE_STANDARD_OUTPUT,
    ZPL_FILE_STANDARD_ERROR,

    ZPL_FILE_STANDARD_COUNT,
} zpl_file_standard_type;

/**
 * Get standard file I/O.
 * @param  std Check zpl_file_standard_type
 * @return     File handle to standard I/O
 */
ZPL_DEF zpl_file    *zpl_file_get_standard(zpl_file_standard_type std);

/**
 * Connects a system handle to a ZPL file.
 * @param  file   Pointer to ZPL file
 * @param  handle Low-level OS handle to connect
 */
ZPL_DEF void         zpl_file_connect_handle(zpl_file *file, void *handle);

/**
 * Creates a new file
 * @param  file
 * @param  filename
 */
ZPL_DEF zpl_file_error zpl_file_create(zpl_file *file, char const *filename);

/**
 * Opens a file
 * @param  file
 * @param  filename
 */
ZPL_DEF zpl_file_error zpl_file_open(zpl_file *file, char const *filename);

/**
 * Opens a file using a specified mode
 * @param  file
 * @param  mode     Access mode to use
 * @param  filename
 */
ZPL_DEF zpl_file_error zpl_file_open_mode(zpl_file *file, zpl_file_mode mode, char const *filename);

/**
 * Constructs a new file from data
 * @param  file
 * @param  fd       Low-level file descriptor to use
 * @param  ops      File operations to rely upon
 * @param  filename
 */
ZPL_DEF zpl_file_error zpl_file_new(zpl_file *file, zpl_file_descriptor fd, zpl_file_operations ops, char const *filename);

/**
 * Reads file safely
 * @param  file
 * @param  buffer     Buffer to read to
 * @param  size       Size to read
 * @param  offset     Offset to read from
 * @param  bytes_read How much data we've actually read
 */
ZPL_DEF zpl_b32        zpl_file_read_at_check(zpl_file *file, void *buffer, zpl_isize size, zpl_i64 offset, zpl_isize *bytes_read);

/**
 * Writes to file safely
 * @param  file
 * @param  buffer        Buffer to read from
 * @param  size          Size to write
 * @param  offset        Offset to write to
 * @param  bytes_written How much data we've actually written
 */
ZPL_DEF zpl_b32        zpl_file_write_at_check(zpl_file *file, void const *buffer, zpl_isize size, zpl_i64 offset, zpl_isize *bytes_written);


/**
 * Reads file at a specific offset
 * @param  file
 * @param  buffer     Buffer to read to
 * @param  size       Size to read
 * @param  offset     Offset to read from
 * @param  bytes_read How much data we've actually read
 */
ZPL_DEF zpl_b32        zpl_file_read_at(zpl_file *file, void *buffer, zpl_isize size, zpl_i64 offset);

/**
 * Writes to file at a specific offset
 * @param  file
 * @param  buffer        Buffer to read from
 * @param  size          Size to write
 * @param  offset        Offset to write to
 * @param  bytes_written How much data we've actually written
 */
ZPL_DEF zpl_b32        zpl_file_write_at(zpl_file *file, void const *buffer, zpl_isize size, zpl_i64 offset);

/**
 * Seeks the file cursor from the beginning of file to a specific position
 * @param  file
 * @param  offset Offset to seek to
 */
ZPL_DEF zpl_i64        zpl_file_seek(zpl_file *file, zpl_i64 offset);

/**
 * Seeks the file cursor to the end of the file
 * @param  file
 */
ZPL_DEF zpl_i64        zpl_file_seek_to_end(zpl_file *file);

/**
 * Skips N bytes at the current position
 * @param  file
 * @param  bytes Bytes to skip
 */
ZPL_DEF zpl_i64        zpl_file_skip(zpl_file *file, zpl_i64 bytes); // NOTE: Skips a certain amount of bytes

/**
 * Returns the length from the beginning of the file we've read so far
 * @param  file
 * @return      Our current position in file
 */
ZPL_DEF zpl_i64        zpl_file_tell(zpl_file *file);

/**
 * Closes the file
 * @param  file
 */
ZPL_DEF zpl_file_error zpl_file_close(zpl_file *file);

/**
 * Reads from a file
 * @param  file
 * @param  buffer Buffer to read to
 * @param  size   Size to read
 */
ZPL_DEF zpl_b32        zpl_file_read(zpl_file *file, void *buffer, zpl_isize size);

/**
 * Writes to a file
 * @param  file
 * @param  buffer Buffer to read from
 * @param  size   Size to read
 */
ZPL_DEF zpl_b32        zpl_file_write(zpl_file *file, void const *buffer, zpl_isize size);

/**
 * Returns a size of the file
 * @param  file
 * @return      File size
 */
ZPL_DEF zpl_i64        zpl_file_size(zpl_file *file);

/**
 * Returns the currently opened file's name
 * @param  file
 */
ZPL_DEF char const    *zpl_file_name(zpl_file *file);

/**
 * Truncates the file by a specified size
 * @param  file
 * @param  size Size to truncate
 */
ZPL_DEF zpl_file_error zpl_file_truncate(zpl_file *file, zpl_i64 size);

/**
 * Checks whether a file's been changed since the last check
 * @param  file
 */
ZPL_DEF zpl_b32 zpl_file_has_changed(zpl_file *file);

/**
 * Retrieves a directory listing relative to the file
 * @param file
 */
ZPL_DEF void zpl_file_dirinfo_refresh(zpl_file *file);

/**
 * Creates a temporary file
 * @param  file
 */
zpl_file_error zpl_file_temp(zpl_file *file);

typedef struct zpl_file_contents {
    zpl_allocator allocator;
    void *data;
    zpl_isize size;
} zpl_file_contents;

/**
 * Reads the whole file contents
 * @param  a              Allocator to use
 * @param  zero_terminate End the read data with null terminator
 * @param  filepath       Path to the file
 * @return                File contents data
 */
ZPL_DEF zpl_file_contents zpl_file_read_contents(zpl_allocator a, zpl_b32 zero_terminate, char const *filepath);

/**
 * Frees the file content data previously read
 * @param  fc
 */
ZPL_DEF void              zpl_file_free_contents(zpl_file_contents *fc);

/**
 * Reads the file as array of lines
 *
 * Make sure you free both the returned buffer and the lines (zpl_array)
 * @param  alloc            Allocator to use
 * @param  lines            Reference to zpl_array container we store lines to
 * @param  filename         Path to the file
 * @param  strip_whitespace Strip whitespace when we split to lines?
 * @return                  File content we've read itself
 */
ZPL_DEF char *zpl_file_read_lines(zpl_allocator alloc, zpl_array(char *) * lines, char const *filename,
                                  zpl_b32 strip_whitespace);

/**
 * Checks if file/directory exists
 * @param  filepath
 */
ZPL_DEF zpl_b32       zpl_fs_exists(char const *filepath);

/**
 * Retrieves node's type (file, folder, ...)
 * @param  path
 */
ZPL_DEF zpl_u8        zpl_fs_get_type(char const *path);

/**
 * Retrieves file's last write time
 * @param  filepath
 */
ZPL_DEF zpl_file_time zpl_fs_last_write_time(char const *filepath);

/**
 * Copies the file to a directory
 * @param  existing_filename
 * @param  new_filename
 * @param  fail_if_exists
 */
ZPL_DEF zpl_b32       zpl_fs_copy(char const *existing_filename, char const *new_filename, zpl_b32 fail_if_exists);

/**
 * Moves the file to a directory
 * @param  existing_filename
 * @param  new_filename
 */
ZPL_DEF zpl_b32       zpl_fs_move(char const *existing_filename, char const *new_filename);

/**
 * Removes a file from a directory
 * @param  filename
 */
ZPL_DEF zpl_b32       zpl_fs_remove(char const *filename);

#ifndef ZPL_PATH_SEPARATOR
#if defined(ZPL_SYSTEM_WINDOWS)
#define ZPL_PATH_SEPARATOR '\\'
#else
#define ZPL_PATH_SEPARATOR '/'
#endif
#endif

ZPL_DEF zpl_b32 zpl_path_is_absolute(char const *path);
ZPL_DEF zpl_b32 zpl_path_is_relative(char const *path);
ZPL_DEF zpl_b32 zpl_path_is_root(char const *path);
ZPL_DEF void    zpl_path_fix_slashes(char *path);

ZPL_DEF char const *zpl_path_base_name(char const *path);
ZPL_DEF char const *zpl_path_extension(char const *path);
ZPL_DEF char       *zpl_path_get_full_name(zpl_allocator a, char const *path);

ZPL_DEF zpl_file_error zpl_path_mkdir(char const *path, zpl_i32 mode);
ZPL_DEF zpl_file_error zpl_path_rmdir(char const *path);

/**
 * Returns file paths terminated by newline (\n)
 * @param  alloc   [description]
 * @param  dirname [description]
 * @param  recurse [description]
 * @return         [description]
 */
ZPL_DEF zpl_string zpl_path_dirlist(zpl_allocator alloc, char const *dirname, zpl_b32 recurse);

/**
 * Initialize dirinfo from specified path
 * @param dir  [description]
 * @param path [description]
 */
ZPL_DEF void zpl_dirinfo_init(zpl_dir_info *dir, char const *path);
ZPL_DEF void zpl_dirinfo_free(zpl_dir_info *dir);

/**
 * Analyze the entry's dirinfo
 * @param dir_entry [description]
 */
ZPL_DEF void zpl_dirinfo_step(zpl_dir_entry *dir_entry);

//! @}
/** @file print.c
@brief Printing methods
@defgroup print Printing methods

Various printing methods.
@{
*/

ZPL_DEF zpl_isize zpl_printf(char const *fmt, ...) ZPL_PRINTF_ARGS(1);
ZPL_DEF zpl_isize zpl_printf_va(char const *fmt, va_list va);
ZPL_DEF zpl_isize zpl_printf_err(char const *fmt, ...) ZPL_PRINTF_ARGS(1);
ZPL_DEF zpl_isize zpl_printf_err_va(char const *fmt, va_list va);
ZPL_DEF zpl_isize zpl_fprintf(zpl_file *f, char const *fmt, ...) ZPL_PRINTF_ARGS(2);
ZPL_DEF zpl_isize zpl_fprintf_va(zpl_file *f, char const *fmt, va_list va);

// NOTE: A locally persisting buffer is used internally
ZPL_DEF char *zpl_bprintf(char const *fmt, ...) ZPL_PRINTF_ARGS(1);

// NOTE: A locally persisting buffer is used internally
ZPL_DEF char *zpl_bprintf_va(char const *fmt, va_list va);

ZPL_DEF zpl_isize zpl_snprintf(char *str, zpl_isize n, char const *fmt, ...) ZPL_PRINTF_ARGS(3);
ZPL_DEF zpl_isize zpl_snprintf_va(char *str, zpl_isize n, char const *fmt, va_list va);


//! @}
/** @file time.c
@brief Time helper methods.
@defgroup time Time helpers

 Helper methods for retrieving the current time in many forms under different precisions. It also offers a simple to use timer library.

 @{
 */

//! Return CPU timestamp.
ZPL_DEF zpl_u64 zpl_rdtsc(void);

//! Return relative time since the application start.
ZPL_DEF zpl_f64 zpl_time_now(void);

//! Return time since 1601-01-01 UTC.
ZPL_DEF zpl_f64 zpl_utc_time_now(void);

//! Sleep for specified number of milliseconds.
ZPL_DEF void zpl_sleep_ms(zpl_u32 ms);

typedef void (*zpl_timer_cb)(void *data);

//! Timer data structure
typedef struct zpl_timer {
    zpl_timer_cb callback;
    zpl_b32 enabled;
    zpl_i32 remaining_calls;
    zpl_i32 initial_calls;
    zpl_f64 next_call_ts;
    zpl_f64 duration;
    void *user_data;
} zpl_timer;

typedef zpl_timer *zpl_timer_pool; ///< zpl_array

//! Initialize timer pool.
#define zpl_timer_init(pool, allocator) zpl_array_init(pool, allocator)

//! Add new timer to pool and return it.
ZPL_DEF zpl_timer *zpl_timer_add(zpl_timer_pool pool);

//! Perform timer pool update.

//! Traverse over all timers and update them accordingly. Should be called by Main Thread in a tight loop.
ZPL_DEF void zpl_timer_update(zpl_timer_pool pool);

//! Set up timer.

//! Set up timer with specific options.
//! @param timer
//! @param duration How long/often to fire a timer.
//! @param count How many times we fire a timer. Use -1 for infinity.
//! @param callback A method to execute once a timer triggers.
ZPL_DEF void zpl_timer_set(zpl_timer *timer, zpl_f64 /* microseconds */ duration, zpl_i32 /* -1 for INFINITY */ count,
                           zpl_timer_cb callback);

//! Start timer with specified delay.
ZPL_DEF void zpl_timer_start(zpl_timer *timer, zpl_f64 delay_start);

//! Stop timer and prevent it from triggering.
ZPL_DEF void zpl_timer_stop(zpl_timer *timer);

//! @}
/** @file misc.c
@brief Various other stuff
@defgroup misc Various other stuff

 Methods that don't belong anywhere but are still very useful in many occasions.

 @{
 */


typedef struct zpl_random {
    zpl_u32 offsets[8];
    zpl_u32 value;
} zpl_random;

// NOTE: Generates from numerous sources to produce a decent pseudo-random seed
ZPL_DEF void      zpl_random_init(zpl_random *r);
ZPL_DEF zpl_u32   zpl_random_gen_u32(zpl_random *r);
ZPL_DEF zpl_u32   zpl_random_gen_u32_unique(zpl_random *r);
ZPL_DEF zpl_u64   zpl_random_gen_u64(zpl_random *r); // NOTE: (zpl_random_gen_u32() << 32) | zpl_random_gen_u32()
ZPL_DEF zpl_isize zpl_random_gen_isize(zpl_random *r);
ZPL_DEF zpl_i64   zpl_random_range_i64(zpl_random *r, zpl_i64 lower_inc, zpl_i64 higher_inc);
ZPL_DEF zpl_isize zpl_random_range_isize(zpl_random *r, zpl_isize lower_inc, zpl_isize higher_inc);
ZPL_DEF zpl_f64   zpl_random_range_f64(zpl_random *r, zpl_f64 lower_inc, zpl_f64 higher_inc);

ZPL_DEF void zpl_exit(zpl_u32 code);
ZPL_DEF void zpl_yield(void);

//! Returns allocated buffer
ZPL_DEF const char *zpl_get_env(const char *name);
ZPL_DEF const char *zpl_get_env_buf(const char *name);
ZPL_DEF zpl_string  zpl_get_env_str(const char *name);
ZPL_DEF void        zpl_set_env(const char *name, const char *value);
ZPL_DEF void        zpl_unset_env(const char *name);

ZPL_DEF zpl_u16 zpl_endian_swap16(zpl_u16 i);
ZPL_DEF zpl_u32 zpl_endian_swap32(zpl_u32 i);
ZPL_DEF zpl_u64 zpl_endian_swap64(zpl_u64 i);

ZPL_DEF zpl_isize zpl_count_set_bits(zpl_u64 mask);

ZPL_DEF zpl_u32    zpl_system_command(const char *command, zpl_usize buffer_len, char *buffer);
ZPL_DEF zpl_string zpl_system_command_str(const char *command, zpl_allocator backing);

//! @}
/** @file opts.c
@brief CLI options processor
@defgroup cli CLI options processor

 Opts is a CLI options parser, it can parse flags, switches and arguments from command line
 and offers an easy way to express input errors as well as the ability to display help screen.

@{
 */

typedef enum {
    ZPL_OPTS_STRING,
    ZPL_OPTS_FLOAT,
    ZPL_OPTS_FLAG,
    ZPL_OPTS_INT,
} zpl_opts_types;

typedef struct {
    char const *name, *lname, *desc;
    zpl_u8 type;
    zpl_b32 met, pos;

    //! values
    union {
        zpl_string text;
        zpl_i64 integer;
        zpl_f64 real;
    };
} zpl_opts_entry;

typedef enum {
    ZPL_OPTS_ERR_VALUE,
    ZPL_OPTS_ERR_OPTION,
    ZPL_OPTS_ERR_EXTRA_VALUE,
    ZPL_OPTS_ERR_MISSING_VALUE,
} zpl_opts_err_type;

typedef struct {
    char *val;
    zpl_u8 type;
} zpl_opts_err;

typedef struct {
    zpl_allocator    alloc;
    zpl_opts_entry  *entries;   ///< zpl_array
    zpl_opts_err    *errors;    ///< zpl_array
    zpl_opts_entry **positioned; ///< zpl_array
    char const      *appname;
} zpl_opts;

//! Initializes options parser.

//! Initializes CLI options parser using specified memory allocator and provided application name.
//! @param opts Options parser to initialize.
//! @param allocator Memory allocator to use. (ex. zpl_heap())
//! @param app Application name displayed in help screen.
ZPL_DEF void zpl_opts_init(zpl_opts *opts, zpl_allocator allocator, char const *app);

//! Releases the resources used by options parser.
ZPL_DEF void zpl_opts_free(zpl_opts *opts);

//! Registers an option.

//! Registers an option with its short and long name, specifies option's type and its description.
//! @param opts Options parser to add to.
//! @param lname Shorter name of option. (ex. "f")
//! @param name Full name of option. (ex. "foo") Note that rest of the module uses longer names to manipulate opts.
//! @param desc Description shown in the help screen.
//! @param type Option's type (see zpl_opts_types)
//! @see zpl_opts_types
ZPL_DEF void zpl_opts_add(zpl_opts *opts, char const *name, char const *lname, const char *desc, zpl_u8 type);

//! Registers option as positional.

//! Registers added option as positional, so that we can pass it anonymously. Arguments are expected on the command input in the same order they were registered as.
//! @param opts
//! @param name Name of already registered option.
ZPL_DEF void zpl_opts_positional_add(zpl_opts *opts, char const *name);

//! Compiles CLI arguments.

// This method takes CLI arguments as input and processes them based on rules that were set up.
//! @param opts
//! @param argc Argument count in an array.
//! @param argv Array of arguments.
ZPL_DEF zpl_b32 zpl_opts_compile(zpl_opts *opts, int argc, char **argv);

//! Prints out help screen.

//! Prints out help screen with example usage of application as well as with all the flags available.
ZPL_DEF void zpl_opts_print_help(zpl_opts *opts);

//! Prints out parsing errors.

//! Prints out possible errors caused by CLI input.
ZPL_DEF void zpl_opts_print_errors(zpl_opts *opts);

//! Fetches a string from an option.

//! @param opts
//! @param name Name of an option.
//! @param fallback Fallback string we return if option wasn't found.
ZPL_DEF zpl_string zpl_opts_string(zpl_opts *opts, char const *name, char const *fallback);

//! Fetches a real number from an option.

//! @param opts
//! @param name Name of an option.
//! @param fallback Fallback real number we return if option was not found.
ZPL_DEF zpl_f64 zpl_opts_real(zpl_opts *opts, char const *name, zpl_f64 fallback);

//! Fetches an integer number from an option.

//! @param opts
//! @param name Name of an option.
//! @param fallback Fallback integer number we return if option was not found.
ZPL_DEF zpl_i64 zpl_opts_integer(zpl_opts *opts, char const *name, zpl_i64 fallback);

//! Checks whether an option was used.

//! @param opts
//! @param name Name of an option.
ZPL_DEF zpl_b32 zpl_opts_has_arg(zpl_opts *opts, char const *name);

//! Checks whether all positionals have been passed in.
ZPL_DEF zpl_b32 zpl_opts_positionals_filled(zpl_opts *opts);

//! @}
/** @file math.c
@brief Math operations
@defgroup math Math operations

OpenGL gamedev friendly library for math.

@{
*/

typedef union zpl_vec2 {
    struct {
        zpl_f32 x, y;
    };
    zpl_f32 e[2];
} zpl_vec2;

typedef union zpl_vec3 {
    struct {
        zpl_f32 x, y, z;
    };
    struct {
        zpl_f32 r, g, b;
    };

    zpl_vec2 xy;
    zpl_f32 e[3];
} zpl_vec3;

typedef union zpl_vec4 {
    struct {
        zpl_f32 x, y, z, w;
    };
    struct {
        zpl_f32 r, g, b, a;
    };
    struct {
        zpl_vec2 xy, zw;
    };
    zpl_vec3 xyz;
    zpl_vec3 rgb;
    zpl_f32 e[4];
} zpl_vec4;

typedef union zpl_mat2 {
    struct {
        zpl_vec2 x, y;
    };
    zpl_vec2 col[2];
    zpl_f32 e[4];
} zpl_mat2;

typedef union zpl_mat3 {
    struct {
        zpl_vec3 x, y, z;
    };
    zpl_vec3 col[3];
    zpl_f32 e[9];
} zpl_mat3;

typedef union zpl_mat4 {
    struct {
        zpl_vec4 x, y, z, w;
    };
    zpl_vec4 col[4];
    zpl_f32 e[16];
} zpl_mat4;

typedef union zpl_quat {
    struct {
        zpl_f32 x, y, z, w;
    };
    zpl_vec4 xyzw;
    zpl_vec3 xyz;
    zpl_f32 e[4];
} zpl_quat;

typedef zpl_f32 zpl_float2[2];
typedef zpl_f32 zpl_float3[3];
typedef zpl_f32 zpl_float4[4];

typedef struct zpl_rect2 {
    zpl_vec2 pos, dim;
} zpl_rect2;
typedef struct zpl_rect3 {
    zpl_vec3 pos, dim;
} zpl_rect3;

typedef struct zpl_aabb2 {
    zpl_vec2 centre, half_size;
} zpl_aabb2;
typedef struct zpl_aabb3 {
    zpl_vec3 centre, half_size;
} zpl_aabb3;

typedef short zpl_half;

#ifndef ZPL_CONSTANTS
#define ZPL_CONSTANTS
#define ZPL_EPSILON    1.19209290e-7f
#define ZPL_ZERO       0.0f
#define ZPL_ONE        1.0f
#define ZPL_TWO_THIRDS 0.666666666666666666666666666666666666667f

#define ZPL_TAU          6.28318530717958647692528676655900576f
#define ZPL_PI           3.14159265358979323846264338327950288f
#define ZPL_ONE_OVER_TAU 0.636619772367581343075535053490057448f
#define ZPL_ONE_OVER_PI  0.159154943091895335768883763372514362f

#define ZPL_TAU_OVER_2 3.14159265358979323846264338327950288f
#define ZPL_TAU_OVER_4 1.570796326794896619231321691639751442f
#define ZPL_TAU_OVER_8 0.785398163397448309615660845819875721f

#define ZPL_E          2.71828182845904523536f
#define ZPL_SQRT_TWO   1.41421356237309504880168872420969808f
#define ZPL_SQRT_THREE 1.73205080756887729352744634150587236f
#define ZPL_SQRT_FIVE  2.23606797749978969640917366873127623f

#define ZPL_LOG_TWO 0.693147180559945309417232121458176568f
#define ZPL_LOG_TEN 2.30258509299404568401799145468436421f
#endif // ZPL_CONSTANTS

#ifndef zpl_square
#define zpl_square(x) ((x) * (x))
#endif

#ifndef zpl_cube
#define zpl_cube(x) ((x) * (x) * (x))
#endif

#ifndef zpl_sign
#define zpl_sign(x) ((x) >= 0 ? 1 : -1)
#endif

ZPL_DEF zpl_f32 zpl_to_radians(zpl_f32 degrees);
ZPL_DEF zpl_f32 zpl_to_degrees(zpl_f32 radians);

/* NOTE: Because to interpolate angles */
ZPL_DEF zpl_f32 zpl_angle_diff(zpl_f32 radians_a, zpl_f32 radians_b);

ZPL_DEF zpl_f32 zpl_copy_sign(zpl_f32 x, zpl_f32 y);
ZPL_DEF zpl_f32 zpl_remainder(zpl_f32 x, zpl_f32 y);
ZPL_DEF zpl_f32 zpl_mod(zpl_f32 x, zpl_f32 y);
ZPL_DEF zpl_f64 zpl_copy_sign64(zpl_f64 x, zpl_f64 y);
ZPL_DEF zpl_f64 zpl_floor64(zpl_f64 x);
ZPL_DEF zpl_f64 zpl_ceil64(zpl_f64 x);
ZPL_DEF zpl_f64 zpl_round64(zpl_f64 x);
ZPL_DEF zpl_f64 zpl_remainder64(zpl_f64 x, zpl_f64 y);
ZPL_DEF zpl_f64 zpl_abs64(zpl_f64 x);
ZPL_DEF zpl_f64 zpl_sign64(zpl_f64 x);
ZPL_DEF zpl_f64 zpl_mod64(zpl_f64 x, zpl_f64 y);
ZPL_DEF zpl_f32 zpl_sqrt(zpl_f32 a);
ZPL_DEF zpl_f32 zpl_rsqrt(zpl_f32 a);
ZPL_DEF zpl_f32 zpl_quake_rsqrt(zpl_f32 a); /* NOTE: It's probably better to use 1.0f/zpl_sqrt(a)
                                     * And for simd, there is usually isqrt functions too!
                                     */
ZPL_DEF zpl_f32 zpl_sin(zpl_f32 radians);
ZPL_DEF zpl_f32 zpl_cos(zpl_f32 radians);
ZPL_DEF zpl_f32 zpl_tan(zpl_f32 radians);
ZPL_DEF zpl_f32 zpl_arcsin(zpl_f32 a);
ZPL_DEF zpl_f32 zpl_arccos(zpl_f32 a);
ZPL_DEF zpl_f32 zpl_arctan(zpl_f32 a);
ZPL_DEF zpl_f32 zpl_arctan2(zpl_f32 y, zpl_f32 x);

ZPL_DEF zpl_f32 zpl_exp(zpl_f32 x);
ZPL_DEF zpl_f32 zpl_exp2(zpl_f32 x);
ZPL_DEF zpl_f32 zpl_log(zpl_f32 x);
ZPL_DEF zpl_f32 zpl_log2(zpl_f32 x);
ZPL_DEF zpl_f32 zpl_fast_exp(zpl_f32 x);   /* NOTE: Only valid from -1 <= x <= +1 */
ZPL_DEF zpl_f32 zpl_fast_exp2(zpl_f32 x);  /* NOTE: Only valid from -1 <= x <= +1 */
ZPL_DEF zpl_f32 zpl_pow(zpl_f32 x, zpl_f32 y); /* x^y */

ZPL_DEF zpl_f32 zpl_round(zpl_f32 x);
ZPL_DEF zpl_f32 zpl_floor(zpl_f32 x);
ZPL_DEF zpl_f32 zpl_ceil(zpl_f32 x);

ZPL_DEF zpl_f32  zpl_half_to_float(zpl_half value);
ZPL_DEF zpl_half zpl_float_to_half(zpl_f32 value);

ZPL_DEF zpl_vec2 zpl_vec2f_zero(void);
ZPL_DEF zpl_vec2 zpl_vec2f(zpl_f32 x, zpl_f32 y);
ZPL_DEF zpl_vec2 zpl_vec2fv(zpl_f32 x[2]);

ZPL_DEF zpl_vec3 zpl_vec3f_zero(void);
ZPL_DEF zpl_vec3 zpl_vec3f(zpl_f32 x, zpl_f32 y, zpl_f32 z);
ZPL_DEF zpl_vec3 zpl_vec3fv(zpl_f32 x[3]);

ZPL_DEF zpl_vec4 zpl_vec4f_zero(void);
ZPL_DEF zpl_vec4 zpl_vec4f(zpl_f32 x, zpl_f32 y, zpl_f32 z, zpl_f32 w);
ZPL_DEF zpl_vec4 zpl_vec4fv(zpl_f32 x[4]);

ZPL_DEF void zpl_vec2_add(zpl_vec2 *d, zpl_vec2 v0, zpl_vec2 v1);
ZPL_DEF void zpl_vec2_sub(zpl_vec2 *d, zpl_vec2 v0, zpl_vec2 v1);
ZPL_DEF void zpl_vec2_mul(zpl_vec2 *d, zpl_vec2 v, zpl_f32 s);
ZPL_DEF void zpl_vec2_div(zpl_vec2 *d, zpl_vec2 v, zpl_f32 s);

ZPL_DEF void zpl_vec3_add(zpl_vec3 *d, zpl_vec3 v0, zpl_vec3 v1);
ZPL_DEF void zpl_vec3_sub(zpl_vec3 *d, zpl_vec3 v0, zpl_vec3 v1);
ZPL_DEF void zpl_vec3_mul(zpl_vec3 *d, zpl_vec3 v, zpl_f32 s);
ZPL_DEF void zpl_vec3_div(zpl_vec3 *d, zpl_vec3 v, zpl_f32 s);

ZPL_DEF void zpl_vec4_add(zpl_vec4 *d, zpl_vec4 v0, zpl_vec4 v1);
ZPL_DEF void zpl_vec4_sub(zpl_vec4 *d, zpl_vec4 v0, zpl_vec4 v1);
ZPL_DEF void zpl_vec4_mul(zpl_vec4 *d, zpl_vec4 v, zpl_f32 s);
ZPL_DEF void zpl_vec4_div(zpl_vec4 *d, zpl_vec4 v, zpl_f32 s);

ZPL_DEF void zpl_vec2_addeq(zpl_vec2 *d, zpl_vec2 v);
ZPL_DEF void zpl_vec2_subeq(zpl_vec2 *d, zpl_vec2 v);
ZPL_DEF void zpl_vec2_muleq(zpl_vec2 *d, zpl_f32 s);
ZPL_DEF void zpl_vec2_diveq(zpl_vec2 *d, zpl_f32 s);

ZPL_DEF void zpl_vec3_addeq(zpl_vec3 *d, zpl_vec3 v);
ZPL_DEF void zpl_vec3_subeq(zpl_vec3 *d, zpl_vec3 v);
ZPL_DEF void zpl_vec3_muleq(zpl_vec3 *d, zpl_f32 s);
ZPL_DEF void zpl_vec3_diveq(zpl_vec3 *d, zpl_f32 s);

ZPL_DEF void zpl_vec4_addeq(zpl_vec4 *d, zpl_vec4 v);
ZPL_DEF void zpl_vec4_subeq(zpl_vec4 *d, zpl_vec4 v);
ZPL_DEF void zpl_vec4_muleq(zpl_vec4 *d, zpl_f32 s);
ZPL_DEF void zpl_vec4_diveq(zpl_vec4 *d, zpl_f32 s);

ZPL_DEF zpl_f32 zpl_vec2_dot(zpl_vec2 v0, zpl_vec2 v1);
ZPL_DEF zpl_f32 zpl_vec3_dot(zpl_vec3 v0, zpl_vec3 v1);
ZPL_DEF zpl_f32 zpl_vec4_dot(zpl_vec4 v0, zpl_vec4 v1);

ZPL_DEF void zpl_vec2_cross(zpl_f32 *d, zpl_vec2 v0, zpl_vec2 v1);
ZPL_DEF void zpl_vec3_cross(zpl_vec3 *d, zpl_vec3 v0, zpl_vec3 v1);

ZPL_DEF zpl_f32 zpl_vec2_mag2(zpl_vec2 v);
ZPL_DEF zpl_f32 zpl_vec3_mag2(zpl_vec3 v);
ZPL_DEF zpl_f32 zpl_vec4_mag2(zpl_vec4 v);

ZPL_DEF zpl_f32 zpl_vec2_mag(zpl_vec2 v);
ZPL_DEF zpl_f32 zpl_vec3_mag(zpl_vec3 v);
ZPL_DEF zpl_f32 zpl_vec4_mag(zpl_vec4 v);

ZPL_DEF void zpl_vec2_norm(zpl_vec2 *d, zpl_vec2 v);
ZPL_DEF void zpl_vec3_norm(zpl_vec3 *d, zpl_vec3 v);
ZPL_DEF void zpl_vec4_norm(zpl_vec4 *d, zpl_vec4 v);

ZPL_DEF void zpl_vec2_norm0(zpl_vec2 *d, zpl_vec2 v);
ZPL_DEF void zpl_vec3_norm0(zpl_vec3 *d, zpl_vec3 v);
ZPL_DEF void zpl_vec4_norm0(zpl_vec4 *d, zpl_vec4 v);

ZPL_DEF void zpl_vec2_reflect(zpl_vec2 *d, zpl_vec2 i, zpl_vec2 n);
ZPL_DEF void zpl_vec3_reflect(zpl_vec3 *d, zpl_vec3 i, zpl_vec3 n);
ZPL_DEF void zpl_vec2_refract(zpl_vec2 *d, zpl_vec2 i, zpl_vec2 n, zpl_f32 eta);
ZPL_DEF void zpl_vec3_refract(zpl_vec3 *d, zpl_vec3 i, zpl_vec3 n, zpl_f32 eta);

ZPL_DEF zpl_f32 zpl_vec2_aspect_ratio(zpl_vec2 v);

ZPL_DEF void zpl_mat2_identity(zpl_mat2 *m);
ZPL_DEF void zpl_float22_identity(zpl_f32 m[2][2]);

ZPL_DEF void    zpl_mat2_transpose(zpl_mat2 *m);
ZPL_DEF void    zpl_mat2_mul(zpl_mat2 *out, zpl_mat2 *m1, zpl_mat2 *m2);
ZPL_DEF void    zpl_mat2_mul_vec2(zpl_vec2 *out, zpl_mat2 *m, zpl_vec2 in);
ZPL_DEF void    zpl_mat2_inverse(zpl_mat2 *out, zpl_mat2 *in);
ZPL_DEF zpl_f32 zpl_mat2_determinate(zpl_mat2 *m);

ZPL_DEF zpl_mat2   *zpl_mat2_v(zpl_vec2 m[2]);
ZPL_DEF zpl_mat2   *zpl_mat2_f(zpl_f32 m[2][2]);
ZPL_DEF zpl_float2 *zpl_float22_m(zpl_mat2 *m);
ZPL_DEF zpl_float2 *zpl_float22_v(zpl_vec2 m[2]);
ZPL_DEF zpl_float2 *zpl_float22_4(zpl_f32 m[4]);

ZPL_DEF void zpl_float22_transpose(zpl_f32 (*vec)[2]);
ZPL_DEF void zpl_float22_mul(zpl_f32 (*out)[2], zpl_f32 (*mat1)[2], zpl_f32 (*mat2)[2]);
ZPL_DEF void zpl_float22_mul_vec2(zpl_vec2 *out, zpl_f32 m[2][2], zpl_vec2 in);

ZPL_DEF void zpl_mat3_identity(zpl_mat3 *m);
ZPL_DEF void zpl_float33_identity(zpl_f32 m[3][3]);

ZPL_DEF void    zpl_mat3_transpose(zpl_mat3 *m);
ZPL_DEF void    zpl_mat3_mul(zpl_mat3 *out, zpl_mat3 *m1, zpl_mat3 *m2);
ZPL_DEF void    zpl_mat3_mul_vec3(zpl_vec3 *out, zpl_mat3 *m, zpl_vec3 in);
ZPL_DEF void    zpl_mat3_inverse(zpl_mat3 *out, zpl_mat3 *in);
ZPL_DEF zpl_f32 zpl_mat3_determinate(zpl_mat3 *m);

ZPL_DEF zpl_mat3   *zpl_mat3_v(zpl_vec3 m[3]);
ZPL_DEF zpl_mat3   *zpl_mat3_f(zpl_f32 m[3][3]);

ZPL_DEF zpl_float3 *zpl_float33_m(zpl_mat3 *m);
ZPL_DEF zpl_float3 *zpl_float33_v(zpl_vec3 m[3]);
ZPL_DEF zpl_float3 *zpl_float33_9(zpl_f32 m[9]);

ZPL_DEF void zpl_float33_transpose(zpl_f32 (*vec)[3]);
ZPL_DEF void zpl_float33_mul(zpl_f32 (*out)[3], zpl_f32 (*mat1)[3], zpl_f32 (*mat2)[3]);
ZPL_DEF void zpl_float33_mul_vec3(zpl_vec3 *out, zpl_f32 m[3][3], zpl_vec3 in);

ZPL_DEF void zpl_mat4_identity(zpl_mat4 *m);
ZPL_DEF void zpl_float44_identity(zpl_f32 m[4][4]);

ZPL_DEF void zpl_mat4_transpose(zpl_mat4 *m);
ZPL_DEF void zpl_mat4_mul(zpl_mat4 *out, zpl_mat4 *m1, zpl_mat4 *m2);
ZPL_DEF void zpl_mat4_mul_vec4(zpl_vec4 *out, zpl_mat4 *m, zpl_vec4 in);
ZPL_DEF void zpl_mat4_inverse(zpl_mat4 *out, zpl_mat4 *in);

ZPL_DEF zpl_mat4 *zpl_mat4_v(zpl_vec4 m[4]);
ZPL_DEF zpl_mat4 *zpl_mat4_f(zpl_f32 m[4][4]);

ZPL_DEF zpl_float4 *zpl_float44_m(zpl_mat4 *m);
ZPL_DEF zpl_float4 *zpl_float44_v(zpl_vec4 m[4]);
ZPL_DEF zpl_float4 *zpl_float44_16(zpl_f32 m[16]);

ZPL_DEF void zpl_float44_transpose(zpl_f32 (*vec)[4]);
ZPL_DEF void zpl_float44_mul(zpl_f32 (*out)[4], zpl_f32 (*mat1)[4], zpl_f32 (*mat2)[4]);
ZPL_DEF void zpl_float44_mul_vec4(zpl_vec4 *out, zpl_f32 m[4][4], zpl_vec4 in);

ZPL_DEF void zpl_mat4_translate(zpl_mat4 *out, zpl_vec3 v);
ZPL_DEF void zpl_mat4_rotate(zpl_mat4 *out, zpl_vec3 v, zpl_f32 angle_radians);
ZPL_DEF void zpl_mat4_scale(zpl_mat4 *out, zpl_vec3 v);
ZPL_DEF void zpl_mat4_scalef(zpl_mat4 *out, zpl_f32 s);
ZPL_DEF void zpl_mat4_ortho2d(zpl_mat4 *out, zpl_f32 left, zpl_f32 right, zpl_f32 bottom, zpl_f32 top);
ZPL_DEF void zpl_mat4_ortho3d(zpl_mat4 *out, zpl_f32 left, zpl_f32 right, zpl_f32 bottom, zpl_f32 top, zpl_f32 z_near, zpl_f32 z_far);
ZPL_DEF void zpl_mat4_perspective(zpl_mat4 *out, zpl_f32 fovy, zpl_f32 aspect, zpl_f32 z_near, zpl_f32 z_far);
ZPL_DEF void zpl_mat4_infinite_perspective(zpl_mat4 *out, zpl_f32 fovy, zpl_f32 aspect, zpl_f32 z_near);

ZPL_DEF void zpl_mat4_look_at(zpl_mat4 *out, zpl_vec3 eye, zpl_vec3 centre, zpl_vec3 up);

ZPL_DEF zpl_quat zpl_quatf(zpl_f32 x, zpl_f32 y, zpl_f32 z, zpl_f32 w);
ZPL_DEF zpl_quat zpl_quatfv(zpl_f32 e[4]);
ZPL_DEF zpl_quat zpl_quat_axis_angle(zpl_vec3 axis, zpl_f32 angle_radians);
ZPL_DEF zpl_quat zpl_quat_euler_angles(zpl_f32 pitch, zpl_f32 yaw, zpl_f32 roll);
ZPL_DEF zpl_quat zpl_quat_identity(void);

ZPL_DEF void zpl_quat_add(zpl_quat *d, zpl_quat q0, zpl_quat q1);
ZPL_DEF void zpl_quat_sub(zpl_quat *d, zpl_quat q0, zpl_quat q1);
ZPL_DEF void zpl_quat_mul(zpl_quat *d, zpl_quat q0, zpl_quat q1);
ZPL_DEF void zpl_quat_div(zpl_quat *d, zpl_quat q0, zpl_quat q1);

ZPL_DEF void zpl_quat_mulf(zpl_quat *d, zpl_quat q, zpl_f32 s);
ZPL_DEF void zpl_quat_divf(zpl_quat *d, zpl_quat q, zpl_f32 s);

ZPL_DEF void zpl_quat_addeq(zpl_quat *d, zpl_quat q);
ZPL_DEF void zpl_quat_subeq(zpl_quat *d, zpl_quat q);
ZPL_DEF void zpl_quat_muleq(zpl_quat *d, zpl_quat q);
ZPL_DEF void zpl_quat_diveq(zpl_quat *d, zpl_quat q);

ZPL_DEF void zpl_quat_muleqf(zpl_quat *d, zpl_f32 s);
ZPL_DEF void zpl_quat_diveqf(zpl_quat *d, zpl_f32 s);

ZPL_DEF zpl_f32 zpl_quat_dot(zpl_quat q0, zpl_quat q1);
ZPL_DEF zpl_f32 zpl_quat_mag(zpl_quat q);

ZPL_DEF void zpl_quat_norm(zpl_quat *d, zpl_quat q);
ZPL_DEF void zpl_quat_conj(zpl_quat *d, zpl_quat q);
ZPL_DEF void zpl_quat_inverse(zpl_quat *d, zpl_quat q);

ZPL_DEF void    zpl_quat_axis(zpl_vec3 *axis, zpl_quat q);
ZPL_DEF zpl_f32 zpl_quat_angle(zpl_quat q);

ZPL_DEF zpl_f32 zpl_quat_pitch(zpl_quat q);
ZPL_DEF zpl_f32 zpl_quat_yaw(zpl_quat q);
ZPL_DEF zpl_f32 zpl_quat_roll(zpl_quat q);

/* NOTE: Rotate v by q */
ZPL_DEF void zpl_quat_rotate_vec3(zpl_vec3 *d, zpl_quat q, zpl_vec3 v);
ZPL_DEF void zpl_mat4_from_quat(zpl_mat4 *out, zpl_quat q);
ZPL_DEF void zpl_quat_from_mat4(zpl_quat *out, zpl_mat4 *m);

/* Interpolations */
ZPL_DEF zpl_f32 zpl_lerp(zpl_f32 a, zpl_f32 b, zpl_f32 t);
ZPL_DEF zpl_f32 zpl_unlerp(zpl_f32 t, zpl_f32 a, zpl_f32 b);
ZPL_DEF zpl_f32 zpl_smooth_step(zpl_f32 a, zpl_f32 b, zpl_f32 t);
ZPL_DEF zpl_f32 zpl_smoother_step(zpl_f32 a, zpl_f32 b, zpl_f32 t);

ZPL_DEF void zpl_vec2_lerp(zpl_vec2 *d, zpl_vec2 a, zpl_vec2 b, zpl_f32 t);
ZPL_DEF void zpl_vec3_lerp(zpl_vec3 *d, zpl_vec3 a, zpl_vec3 b, zpl_f32 t);
ZPL_DEF void zpl_vec4_lerp(zpl_vec4 *d, zpl_vec4 a, zpl_vec4 b, zpl_f32 t);

ZPL_DEF void zpl_vec2_cslerp(zpl_vec2 *d, zpl_vec2 a, zpl_vec2 v0, zpl_vec2 b, zpl_vec2 v1, zpl_f32 t);
ZPL_DEF void zpl_vec3_cslerp(zpl_vec3 *d, zpl_vec3 a, zpl_vec3 v0, zpl_vec3 b, zpl_vec3 v1, zpl_f32 t);
ZPL_DEF void zpl_vec2_dcslerp(zpl_vec2 *d, zpl_vec2 a, zpl_vec2 v0, zpl_vec2 b, zpl_vec2 v1, zpl_f32 t);
ZPL_DEF void zpl_vec3_dcslerp(zpl_vec3 *d, zpl_vec3 a, zpl_vec3 v0, zpl_vec3 b, zpl_vec3 v1, zpl_f32 t);

ZPL_DEF void zpl_quat_lerp(zpl_quat *d, zpl_quat a, zpl_quat b, zpl_f32 t);
ZPL_DEF void zpl_quat_nlerp(zpl_quat *d, zpl_quat a, zpl_quat b, zpl_f32 t);
ZPL_DEF void zpl_quat_slerp(zpl_quat *d, zpl_quat a, zpl_quat b, zpl_f32 t);
ZPL_DEF void zpl_quat_nquad(zpl_quat *d, zpl_quat p, zpl_quat a, zpl_quat b, zpl_quat q, zpl_f32 t);
ZPL_DEF void zpl_quat_squad(zpl_quat *d, zpl_quat p, zpl_quat a, zpl_quat b, zpl_quat q, zpl_f32 t);
ZPL_DEF void zpl_quat_slerp_approx(zpl_quat *d, zpl_quat a, zpl_quat b, zpl_f32 t);
ZPL_DEF void zpl_quat_squad_approx(zpl_quat *d, zpl_quat p, zpl_quat a, zpl_quat b, zpl_quat q, zpl_f32 t);

/* Rects */
ZPL_DEF zpl_rect2 zpl_rect2f(zpl_vec2 pos, zpl_vec2 dim);
ZPL_DEF zpl_rect3 zpl_rect3f(zpl_vec3 pos, zpl_vec3 dim);

ZPL_DEF int zpl_rect2_contains(zpl_rect2 a, zpl_f32 x, zpl_f32 y);
ZPL_DEF int zpl_rect2_contains_vec2(zpl_rect2 a, zpl_vec2 p);
ZPL_DEF int zpl_rect2_intersects(zpl_rect2 a, zpl_rect2 b);
ZPL_DEF int zpl_rect2_intersection_result(zpl_rect2 a, zpl_rect2 b, zpl_rect2 *intersection);

//! @}


#if defined(__cplusplus)
}
#endif

#if defined(ZPL_COMPILER_MSVC)
#pragma warning(pop)
#endif

#if defined(__GCC__) || defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif

#if defined(ZPL_IMPLEMENTATION) && !defined(ZPL_IMPLEMENTATION_DONE)
#define ZPL_IMPLEMENTATION_DONE

#if defined(__GCC__) || defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
#pragma GCC diagnostic ignored "-Wattributes"
#pragma GCC diagnostic ignored "-Wunused-value"
#pragma GCC diagnostic ignored "-Wunused-function"
#pragma GCC diagnostic ignored "-Wunused-parameter"
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
#pragma GCC diagnostic ignored "-Wmissing-braces"
#pragma GCC diagnostic ignored "-Wmissing-field-initializers"
#endif

#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable : 4201)
#pragma warning(disable : 4127) // Conditional expression is constant
#endif

#if defined(__cplusplus)
extern "C" {
#endif

    

void zpl_assert_handler(char const *condition, char const *file, zpl_i32 line, char const *msg, ...) {
    zpl_printf_err("%s:(%d): Assert Failure: ", file, line);
    if (condition) zpl_printf_err("`%s` ", condition);
    if (msg) {
        va_list va;
        va_start(va, msg);
        zpl_printf_err_va(msg, va);
        va_end(va);
    }
    zpl_printf_err("\n");
}

zpl_i32 zpl_assert_crash(char const *condition) {
    ZPL_PANIC(condition);

    return 0;
}


zpl_b32 zpl_is_power_of_two(zpl_isize x) {
    if (x <= 0) return false;
    return !(x & (x - 1));
}

zpl_inline void *zpl_align_forward(void *ptr, zpl_isize alignment) {
    zpl_uintptr p;

    ZPL_ASSERT(zpl_is_power_of_two(alignment));

    p = cast(zpl_uintptr) ptr;
    return cast(void *)((p + (alignment - 1)) & ~(alignment - 1));
}

zpl_inline void *zpl_pointer_add(void *ptr, zpl_isize bytes) { return cast(void *)(cast(zpl_u8 *) ptr + bytes); }
zpl_inline void *zpl_pointer_sub(void *ptr, zpl_isize bytes) { return cast(void *)(cast(zpl_u8 *) ptr - bytes); }
zpl_inline void const *zpl_pointer_add_const(void const *ptr, zpl_isize bytes) {
    return cast(void const *)(cast(zpl_u8 const *) ptr + bytes);
}
zpl_inline void const *zpl_pointer_sub_const(void const *ptr, zpl_isize bytes) {
    return cast(void const *)(cast(zpl_u8 const *) ptr - bytes);
}
zpl_inline zpl_isize zpl_pointer_diff(void const *begin, void const *end) {
    return cast(zpl_isize)(cast(zpl_u8 const *) end - cast(zpl_u8 const *) begin);
}

zpl_inline void zpl_zero_size(void *ptr, zpl_isize size) { zpl_memset(ptr, 0, size); }

#if defined(_MSC_VER) && !defined(__clang__)
#pragma intrinsic(__movsb)
#endif

zpl_inline void *zpl_memcopy(void *dest, void const *source, zpl_isize n) {
    if (dest == NULL) { return NULL; }

    return memcpy(dest, source, n);

    // TODO: Re-work the whole method
#if 0
#if defined(_MSC_VER)
    __movsb(cast(zpl_u8 *) dest, cast(zpl_u8 *) source, n);
#elif defined(ZPL_CPU_X86) && !defined(ZPL_SYSTEM_EMSCRIPTEN)
    zpl_u8 *__dest8 = cast(zpl_u8 *) dest;
    zpl_u8 *__source8 = cast(zpl_u8 *) source;
    __asm__ __volatile__("rep movsb" : "+D"(__dest8), "+S"(__source8), "+c"(n) : : "memory");
#elif defined(ZPL_CPU_ARM)
    return memcpy(dest, source, n);
#else
    zpl_u8 *d = cast(zpl_u8 *) dest;
    zpl_u8 const *s = cast(zpl_u8 const *) source;
    zpl_u32 w, x;

    for (; cast(zpl_uintptr) s % 4 && n; n--) *d++ = *s++;

    if (cast(zpl_uintptr) d % 4 == 0) {
        for (; n >= 16; s += 16, d += 16, n -= 16) {
            *cast(zpl_u32 *)(d + 0) = *cast(zpl_u32 *)(s + 0);
            *cast(zpl_u32 *)(d + 4) = *cast(zpl_u32 *)(s + 4);
            *cast(zpl_u32 *)(d + 8) = *cast(zpl_u32 *)(s + 8);
            *cast(zpl_u32 *)(d + 12) = *cast(zpl_u32 *)(s + 12);
        }
        if (n & 8) {
            *cast(zpl_u32 *)(d + 0) = *cast(zpl_u32 *)(s + 0);
            *cast(zpl_u32 *)(d + 4) = *cast(zpl_u32 *)(s + 4);
            d += 8;
            s += 8;
        }
        if (n & 4) {
            *cast(zpl_u32 *)(d + 0) = *cast(zpl_u32 *)(s + 0);
            d += 4;
            s += 4;
        }
        if (n & 2) {
            *d++ = *s++;
            *d++ = *s++;
        }
        if (n & 1) { *d = *s; }
        return dest;
    }

    if (n >= 32) {
#if __BYTE_ORDER == __BIG_ENDIAN
#define LS <<
#define RS >>
#else
#define LS >>
#define RS <<
#endif
        switch (cast(zpl_uintptr) d % 4) {
            case 1: {
                w = *cast(zpl_u32 *) s;
                *d++ = *s++;
                *d++ = *s++;
                *d++ = *s++;
                n -= 3;
                while (n > 16) {
                    x = *cast(zpl_u32 *)(s + 1);
                    *cast(zpl_u32 *)(d + 0) = (w LS 24) | (x RS 8);
                    w = *cast(zpl_u32 *)(s + 5);
                    *cast(zpl_u32 *)(d + 4) = (x LS 24) | (w RS 8);
                    x = *cast(zpl_u32 *)(s + 9);
                    *cast(zpl_u32 *)(d + 8) = (w LS 24) | (x RS 8);
                    w = *cast(zpl_u32 *)(s + 13);
                    *cast(zpl_u32 *)(d + 12) = (x LS 24) | (w RS 8);

                    s += 16;
                    d += 16;
                    n -= 16;
                }
            } break;
            case 2: {
                w = *cast(zpl_u32 *) s;
                *d++ = *s++;
                *d++ = *s++;
                n -= 2;
                while (n > 17) {
                    x = *cast(zpl_u32 *)(s + 2);
                    *cast(zpl_u32 *)(d + 0) = (w LS 16) | (x RS 16);
                    w = *cast(zpl_u32 *)(s + 6);
                    *cast(zpl_u32 *)(d + 4) = (x LS 16) | (w RS 16);
                    x = *cast(zpl_u32 *)(s + 10);
                    *cast(zpl_u32 *)(d + 8) = (w LS 16) | (x RS 16);
                    w = *cast(zpl_u32 *)(s + 14);
                    *cast(zpl_u32 *)(d + 12) = (x LS 16) | (w RS 16);

                    s += 16;
                    d += 16;
                    n -= 16;
                }
            } break;
            case 3: {
                w = *cast(zpl_u32 *) s;
                *d++ = *s++;
                n -= 1;
                while (n > 18) {
                    x = *cast(zpl_u32 *)(s + 3);
                    *cast(zpl_u32 *)(d + 0) = (w LS 8) | (x RS 24);
                    w = *cast(zpl_u32 *)(s + 7);
                    *cast(zpl_u32 *)(d + 4) = (x LS 8) | (w RS 24);
                    x = *cast(zpl_u32 *)(s + 11);
                    *cast(zpl_u32 *)(d + 8) = (w LS 8) | (x RS 24);
                    w = *cast(zpl_u32 *)(s + 15);
                    *cast(zpl_u32 *)(d + 12) = (x LS 8) | (w RS 24);

                    s += 16;
                    d += 16;
                    n -= 16;
                }
            } break;
            default: break; // NOTE: Do nowt!
        }
#undef LS
#undef RS
        if (n & 16) {
            *d++ = *s++;
            *d++ = *s++;
            *d++ = *s++;
            *d++ = *s++;
            *d++ = *s++;
            *d++ = *s++;
            *d++ = *s++;
            *d++ = *s++;
            *d++ = *s++;
            *d++ = *s++;
            *d++ = *s++;
            *d++ = *s++;
            *d++ = *s++;
            *d++ = *s++;
            *d++ = *s++;
            *d++ = *s++;
        }
        if (n & 8) {
            *d++ = *s++;
            *d++ = *s++;
            *d++ = *s++;
            *d++ = *s++;
            *d++ = *s++;
            *d++ = *s++;
            *d++ = *s++;
            *d++ = *s++;
        }
        if (n & 4) {
            *d++ = *s++;
            *d++ = *s++;
            *d++ = *s++;
            *d++ = *s++;
        }
        if (n & 2) {
            *d++ = *s++;
            *d++ = *s++;
        }
        if (n & 1) { *d = *s; }
    }

#endif
#endif

    return dest;
}

zpl_inline void *zpl_memmove(void *dest, void const *source, zpl_isize n) {
    if (dest == NULL) { return NULL; }

    zpl_u8 *d = cast(zpl_u8 *) dest;
    zpl_u8 const *s = cast(zpl_u8 const *) source;

    if (d == s) return d;
    if (s + n <= d || d + n <= s) // NOTE: Non-overlapping
        return zpl_memcopy(d, s, n);

    if (d < s) {
        if (cast(zpl_uintptr) s % zpl_size_of(zpl_isize) == cast(zpl_uintptr) d % zpl_size_of(zpl_isize)) {
            while (cast(zpl_uintptr) d % zpl_size_of(zpl_isize)) {
                if (!n--) return dest;
                *d++ = *s++;
            }
            while (n >= zpl_size_of(zpl_isize)) {
                *cast(zpl_isize *) d = *cast(zpl_isize *) s;
                n -= zpl_size_of(zpl_isize);
                d += zpl_size_of(zpl_isize);
                s += zpl_size_of(zpl_isize);
            }
        }
        for (; n; n--) *d++ = *s++;
    } else {
        if ((cast(zpl_uintptr) s % zpl_size_of(zpl_isize)) == (cast(zpl_uintptr) d % zpl_size_of(zpl_isize))) {
            while (cast(zpl_uintptr)(d + n) % zpl_size_of(zpl_isize)) {
                if (!n--) return dest;
                d[n] = s[n];
            }
            while (n >= zpl_size_of(zpl_isize)) {
                n -= zpl_size_of(zpl_isize);
                *cast(zpl_isize *)(d + n) = *cast(zpl_isize *)(s + n);
            }
        }
        while (n) n--, d[n] = s[n];
    }

    return dest;
}

zpl_inline void *zpl_memset(void *dest, zpl_u8 c, zpl_isize n) {
    if (dest == NULL) { return NULL; }

    zpl_u8 *s = cast(zpl_u8 *) dest;
    zpl_isize k;
    zpl_u32 c32 = ((zpl_u32)-1) / 255 * c;

    if (n == 0) return dest;
    s[0] = s[n - 1] = c;
    if (n < 3) return dest;
    s[1] = s[n - 2] = c;
    s[2] = s[n - 3] = c;
    if (n < 7) return dest;
    s[3] = s[n - 4] = c;
    if (n < 9) return dest;

    k = -cast(zpl_intptr) s & 3;
    s += k;
    n -= k;
    n &= -4;

    *cast(zpl_u32 *)(s + 0) = c32;
    *cast(zpl_u32 *)(s + n - 4) = c32;
    if (n < 9) return dest;
    *cast(zpl_u32 *)(s + 4) = c32;
    *cast(zpl_u32 *)(s + 8) = c32;
    *cast(zpl_u32 *)(s + n - 12) = c32;
    *cast(zpl_u32 *)(s + n - 8) = c32;
    if (n < 25) return dest;
    *cast(zpl_u32 *)(s + 12) = c32;
    *cast(zpl_u32 *)(s + 16) = c32;
    *cast(zpl_u32 *)(s + 20) = c32;
    *cast(zpl_u32 *)(s + 24) = c32;
    *cast(zpl_u32 *)(s + n - 28) = c32;
    *cast(zpl_u32 *)(s + n - 24) = c32;
    *cast(zpl_u32 *)(s + n - 20) = c32;
    *cast(zpl_u32 *)(s + n - 16) = c32;

    k = 24 + (cast(zpl_uintptr) s & 4);
    s += k;
    n -= k;

    {
        zpl_u64 c64 = (cast(zpl_u64) c32 << 32) | c32;
        while (n > 31) {
            *cast(zpl_u64 *)(s + 0) = c64;
            *cast(zpl_u64 *)(s + 8) = c64;
            *cast(zpl_u64 *)(s + 16) = c64;
            *cast(zpl_u64 *)(s + 24) = c64;

            n -= 32;
            s += 32;
        }
    }

    return dest;
}

zpl_inline zpl_i32 zpl_memcompare(void const *s1, void const *s2, zpl_isize size) {
    zpl_u8 const *s1p8 = cast(zpl_u8 const *) s1;
    zpl_u8 const *s2p8 = cast(zpl_u8 const *) s2;

    if (s1 == NULL || s2 == NULL) { return 0; }

    while (size--) {
        zpl_isize d;
        if ((d = (*s1p8++ - *s2p8++)) != 0) return cast(zpl_i32) d;
    }
    return 0;
}

void zpl_memswap(void *i, void *j, zpl_isize size) {
    if (i == j) return;

    if (size == 4) {
        zpl_swap(zpl_u32, *cast(zpl_u32 *) i, *cast(zpl_u32 *) j);
    } else if (size == 8) {
        zpl_swap(zpl_u64, *cast(zpl_u64 *) i, *cast(zpl_u64 *) j);
    } else if (size < 8) {
        zpl_u8 *a = cast(zpl_u8 *) i;
        zpl_u8 *b = cast(zpl_u8 *) j;
        if (a != b) {
            while (size--) { zpl_swap(zpl_u8, *a++, *b++); }
        }
    } else {
        char buffer[256];

        while (size > zpl_size_of(buffer)) {
            zpl_memswap(i, j, zpl_size_of(buffer));
            i = zpl_pointer_add(i, zpl_size_of(buffer));
            j = zpl_pointer_add(j, zpl_size_of(buffer));
            size -= zpl_size_of(buffer);
        }

        zpl_memcopy(buffer, i, size);
        zpl_memcopy(i, j, size);
        zpl_memcopy(j, buffer, size);
    }
}

#define ZPL__ONES (cast(zpl_usize) - 1 / ZPL_U8_MAX)
#define ZPL__HIGHS (ZPL__ONES * (ZPL_U8_MAX / 2 + 1))
#define ZPL__HAS_ZERO(x) (((x)-ZPL__ONES) & ~(x)&ZPL__HIGHS)

void const *zpl_memchr(void const *data, zpl_u8 c, zpl_isize n) {
    zpl_u8 const *s = cast(zpl_u8 const *) data;
    while ((cast(zpl_uintptr) s & (sizeof(zpl_usize) - 1)) && n && *s != c) {
        s++;
        n--;
    }
    if (n && *s != c) {
        zpl_isize const *w;
        zpl_isize k = ZPL__ONES * c;
        w = cast(zpl_isize const *) s;
        while (n >= zpl_size_of(zpl_isize) && !ZPL__HAS_ZERO(*w ^ k)) {
            w++;
            n -= zpl_size_of(zpl_isize);
        }
        s = cast(zpl_u8 const *) w;
        while (n && *s != c) {
            s++;
            n--;
        }
    }

    return n ? cast(void const *) s : NULL;
}

void const *zpl_memrchr(void const *data, zpl_u8 c, zpl_isize n) {
    zpl_u8 const *s = cast(zpl_u8 const *) data;
    while (n--) {
        if (s[n] == c) return cast(void const *)(s + n);
    }
    return NULL;
}

////////////////////////////////////////////////////////////////
//
// Virtual Memory
//
//

zpl_virtual_memory zpl_vm(void *data, zpl_isize size) {
    zpl_virtual_memory vm;
    vm.data = data;
    vm.size = size;
    return vm;
}

#if defined(ZPL_SYSTEM_WINDOWS)
zpl_inline zpl_virtual_memory zpl_vm_alloc(void *addr, zpl_isize size) {
    zpl_virtual_memory vm;
    ZPL_ASSERT(size > 0);
    vm.data = VirtualAlloc(addr, size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    vm.size = size;
    return vm;
}

zpl_inline zpl_b32 zpl_vm_free(zpl_virtual_memory vm) {
    MEMORY_BASIC_INFORMATION info;
    while (vm.size > 0) {
        if (VirtualQuery(vm.data, &info, zpl_size_of(info)) == 0) return false;
        if (info.BaseAddress != vm.data || info.AllocationBase != vm.data || info.State != MEM_COMMIT ||
            info.RegionSize > cast(zpl_usize) vm.size) {
            return false;
        }
        if (VirtualFree(vm.data, 0, MEM_RELEASE) == 0) return false;
        vm.data = zpl_pointer_add(vm.data, info.RegionSize);
        vm.size -= info.RegionSize;
    }
    return true;
}

zpl_inline zpl_virtual_memory zpl_vm_trim(zpl_virtual_memory vm, zpl_isize lead_size, zpl_isize size) {
    zpl_virtual_memory new_vm = { 0 };
    void *ptr;
    ZPL_ASSERT(vm.size >= lead_size + size);

    ptr = zpl_pointer_add(vm.data, lead_size);

    zpl_vm_free(vm);
    new_vm = zpl_vm_alloc(ptr, size);
    if (new_vm.data == ptr) return new_vm;
    if (new_vm.data) zpl_vm_free(new_vm);
    return new_vm;
}

zpl_inline zpl_b32 zpl_vm_purge(zpl_virtual_memory vm) {
    VirtualAlloc(vm.data, vm.size, MEM_RESET, PAGE_READWRITE);
    // NOTE: Can this really fail?
    return true;
}

zpl_isize zpl_virtual_memory_page_size(zpl_isize *alignment_out) {
    SYSTEM_INFO info;
    GetSystemInfo(&info);
    if (alignment_out) *alignment_out = info.dwAllocationGranularity;
    return info.dwPageSize;
}

#else

#ifndef MAP_ANONYMOUS
#define MAP_ANONYMOUS MAP_ANON
#endif

zpl_inline zpl_virtual_memory zpl_vm_alloc(void *addr, zpl_isize size) {
    zpl_virtual_memory vm;
    ZPL_ASSERT(size > 0);
    vm.data = mmap(addr, size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    vm.size = size;
    return vm;
}

zpl_inline zpl_b32 zpl_vm_free(zpl_virtual_memory vm) {
    munmap(vm.data, vm.size);
    return true;
}

zpl_inline zpl_virtual_memory zpl_vm_trim(zpl_virtual_memory vm, zpl_isize lead_size, zpl_isize size) {
    void *ptr;
    zpl_isize trail_size;
    ZPL_ASSERT(vm.size >= lead_size + size);

    ptr = zpl_pointer_add(vm.data, lead_size);
    trail_size = vm.size - lead_size - size;

    if (lead_size != 0) zpl_vm_free(zpl_vm(vm.data, lead_size));
    if (trail_size != 0) zpl_vm_free(zpl_vm(ptr, trail_size));
    return zpl_vm(ptr, size);
}

zpl_inline zpl_b32 zpl_vm_purge(zpl_virtual_memory vm) {
    int err = madvise(vm.data, vm.size, MADV_DONTNEED);
    return err != 0;
}

zpl_isize zpl_virtual_memory_page_size(zpl_isize *alignment_out) {
    // TODO: Is this always true?
    zpl_isize result = cast(zpl_isize) sysconf(_SC_PAGE_SIZE);
    if (alignment_out) *alignment_out = result;
    return result;
}

#endif

zpl_inline void *zpl_alloc_align(zpl_allocator a, zpl_isize size, zpl_isize alignment) {
    return a.proc(a.data, ZPL_ALLOCATION_ALLOC, size, alignment, NULL, 0, ZPL_DEFAULT_ALLOCATOR_FLAGS);
}
zpl_inline void *zpl_alloc(zpl_allocator a, zpl_isize size) {
    return zpl_alloc_align(a, size, ZPL_DEFAULT_MEMORY_ALIGNMENT);
}
zpl_inline void zpl_free(zpl_allocator a, void *ptr) {
    if (ptr != NULL) a.proc(a.data, ZPL_ALLOCATION_FREE, 0, 0, ptr, 0, ZPL_DEFAULT_ALLOCATOR_FLAGS);
}
zpl_inline void zpl_free_all(zpl_allocator a) {
    a.proc(a.data, ZPL_ALLOCATION_FREE_ALL, 0, 0, NULL, 0, ZPL_DEFAULT_ALLOCATOR_FLAGS);
}
zpl_inline void *zpl_resize(zpl_allocator a, void *ptr, zpl_isize old_size, zpl_isize new_size) {
    return zpl_resize_align(a, ptr, old_size, new_size, ZPL_DEFAULT_MEMORY_ALIGNMENT);
}
zpl_inline void *zpl_resize_align(zpl_allocator a, void *ptr, zpl_isize old_size, zpl_isize new_size, zpl_isize alignment) {
    return a.proc(a.data, ZPL_ALLOCATION_RESIZE, new_size, alignment, ptr, old_size, ZPL_DEFAULT_ALLOCATOR_FLAGS);
}

zpl_inline void *zpl_alloc_copy(zpl_allocator a, void const *src, zpl_isize size) {
    return zpl_memcopy(zpl_alloc(a, size), src, size);
}
zpl_inline void *zpl_alloc_copy_align(zpl_allocator a, void const *src, zpl_isize size, zpl_isize alignment) {
    return zpl_memcopy(zpl_alloc_align(a, size, alignment), src, size);
}

zpl_inline char *zpl_alloc_str(zpl_allocator a, char const *str) { return zpl_alloc_str_len(a, str, zpl_strlen(str)); }

zpl_inline char *zpl_alloc_str_len(zpl_allocator a, char const *str, zpl_isize len) {
    char *result;
    result = cast(char *) zpl_alloc_copy(a, str, len + 1);
    result[len] = '\0';
    return result;
}

zpl_inline void *zpl_default_resize_align(zpl_allocator a, void *old_memory, zpl_isize old_size, zpl_isize new_size,
                                          zpl_isize alignment) {
    if (!old_memory) return zpl_alloc_align(a, new_size, alignment);

    if (new_size == 0) {
        zpl_free(a, old_memory);
        return NULL;
    }

    if (new_size < old_size) new_size = old_size;

    if (old_size == new_size) {
        return old_memory;
    } else {
        void *new_memory = zpl_alloc_align(a, new_size, alignment);
        if (!new_memory) return NULL;
        zpl_memmove(new_memory, old_memory, zpl_min(new_size, old_size));
        zpl_free(a, old_memory);
        return new_memory;
    }
}

////////////////////////////////////////////////////////////////
//
// Custom Allocation
//
//

//
// Heap Allocator
//

zpl_inline zpl_allocator zpl_heap_allocator(void) {
    zpl_allocator a;
    a.proc = zpl_heap_allocator_proc;
    a.data = NULL;
    return a;
}

ZPL_ALLOCATOR_PROC(zpl_heap_allocator_proc) {
    void *ptr = NULL;
    zpl_unused(allocator_data);
    zpl_unused(old_size);
    // TODO: Throughly test!
    switch (type) {
#if defined(ZPL_COMPILER_MSVC) || (defined(ZPL_COMPILER_GCC) && defined(ZPL_SYSTEM_WINDOWS))
        case ZPL_ALLOCATION_ALLOC:
        ptr = _aligned_malloc(size, alignment);
        if (flags & ZPL_ALLOCATOR_FLAG_CLEAR_TO_ZERO) zpl_zero_size(ptr, size);
        break;
        case ZPL_ALLOCATION_FREE: _aligned_free(old_memory); break;
        case ZPL_ALLOCATION_RESIZE: ptr = _aligned_realloc(old_memory, size, alignment); break;

#elif defined(ZPL_SYSTEM_LINUX) && !defined(ZPL_CPU_ARM)
        case ZPL_ALLOCATION_ALLOC: {
            ptr = aligned_alloc(alignment, size);

            if (flags & ZPL_ALLOCATOR_FLAG_CLEAR_TO_ZERO) { zpl_zero_size(ptr, size); }
        } break;

        case ZPL_ALLOCATION_FREE: {
            free(old_memory);
        } break;

        case ZPL_ALLOCATION_RESIZE: {
            zpl_allocator a = zpl_heap_allocator( );
            ptr = zpl_default_resize_align(a, old_memory, old_size, size, alignment);
        } break;
#else
        case ZPL_ALLOCATION_ALLOC: {
            posix_memalign(&ptr, alignment, size);

            if (flags & ZPL_ALLOCATOR_FLAG_CLEAR_TO_ZERO) { zpl_zero_size(ptr, size); }
        } break;

        case ZPL_ALLOCATION_FREE: {
            free(old_memory);
        } break;

        case ZPL_ALLOCATION_RESIZE: {
            zpl_allocator a = zpl_heap_allocator( );
            ptr = zpl_default_resize_align(a, old_memory, old_size, size, alignment);
        } break;
#endif

        case ZPL_ALLOCATION_FREE_ALL: break;
    }

    return ptr;
}

//
// Arena Allocator
//

zpl_inline void zpl_arena_init_from_memory(zpl_arena *arena, void *start, zpl_isize size) {
    arena->backing.proc = NULL;
    arena->backing.data = NULL;
    arena->physical_start = start;
    arena->total_size = size;
    arena->total_allocated = 0;
    arena->temp_count = 0;
}

zpl_inline void zpl_arena_init_from_allocator(zpl_arena *arena, zpl_allocator backing, zpl_isize size) {
    arena->backing = backing;
    arena->physical_start = zpl_alloc(backing, size); // NOTE: Uses default alignment
    arena->total_size = size;
    arena->total_allocated = 0;
    arena->temp_count = 0;
}

zpl_inline void zpl_arena_init_sub(zpl_arena *arena, zpl_arena *parent_arena, zpl_isize size) {
    zpl_arena_init_from_allocator(arena, zpl_arena_allocator(parent_arena), size);
}

zpl_inline void zpl_arena_free(zpl_arena *arena) {
    if (arena->backing.proc) {
        zpl_free(arena->backing, arena->physical_start);
        arena->physical_start = NULL;
    }
}

zpl_inline zpl_isize zpl_arena_alignment_of(zpl_arena *arena, zpl_isize alignment) {
    zpl_isize alignment_offset, result_pointer, mask;
    ZPL_ASSERT(zpl_is_power_of_two(alignment));

    alignment_offset = 0;
    result_pointer = cast(zpl_isize) arena->physical_start + arena->total_allocated;
    mask = alignment - 1;
    if (result_pointer & mask) alignment_offset = alignment - (result_pointer & mask);

    return alignment_offset;
}

zpl_inline zpl_isize zpl_arena_size_remaining(zpl_arena *arena, zpl_isize alignment) {
    zpl_isize result = arena->total_size - (arena->total_allocated + zpl_arena_alignment_of(arena, alignment));
    return result;
}

zpl_inline void zpl_arena_check(zpl_arena *arena) { ZPL_ASSERT(arena->temp_count == 0); }

zpl_inline zpl_allocator zpl_arena_allocator(zpl_arena *arena) {
    zpl_allocator allocator;
    allocator.proc = zpl_arena_allocator_proc;
    allocator.data = arena;
    return allocator;
}

ZPL_ALLOCATOR_PROC(zpl_arena_allocator_proc) {
    zpl_arena *arena = cast(zpl_arena *) allocator_data;
    void *ptr = NULL;

    zpl_unused(old_size);

    switch (type) {
        case ZPL_ALLOCATION_ALLOC: {
            void *end = zpl_pointer_add(arena->physical_start, arena->total_allocated);
            zpl_isize total_size = size + alignment;

            // NOTE: Out of memory
            if (arena->total_allocated + total_size > cast(zpl_isize) arena->total_size) {
                zpl_printf_err("Arena out of memory\n");
                return NULL;
            }

            ptr = zpl_align_forward(end, alignment);
            arena->total_allocated += total_size;
            if (flags & ZPL_ALLOCATOR_FLAG_CLEAR_TO_ZERO) zpl_zero_size(ptr, size);
        } break;

        case ZPL_ALLOCATION_FREE:
        // NOTE: Free all at once
        // Use Temp_Arena_Memory if you want to free a block
        break;

        case ZPL_ALLOCATION_FREE_ALL: arena->total_allocated = 0; break;

        case ZPL_ALLOCATION_RESIZE: {
            // TODO: Check if ptr is on top of stack and just extend
            zpl_allocator a = zpl_arena_allocator(arena);
            ptr = zpl_default_resize_align(a, old_memory, old_size, size, alignment);
        } break;
    }
    return ptr;
}

zpl_inline zpl_temp_arena_memory zpl_temp_arena_memory_begin(zpl_arena *arena) {
    zpl_temp_arena_memory tmp;
    tmp.arena = arena;
    tmp.original_count = arena->total_allocated;
    arena->temp_count++;
    return tmp;
}

zpl_inline void zpl_temp_arena_memory_end(zpl_temp_arena_memory tmp) {
    ZPL_ASSERT(tmp.arena->total_allocated >= tmp.original_count);
    ZPL_ASSERT(tmp.arena->temp_count > 0);
    tmp.arena->total_allocated = tmp.original_count;
    tmp.arena->temp_count--;
}

//
// Pool Allocator
//

zpl_inline void zpl_pool_init(zpl_pool *pool, zpl_allocator backing, zpl_isize num_blocks, zpl_isize block_size) {
    zpl_pool_init_align(pool, backing, num_blocks, block_size, ZPL_DEFAULT_MEMORY_ALIGNMENT);
}

void zpl_pool_init_align(zpl_pool *pool, zpl_allocator backing, zpl_isize num_blocks, zpl_isize block_size, zpl_isize block_align) {
    zpl_isize actual_block_size, pool_size, block_index;
    void *data, *curr;
    zpl_uintptr *end;

    zpl_zero_item(pool);

    pool->backing = backing;
    pool->block_size = block_size;
    pool->block_align = block_align;

    actual_block_size = block_size + block_align;
    pool_size = num_blocks * actual_block_size;

    data = zpl_alloc_align(backing, pool_size, block_align);

    // NOTE: Init intrusive freelist
    curr = data;
    for (block_index = 0; block_index < num_blocks - 1; block_index++) {
        zpl_uintptr *next = cast(zpl_uintptr *) curr;
        *next = cast(zpl_uintptr) curr + actual_block_size;
        curr = zpl_pointer_add(curr, actual_block_size);
    }

    end = cast(zpl_uintptr *) curr;
    *end = cast(zpl_uintptr) NULL;

    pool->physical_start = data;
    pool->free_list = data;
}

zpl_inline void zpl_pool_free(zpl_pool *pool) {
    if (pool->backing.proc) { zpl_free(pool->backing, pool->physical_start); }
}

zpl_inline zpl_allocator zpl_pool_allocator(zpl_pool *pool) {
    zpl_allocator allocator;
    allocator.proc = zpl_pool_allocator_proc;
    allocator.data = pool;
    return allocator;
}
ZPL_ALLOCATOR_PROC(zpl_pool_allocator_proc) {
    zpl_pool *pool = cast(zpl_pool *) allocator_data;
    void *ptr = NULL;

    zpl_unused(old_size);

    switch (type) {
        case ZPL_ALLOCATION_ALLOC: {
            zpl_uintptr next_free;
            ZPL_ASSERT(size == pool->block_size);
            ZPL_ASSERT(alignment == pool->block_align);
            ZPL_ASSERT(pool->free_list != NULL);

            next_free = *cast(zpl_uintptr *) pool->free_list;
            ptr = pool->free_list;
            pool->free_list = cast(void *) next_free;
            pool->total_size += pool->block_size;
            if (flags & ZPL_ALLOCATOR_FLAG_CLEAR_TO_ZERO) zpl_zero_size(ptr, size);
        } break;

        case ZPL_ALLOCATION_FREE: {
            zpl_uintptr *next;
            if (old_memory == NULL) return NULL;

            next = cast(zpl_uintptr *) old_memory;
            *next = cast(zpl_uintptr) pool->free_list;
            pool->free_list = old_memory;
            pool->total_size -= pool->block_size;
        } break;

        case ZPL_ALLOCATION_FREE_ALL:
        // TODO:
        break;

        case ZPL_ALLOCATION_RESIZE:
        // NOTE: Cannot resize
        ZPL_PANIC("You cannot resize something allocated by with a pool.");
        break;
    }

    return ptr;
}

zpl_inline zpl_allocation_header_ev *zpl_allocation_header(void *data) {
    zpl_isize *p = cast(zpl_isize *) data;
    while (p[-1] == cast(zpl_isize)(-1)) p--;
    return cast(zpl_allocation_header_ev *) p - 1;
}

zpl_inline void zpl_allocation_header_fill(zpl_allocation_header_ev *header, void *data, zpl_isize size) {
    zpl_isize *ptr;
    header->size = size;
    ptr = cast(zpl_isize *)(header + 1);
    while (cast(void *) ptr < data) *ptr++ = cast(zpl_isize)(-1);
}

//
// Scratch Memory Allocator
//

void zpl_scratch_memory_init(zpl_scratch_memory *s, void *start, zpl_isize size) {
    s->physical_start = start;
    s->total_size = size;
    s->alloc_point = start;
    s->free_point = start;
}

zpl_b32 zpl_scratch_memory_is_in_use(zpl_scratch_memory *s, void *ptr) {
    if (s->free_point == s->alloc_point) return false;
    if (s->alloc_point > s->free_point) return ptr >= s->free_point && ptr < s->alloc_point;
    return ptr >= s->free_point || ptr < s->alloc_point;
}

zpl_allocator zpl_scratch_allocator(zpl_scratch_memory *s) {
    zpl_allocator a;
    a.proc = zpl_scratch_allocator_proc;
    a.data = s;
    return a;
}

ZPL_ALLOCATOR_PROC(zpl_scratch_allocator_proc) {
    zpl_scratch_memory *s = cast(zpl_scratch_memory *) allocator_data;
    void *ptr = NULL;
    ZPL_ASSERT_NOT_NULL(s);

    switch (type) {
        case ZPL_ALLOCATION_ALLOC: {
            void *pt = s->alloc_point;
            zpl_allocation_header_ev *header = cast(zpl_allocation_header_ev *) pt;
            void *data = zpl_align_forward(header + 1, alignment);
            void *end = zpl_pointer_add(s->physical_start, s->total_size);

            ZPL_ASSERT(alignment % 4 == 0);
            size = ((size + 3) / 4) * 4;
            pt = zpl_pointer_add(pt, size);

            // NOTE: Wrap around
            if (pt > end) {
                header->size = zpl_pointer_diff(header, end) | ZPL_ISIZE_HIGH_BIT;
                pt = s->physical_start;
                header = cast(zpl_allocation_header_ev *) pt;
                data = zpl_align_forward(header + 1, alignment);
                pt = zpl_pointer_add(pt, size);
            }

            if (!zpl_scratch_memory_is_in_use(s, pt)) {
                zpl_allocation_header_fill(header, pt, zpl_pointer_diff(header, pt));
                s->alloc_point = cast(zpl_u8 *) pt;
                ptr = data;
            }

            if (flags & ZPL_ALLOCATOR_FLAG_CLEAR_TO_ZERO) zpl_zero_size(ptr, size);
        } break;

        case ZPL_ALLOCATION_FREE: {
            if (old_memory) {
                void *end = zpl_pointer_add(s->physical_start, s->total_size);
                if (old_memory < s->physical_start || old_memory >= end) {
                    ZPL_ASSERT(false);
                } else {
                    // NOTE: Mark as free
                    zpl_allocation_header_ev *h = zpl_allocation_header(old_memory);
                    ZPL_ASSERT((h->size & ZPL_ISIZE_HIGH_BIT) == 0);
                    h->size = h->size | ZPL_ISIZE_HIGH_BIT;

                    while (s->free_point != s->alloc_point) {
                        zpl_allocation_header_ev *header = cast(zpl_allocation_header_ev *) s->free_point;
                        if ((header->size & ZPL_ISIZE_HIGH_BIT) == 0) break;

                        s->free_point = zpl_pointer_add(s->free_point, h->size & (~ZPL_ISIZE_HIGH_BIT));
                        if (s->free_point == end) s->free_point = s->physical_start;
                    }
                }
            }
        } break;

        case ZPL_ALLOCATION_FREE_ALL:
        s->alloc_point = s->physical_start;
        s->free_point = s->physical_start;
        break;

        case ZPL_ALLOCATION_RESIZE:
        ptr = zpl_default_resize_align(zpl_scratch_allocator(s), old_memory, old_size, size, alignment);
        break;
    }

    return ptr;
}

//
// Stack Memory Allocator
//

#define ZPL_STACK_ALLOC_OFFSET sizeof(zpl_u64)
ZPL_STATIC_ASSERT(ZPL_STACK_ALLOC_OFFSET == 8);

zpl_inline void zpl_stack_memory_init_from_memory(zpl_stack_memory *s, void *start, zpl_isize size) {
    s->physical_start = start;
    s->total_size = size;
    s->allocated = 0;
}

zpl_inline void zpl_stack_memory_init(zpl_stack_memory *s, zpl_allocator backing, zpl_isize size) {
    s->backing = backing;
    s->physical_start = zpl_alloc(backing, size);
    s->total_size = size;
    s->allocated = 0;
}

zpl_inline zpl_b32 zpl_stack_memory_is_in_use(zpl_stack_memory *s, void *ptr) {
    if (s->allocated == 0) return false;

    if (ptr > s->physical_start && ptr < zpl_pointer_add(s->physical_start, s->total_size)) { return true; }

    return false;
}

zpl_inline void zpl_stack_memory_free(zpl_stack_memory *s) {
    if (s->backing.proc) {
        zpl_free(s->backing, s->physical_start);
        s->physical_start = NULL;
    }
}

zpl_inline zpl_allocator zpl_stack_allocator(zpl_stack_memory *s) {
    zpl_allocator a;
    a.proc = zpl_stack_allocator_proc;
    a.data = s;
    return a;
}

ZPL_ALLOCATOR_PROC(zpl_stack_allocator_proc) {
    zpl_stack_memory *s = cast(zpl_stack_memory *) allocator_data;
    void *ptr = NULL;
    ZPL_ASSERT_NOT_NULL(s);
    zpl_unused(old_size);
    zpl_unused(flags);

    switch (type) {
        case ZPL_ALLOCATION_ALLOC: {
            size += ZPL_STACK_ALLOC_OFFSET;
            zpl_u64 alloc_offset = s->allocated;

            void *curr =
                cast(zpl_u64 *) zpl_align_forward(cast(zpl_u64 *) zpl_pointer_add(s->physical_start, s->allocated), alignment);

            if (cast(zpl_u64 *) zpl_pointer_add(curr, size) > cast(zpl_u64 *) zpl_pointer_add(s->physical_start, s->total_size)) {
                if (s->backing.proc) {
                    void *old_start = s->physical_start;
                    s->physical_start =
                        zpl_resize_align(s->backing, s->physical_start, s->total_size, s->total_size + size, alignment);
                    curr = cast(zpl_u64 *)
                        zpl_align_forward(cast(zpl_u64 *) zpl_pointer_add(s->physical_start, s->allocated), alignment);
                    s->total_size = zpl_pointer_diff(old_start, s->physical_start);
                } else {
                    ZPL_PANIC("Can not resize stack's memory! Allocator not defined!");
                }
            }

            s->allocated = zpl_pointer_diff(s->physical_start, curr) + size;

            *(zpl_u64 *)curr = alloc_offset;
            curr = zpl_pointer_add(curr, ZPL_STACK_ALLOC_OFFSET);

            ptr = curr;
        } break;

        case ZPL_ALLOCATION_FREE: {
            if (old_memory) {
                void *curr = old_memory;
                curr = zpl_pointer_sub(curr, ZPL_STACK_ALLOC_OFFSET);

                zpl_u64 alloc_offset = *(zpl_u64 *)curr;
                s->allocated = (zpl_usize)alloc_offset;
            }
        } break;

        case ZPL_ALLOCATION_FREE_ALL: {
            s->allocated = 0;
        } break;

        case ZPL_ALLOCATION_RESIZE: {
            ZPL_PANIC("You cannot resize something allocated by a stack.");
        } break;
    }
    return ptr;
}


#ifdef ZPL_THREADING

////////////////////////////////////////////////////////////////
//
// Concurrency
//
//



zpl_inline void zpl_yield_thread(void) {
#if defined(ZPL_SYSTEM_WINDOWS)
    _mm_pause();
#elif defined(ZPL_SYSTEM_OSX)
    __asm__ volatile ("" : : : "memory");
#elif defined(ZPL_CPU_X86)
    _mm_pause();
#else
#error Unknown architecture
#endif
}

zpl_inline void zpl_mfence(void) {
#if defined(ZPL_SYSTEM_WINDOWS)
    _ReadWriteBarrier();
#elif defined(ZPL_SYSTEM_OSX)
    __sync_synchronize();
#elif defined(ZPL_CPU_X86)
    _mm_mfence();
#else
#error Unknown architecture
#endif
}

zpl_inline void zpl_sfence(void) {
#if defined(ZPL_SYSTEM_WINDOWS)
    _WriteBarrier();
#elif defined(ZPL_SYSTEM_OSX)
    __asm__ volatile ("" : : : "memory");
#elif defined(ZPL_CPU_X86)
    _mm_sfence();
#else
#error Unknown architecture
#endif
}

zpl_inline void zpl_lfence(void) {
#if defined(ZPL_SYSTEM_WINDOWS)
    _ReadBarrier();
#elif defined(ZPL_SYSTEM_OSX)
    __asm__ volatile ("" : : : "memory");
#elif defined(ZPL_CPU_X86)
    _mm_lfence();
#else
#error Unknown architecture
#endif
}


zpl_inline void zpl_semaphore_release(zpl_semaphore *s) { zpl_semaphore_post(s, 1); }

#if defined(ZPL_SYSTEM_WINDOWS)
zpl_inline void zpl_semaphore_init   (zpl_semaphore *s)            { s->win32_handle = CreateSemaphoreA(NULL, 0, ZPL_I32_MAX, NULL); }
zpl_inline void zpl_semaphore_destroy(zpl_semaphore *s)            { CloseHandle(s->win32_handle); }
zpl_inline void zpl_semaphore_post   (zpl_semaphore *s, zpl_i32 count) { ReleaseSemaphore(s->win32_handle, count, NULL); }
zpl_inline void zpl_semaphore_wait   (zpl_semaphore *s)            { WaitForSingleObject(s->win32_handle, INFINITE); }

#elif defined(ZPL_SYSTEM_OSX)
zpl_inline void zpl_semaphore_init   (zpl_semaphore *s)            { semaphore_create(mach_task_self(), &s->osx_handle, SYNC_POLICY_FIFO, 0); }
zpl_inline void zpl_semaphore_destroy(zpl_semaphore *s)            { semaphore_destroy(mach_task_self(), s->osx_handle); }
zpl_inline void zpl_semaphore_post   (zpl_semaphore *s, zpl_i32 count) { while (count --> 0) semaphore_signal(s->osx_handle); }
zpl_inline void zpl_semaphore_wait   (zpl_semaphore *s)            { semaphore_wait(s->osx_handle); }

#elif defined(ZPL_SYSTEM_UNIX)
zpl_inline void zpl_semaphore_init   (zpl_semaphore *s)            { sem_init(&s->unix_handle, 0, 0); }
zpl_inline void zpl_semaphore_destroy(zpl_semaphore *s)            { sem_destroy(&s->unix_handle); }
zpl_inline void zpl_semaphore_post   (zpl_semaphore *s, zpl_i32 count) { while (count --> 0) sem_post(&s->unix_handle); }
zpl_inline void zpl_semaphore_wait   (zpl_semaphore *s)            { int i; do { i = sem_wait(&s->unix_handle); } while (i == -1 && errno == EINTR); }

#else
#error
#endif

zpl_inline void zpl_mutex_init(zpl_mutex *m) {
#if defined(ZPL_SYSTEM_WINDOWS)
    InitializeCriticalSection(&m->win32_critical_section);
#else
    pthread_mutex_init(&m->pthread_mutex, NULL);
#endif
}

zpl_inline void zpl_mutex_destroy(zpl_mutex *m) {
#if defined(ZPL_SYSTEM_WINDOWS)
    DeleteCriticalSection(&m->win32_critical_section);
#else
    pthread_mutex_destroy(&m->pthread_mutex);
#endif
}

zpl_inline void zpl_mutex_lock(zpl_mutex *m) {
#if defined(ZPL_SYSTEM_WINDOWS)
    EnterCriticalSection(&m->win32_critical_section);
#else
    pthread_mutex_lock(&m->pthread_mutex);
#endif
}

zpl_inline zpl_b32 zpl_mutex_try_lock(zpl_mutex *m) {
#if defined(ZPL_SYSTEM_WINDOWS)
    return TryEnterCriticalSection(&m->win32_critical_section);
#else
    return pthread_mutex_trylock(&m->pthread_mutex);
#endif
}

zpl_inline void zpl_mutex_unlock(zpl_mutex *m) {
#if defined(ZPL_SYSTEM_WINDOWS)
    LeaveCriticalSection(&m->win32_critical_section);
#else
    pthread_mutex_unlock(&m->pthread_mutex);
#endif
}

void zpl_thread_init(zpl_thread *t) {
    zpl_zero_item(t);
#if defined(ZPL_SYSTEM_WINDOWS)
    t->win32_handle = INVALID_HANDLE_VALUE;
#else
    t->posix_handle = 0;
#endif
    zpl_semaphore_init(&t->semaphore);
}

void zpl_thread_destroy(zpl_thread *t) {
    if (t->is_running) zpl_thread_join(t);
    zpl_semaphore_destroy(&t->semaphore);
}

zpl_inline void zpl__thread_run(zpl_thread *t) {
    zpl_semaphore_release(&t->semaphore);
    t->return_value = t->proc(t);
}

#if defined(ZPL_SYSTEM_WINDOWS)
zpl_inline DWORD __stdcall zpl__thread_proc(void *arg) {
    zpl_thread *t = cast(zpl_thread *)arg;
    zpl__thread_run(t);
    t->is_running = false;
    return 0;
}
#else
zpl_inline void *zpl__thread_proc(void *arg) {
    zpl_thread *t = cast(zpl_thread *)arg;
    zpl__thread_run(t);
    t->is_running = false;
    return NULL;
}
#endif

zpl_inline void zpl_thread_start(zpl_thread *t, zpl_thread_proc proc, void *user_data) { zpl_thread_start_with_stack(t, proc, user_data, 0); }

zpl_inline void zpl_thread_start_with_stack(zpl_thread *t, zpl_thread_proc proc, void *user_data, zpl_isize stack_size) {
    ZPL_ASSERT(!t->is_running);
    ZPL_ASSERT(proc != NULL);
    t->proc = proc;
    t->user_data = user_data;
    t->stack_size = stack_size;

#if defined(ZPL_SYSTEM_WINDOWS)
    t->win32_handle = CreateThread(NULL, stack_size, zpl__thread_proc, t, 0, NULL);
    ZPL_ASSERT_MSG(t->win32_handle != NULL, "CreateThread: GetLastError");
#else
    {
        pthread_attr_t attr;
        pthread_attr_init(&attr);
        pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
        if (stack_size != 0)
            pthread_attr_setstacksize(&attr, stack_size);
        pthread_create(&t->posix_handle, &attr, zpl__thread_proc, t);
        pthread_attr_destroy(&attr);
    }
#endif

    t->is_running = true;
    zpl_semaphore_wait(&t->semaphore);
}

zpl_inline void zpl_thread_join(zpl_thread *t) {
    if (!t->is_running) return;

#if defined(ZPL_SYSTEM_WINDOWS)
    WaitForSingleObject(t->win32_handle, INFINITE);
    CloseHandle(t->win32_handle);
    t->win32_handle = INVALID_HANDLE_VALUE;
#else
    pthread_join(t->posix_handle, NULL);
    t->posix_handle = 0;
#endif
    t->is_running = false;
}

zpl_inline zpl_b32 zpl_thread_is_running(zpl_thread const *t) { return t->is_running != 0; }

zpl_inline zpl_u32 zpl_thread_current_id(void) {
    zpl_u32 thread_id;
#if defined(ZPL_SYSTEM_WINDOWS)
#if defined(ZPL_ARCH_32_BIT) && defined(ZPL_CPU_X86)
    thread_id = (cast(zpl_u32 *)__readfsdword(24))[9];
#elif defined(ZPL_ARCH_64_BIT) && defined(ZPL_CPU_X86)
    thread_id = (cast(zpl_u32 *)__readgsqword(48))[18];
#else
    thread_id = GetCurrentThreadId();
#endif

#elif defined(ZPL_SYSTEM_OSX) && defined(ZPL_ARCH_64_BIT)
    thread_id = pthread_mach_thread_np(pthread_self());
#elif defined(ZPL_ARCH_32_BIT) && defined(ZPL_CPU_X86)
    __asm__("mov %%gs:0x08,%0" : "=r"(thread_id));
#elif defined(ZPL_ARCH_64_BIT) && defined(ZPL_CPU_X86)
    __asm__("mov %%fs:0x10,%0" : "=r"(thread_id));
#else
#error Unsupported architecture for zpl_thread_current_id()
#endif

    return thread_id;
}



void zpl_thread_set_name(zpl_thread *t, char const *name) {
#if defined(ZPL_COMPILER_MSVC)
#pragma pack(push, 8)
    typedef struct {
        DWORD       type;
        char const *name;
        DWORD       id;
        DWORD       flags;
    } zplprivThreadName;
#pragma pack(pop)
    zplprivThreadName tn;
    tn.type  = 0x1000;
    tn.name  = name;
    tn.id    = GetThreadId(cast(HANDLE)t->win32_handle);
    tn.flags = 0;

    __try {
        RaiseException(0x406d1388, 0, zpl_size_of(tn)/4, cast(ULONG_PTR *)&tn);
    } __except(1 /*EXCEPTION_EXECUTE_HANDLER*/) {
    }

#elif defined(ZPL_SYSTEM_WINDOWS) && !defined(ZPL_COMPILER_MSVC)
    zpl_unused(t);
    zpl_unused(name);
    // IMPORTANT TODO: Set thread name for GCC/Clang on windows
    return;
#elif defined(ZPL_SYSTEM_OSX)
    // TODO: Test if this works
    pthread_setname_np(name);
#else
    zpl_unused(t);
    zpl_unused(name);
    // TODO: Test if this works
    //        pthread_set_name_np(t->posix_handle, name);
#endif
}

void zpl_sync_init(zpl_sync *s) {
    zpl_zero_item(s);
    zpl_mutex_init(&s->mutex);
    zpl_mutex_init(&s->start);
    zpl_semaphore_init(&s->release);
}

void zpl_sync_destroy(zpl_sync *s) {
    if (s->waiting) {
        ZPL_PANIC("Cannot destroy while threads are waiting!");
    }

    zpl_mutex_destroy(&s->mutex);
    zpl_mutex_destroy(&s->start);
    zpl_semaphore_destroy(&s->release);
}

void zpl_sync_set_target(zpl_sync *s, zpl_i32 count) {
    zpl_mutex_lock(&s->start);

    zpl_mutex_lock(&s->mutex);
    ZPL_ASSERT(s->target == 0);
    s->target = count;
    s->current = 0;
    s->waiting = 0;
    zpl_mutex_unlock(&s->mutex);
}

void zpl_sync_release(zpl_sync *s) {
    if (s->waiting) {
        zpl_semaphore_release(&s->release);
    } else {
        s->target = 0;
        zpl_mutex_unlock(&s->start);
    }
}

zpl_i32 zpl_sync_reach(zpl_sync *s) {
    zpl_i32 n;
    zpl_mutex_lock(&s->mutex);
    ZPL_ASSERT(s->current < s->target);
    n = ++s->current; // NOTE: Record this value to avoid possible race if `return s->current` was done
    if (s->current == s->target)
        zpl_sync_release(s);
    zpl_mutex_unlock(&s->mutex);
    return n;
}

void zpl_sync_reach_and_wait(zpl_sync *s) {
    zpl_mutex_lock(&s->mutex);
    ZPL_ASSERT(s->current < s->target);
    s->current++;
    if (s->current == s->target) {
        zpl_sync_release(s);
        zpl_mutex_unlock(&s->mutex);
    } else {
        s->waiting++;                   // NOTE: Waiting, so one more waiter
        zpl_mutex_unlock(&s->mutex);     // NOTE: Release the mutex to other threads

        zpl_semaphore_wait(&s->release); // NOTE: Wait for merge completion

        zpl_mutex_lock(&s->mutex);       // NOTE: On merge completion, lock mutex
        s->waiting--;                   // NOTE: Done waiting
        zpl_sync_release(s);             // NOTE: Restart the next waiter
        zpl_mutex_unlock(&s->mutex);
    }
}

#if defined(ZPL_SYSTEM_WINDOWS)
void zpl_affinity_init(zpl_affinity *a) {
    SYSTEM_LOGICAL_PROCESSOR_INFORMATION *start_processor_info = NULL;
    DWORD length = 0;
    zpl_b32 result  = GetLogicalProcessorInformation(NULL, &length);

    zpl_zero_item(a);

    if (!result && GetLastError() == 122l /*ERROR_INSUFFICIENT_BUFFER*/ && length > 0) {
        start_processor_info = cast(SYSTEM_LOGICAL_PROCESSOR_INFORMATION *)zpl_alloc(zpl_heap_allocator(), length);
        result = GetLogicalProcessorInformation(start_processor_info, &length);
        if (result) {
            SYSTEM_LOGICAL_PROCESSOR_INFORMATION *end_processor_info, *processor_info;

            a->is_accurate  = true;
            a->core_count   = 0;
            a->thread_count = 0;
            end_processor_info = cast(SYSTEM_LOGICAL_PROCESSOR_INFORMATION *)zpl_pointer_add(start_processor_info, length);

            for (processor_info = start_processor_info;
                 processor_info < end_processor_info;
                 processor_info++) {
                if (processor_info->Relationship == RelationProcessorCore) {
                    zpl_isize thread = zpl_count_set_bits(processor_info->ProcessorMask);
                    if (thread == 0) {
                        a->is_accurate = false;
                    } else if (a->thread_count + thread > ZPL_WIN32_MAX_THREADS) {
                        a->is_accurate = false;
                    } else {
                        ZPL_ASSERT(a->core_count <= a->thread_count &&
                                   a->thread_count < ZPL_WIN32_MAX_THREADS);
                        a->core_masks[a->core_count++] = processor_info->ProcessorMask;
                        a->thread_count += thread;
                    }
                }
            }
        }

        zpl_free(zpl_heap_allocator(), start_processor_info);
    }

    ZPL_ASSERT(a->core_count <= a->thread_count);
    if (a->thread_count == 0) {
        a->is_accurate   = false;
        a->core_count    = 1;
        a->thread_count  = 1;
        a->core_masks[0] = 1;
    }

}
void zpl_affinity_destroy(zpl_affinity *a) {
    zpl_unused(a);
}


zpl_b32 zpl_affinity_set(zpl_affinity *a, zpl_isize core, zpl_isize thread) {
    zpl_usize available_mask, check_mask = 1;
    ZPL_ASSERT(thread < zpl_affinity_thread_count_for_core(a, core));

    available_mask = a->core_masks[core];
    for (;;) {
        if ((available_mask & check_mask) != 0) {
            if (thread-- == 0) {
                zpl_usize result = SetThreadAffinityMask(GetCurrentThread(), check_mask);
                return result != 0;
            }
        }
        check_mask <<= 1; // NOTE: Onto the next bit
    }
}

zpl_isize zpl_affinity_thread_count_for_core(zpl_affinity *a, zpl_isize core) {
    ZPL_ASSERT(core >= 0 && core < a->core_count);
    return zpl_count_set_bits(a->core_masks[core]);
}

#elif defined(ZPL_SYSTEM_OSX)
void zpl_affinity_init(zpl_affinity *a) {
    zpl_usize count, count_size = zpl_size_of(count);

    a->is_accurate      = false;
    a->thread_count     = 1;
    a->core_count       = 1;
    a->threads_per_core = 1;

    if (sysctlbyname("hw.logicalcpu", &count, &count_size, NULL, 0) == 0) {
        if (count > 0) {
            a->thread_count = count;
            // Get # of physical cores
            if (sysctlbyname("hw.physicalcpu", &count, &count_size, NULL, 0) == 0) {
                if (count > 0) {
                    a->core_count = count;
                    a->threads_per_core = a->thread_count / count;
                    if (a->threads_per_core < 1)
                        a->threads_per_core = 1;
                    else
                        a->is_accurate = true;
                }
            }
        }
    }

}

void zpl_affinity_destroy(zpl_affinity *a) {
    zpl_unused(a);
}

zpl_b32 zpl_affinity_set(zpl_affinity *a, zpl_isize core, zpl_isize thread_index) {
    zpl_isize index;
    thread_t thread;
    thread_affinity_policy_data_t info;
    kern_return_t result;

    ZPL_ASSERT(core < a->core_count);
    ZPL_ASSERT(thread_index < a->threads_per_core);

    index = core * a->threads_per_core + thread_index;
    thread = mach_thread_self();
    info.affinity_tag = cast(integer_t)index;
    result = thread_policy_set(thread, THREAD_AFFINITY_POLICY, cast(thread_policy_t)&info, THREAD_AFFINITY_POLICY_COUNT);
    return result == KERN_SUCCESS;
}

zpl_isize zpl_affinity_thread_count_for_core(zpl_affinity *a, zpl_isize core) {
    ZPL_ASSERT(core >= 0 && core < a->core_count);
    return a->threads_per_core;
}

#elif defined(ZPL_SYSTEM_LINUX)
// IMPORTANT TODO: This zpl_affinity stuff for linux needs be improved a lot!
// NOTE(zangent): I have to read /proc/cpuinfo to get the number of threads per core.
#include <stdio.h>

void zpl_affinity_init(zpl_affinity *a) {
    zpl_b32   accurate = true;
    zpl_isize threads = 0;

    a->thread_count     = 1;
    a->core_count       = sysconf(_SC_NPROCESSORS_ONLN);
    a->threads_per_core = 1;


    if(a->core_count <= 0) {
        a->core_count = 1;
        accurate = false;
    }

    // Parsing /proc/cpuinfo to get the number of threads per core.
    // NOTE(zangent): This calls the CPU's threads "cores", although the wording
    // is kind of weird. This should be right, though.
    FILE *cpu_info = fopen("/proc/cpuinfo", "r");
    if (cpu_info != NULL) {
        for (;;) {
            // The 'temporary char'. Everything goes into this char,
            // so that we can check against EOF at the end of this loop.
            int c;

#define AF__CHECK(letter) ((c = getc(cpu_info)) == letter)
            if (AF__CHECK('c') && AF__CHECK('p') && AF__CHECK('u') && AF__CHECK(' ') &&
                AF__CHECK('c') && AF__CHECK('o') && AF__CHECK('r') && AF__CHECK('e') && AF__CHECK('s')) {
                // We're on a CPU info line.
                while (!AF__CHECK(EOF)) {
                    if (c == '\n') {
                        break;
                    } else if (c < '0' || '9' > c) {
                        continue;
                    }
                    threads = threads * 10 + (c - '0');
                }
                break;
            } else {
                while (!AF__CHECK('\n')) {
                    if (c==EOF) {
                        break;
                    }
                }
            }
            if (c == EOF) {
                break;
            }
#undef AF__CHECK
        }

        fclose(cpu_info);
    }

    if (threads == 0) {
        threads  = 1;
        accurate = false;
    }

    a->threads_per_core = threads;
    a->thread_count = a->threads_per_core * a->core_count;
    a->is_accurate = accurate;

}

void zpl_affinity_destroy(zpl_affinity *a) {
    zpl_unused(a);
}

zpl_b32 zpl_affinity_set(zpl_affinity * a, zpl_isize core, zpl_isize thread_index) {
    zpl_unused(a);
    zpl_unused(core);
    zpl_unused(thread_index);
    return true;
}

zpl_isize zpl_affinity_thread_count_for_core(zpl_affinity *a, zpl_isize core) {
    ZPL_ASSERT(0 <= core && core < a->core_count);
    return a->threads_per_core;
}
#elif defined(ZPL_SYSTEM_EMSCRIPTEN)
// no code 4 u :(
#else
    #error TODO: Unknown system
#endif

#endif // ZPL_THREADING


////////////////////////////////////////////////////////////////
//
// Sorting
//
//

// TODO: Should I make all the macros local?

#define ZPL__COMPARE_PROC(Type)                                                                                        \
zpl_global zpl_isize Type##__cmp_offset;                                                                         \
ZPL_COMPARE_PROC(Type##__cmp) {                                                                              \
    Type const p = *cast(Type const *) zpl_pointer_add_const(a, Type##__cmp_offset);                         \
    Type const q = *cast(Type const *) zpl_pointer_add_const(b, Type##__cmp_offset);                         \
    return p < q ? -1 : p > q;                                                                                     \
}                                                                                                                  \
ZPL_COMPARE_PROC_PTR(Type##_cmp(zpl_isize offset)) {                                                             \
    Type##__cmp_offset = offset;                                                                             \
    return &Type##__cmp;                                                                                     \
}

ZPL__COMPARE_PROC(zpl_u8);
ZPL__COMPARE_PROC(zpl_i16);
ZPL__COMPARE_PROC(zpl_i32);
ZPL__COMPARE_PROC(zpl_i64);
ZPL__COMPARE_PROC(zpl_isize);
ZPL__COMPARE_PROC(zpl_f32);
ZPL__COMPARE_PROC(zpl_f64);

// NOTE: str_cmp is special as it requires a funny type and funny comparison
zpl_global zpl_isize zpl__str_cmp_offset;
ZPL_COMPARE_PROC(zpl__str_cmp) {
    char const *p = *cast(char const **) zpl_pointer_add_const(a, zpl__str_cmp_offset);
    char const *q = *cast(char const **) zpl_pointer_add_const(b, zpl__str_cmp_offset);
    return zpl_strcmp(p, q);
}
ZPL_COMPARE_PROC_PTR(zpl_str_cmp(zpl_isize offset)) {
    zpl__str_cmp_offset = offset;
    return &zpl__str_cmp;
}

#undef ZPL__COMPARE_PROC

// TODO: Make user definable?
#define ZPL__SORT_STACK_SIZE 64
#define zpl__SORT_INSERT_SORT_TRESHOLD 8

#define ZPL__SORT_PUSH(_base, _limit)                                                                                  \
do {                                                                                                               \
    stack_ptr[0] = (_base);                                                                                        \
    stack_ptr[1] = (_limit);                                                                                       \
    stack_ptr += 2;                                                                                                \
} while (0)

#define ZPL__SORT_POP(_base, _limit)                                                                                   \
do {                                                                                                               \
    stack_ptr -= 2;                                                                                                \
    (_base) = stack_ptr[0];                                                                                        \
    (_limit) = stack_ptr[1];                                                                                       \
} while (0)

void zpl_sort(void *base_, zpl_isize count, zpl_isize size, zpl_compare_proc cmp) {
    zpl_u8 *i, *j;
    zpl_u8 *base = cast(zpl_u8 *) base_;
    zpl_u8 *limit = base + count * size;
    zpl_isize threshold = zpl__SORT_INSERT_SORT_TRESHOLD * size;

    // NOTE: Prepare the stack
    zpl_u8 *stack[ZPL__SORT_STACK_SIZE] = { 0 };
    zpl_u8 **stack_ptr = stack;

    for (;;) {
        if ((limit - base) > threshold) {
            // NOTE: Quick sort
            i = base + size;
            j = limit - size;

            zpl_memswap(((limit - base) / size / 2) * size + base, base, size);
            if (cmp(i, j) > 0) zpl_memswap(i, j, size);
            if (cmp(base, j) > 0) zpl_memswap(base, j, size);
            if (cmp(i, base) > 0) zpl_memswap(i, base, size);

            for (;;) {
                do
                    i += size;
                while (cmp(i, base) < 0);
                do
                    j -= size;
                while (cmp(j, base) > 0);
                if (i > j) break;
                zpl_memswap(i, j, size);
            }

            zpl_memswap(base, j, size);

            if (j - base > limit - i) {
                ZPL__SORT_PUSH(base, j);
                base = i;
            } else {
                ZPL__SORT_PUSH(i, limit);
                limit = j;
            }
        } else {
            // NOTE: Insertion sort
            for (j = base, i = j + size; i < limit; j = i, i += size) {
                for (; cmp(j, j + size) > 0; j -= size) {
                    zpl_memswap(j, j + size, size);
                    if (j == base) break;
                }
            }

            if (stack_ptr == stack) break; // NOTE: Sorting is done!
            ZPL__SORT_POP(base, limit);
        }
    }
}

#undef ZPL__SORT_PUSH
#undef ZPL__SORT_POP

#define ZPL_RADIX_SORT_PROC_GEN(Type)                                                                                  \
ZPL_RADIX_SORT_PROC(Type) {                                                                                        \
    zpl_##Type *source = items;                                                                                          \
    zpl_##Type *dest = temp;                                                                                             \
    zpl_isize byte_index, i, byte_max = 8 * zpl_size_of(zpl_##Type);                                                         \
    for (byte_index = 0; byte_index < byte_max; byte_index += 8) {                                                 \
        zpl_isize offsets[256] = { 0 };                                                                                \
        zpl_isize total = 0;                                                                                           \
        /* NOTE: First pass - count how many of each key */                                                        \
        for (i = 0; i < count; i++) {                                                                              \
            zpl_##Type radix_value = source[i];                                                                          \
            zpl_##Type radix_piece = (radix_value >> byte_index) & 0xff;                                                 \
            offsets[radix_piece]++;                                                                                \
        }                                                                                                          \
        /* NOTE: Change counts to offsets */                                                                       \
        for (i = 0; i < zpl_count_of(offsets); i++) {                                                              \
            zpl_isize skcount = offsets[i];                                                                            \
            offsets[i] = total;                                                                                    \
            total += skcount;                                                                                      \
        }                                                                                                          \
        /* NOTE: Second pass - place elements into the right location */                                           \
        for (i = 0; i < count; i++) {                                                                              \
            zpl_##Type radix_value = source[i];                                                                          \
            zpl_##Type radix_piece = (radix_value >> byte_index) & 0xff;                                                 \
            dest[offsets[radix_piece]++] = source[i];                                                              \
        }                                                                                                          \
        zpl_swap(zpl_##Type *, source, dest);                                                                            \
    }                                                                                                              \
}

ZPL_RADIX_SORT_PROC_GEN(u8);
ZPL_RADIX_SORT_PROC_GEN(u16);
ZPL_RADIX_SORT_PROC_GEN(u32);
ZPL_RADIX_SORT_PROC_GEN(u64);

zpl_inline zpl_isize zpl_binary_search(void const *base, zpl_isize count, zpl_isize size, void const *key,
                                   zpl_compare_proc compare_proc) {
    zpl_isize start = 0;
    zpl_isize end = count;

    while (start < end) {
        zpl_isize mid = start + (end - start) / 2;
        zpl_isize result = compare_proc(key, cast(zpl_u8 *) base + mid * size);
        if (result < 0)
            end = mid;
        else if (result > 0)
            start = mid + 1;
        else
            return mid;
    }

    return -1;
}

void zpl_shuffle(void *base, zpl_isize count, zpl_isize size) {
    zpl_u8 *a;
    zpl_isize i, j;
    zpl_random random;
    zpl_random_init(&random);

    a = cast(zpl_u8 *) base + (count - 1) * size;
    for (i = count; i > 1; i--) {
        j = zpl_random_gen_isize(&random) % i;
        zpl_memswap(a, cast(zpl_u8 *) base + j * size, size);
        a -= size;
    }
}

void zpl_reverse(void *base, zpl_isize count, zpl_isize size) {
    zpl_isize i, j = count - 1;
    for (i = 0; i < j; i++, j++) zpl_memswap(cast(zpl_u8 *) base + i * size, cast(zpl_u8 *) base + j * size, size);
}


////////////////////////////////////////////////////////////////
//
// Char things
//
//

zpl_inline char zpl_char_to_lower(char c) {
    if (c >= 'A' && c <= 'Z') return 'a' + (c - 'A');
    return c;
}

zpl_inline char zpl_char_to_upper(char c) {
    if (c >= 'a' && c <= 'z') return 'A' + (c - 'a');
    return c;
}

zpl_inline zpl_b32 zpl_char_is_space(char c) {
    if (c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\f' || c == '\v') return true;
    return false;
}

zpl_inline zpl_b32 zpl_char_is_digit(char c) {
    if (c >= '0' && c <= '9') return true;
    return false;
}

zpl_inline zpl_b32 zpl_char_is_hex_digit(char c) {
    if (zpl_char_is_digit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')) return true;
    return false;
}

zpl_inline zpl_b32 zpl_char_is_alpha(char c) {
    if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) return true;
    return false;
}

zpl_inline zpl_b32 zpl_char_is_alphanumeric(char c) { return zpl_char_is_alpha(c) || zpl_char_is_digit(c); }

zpl_inline zpl_i32 zpl_digit_to_int(char c) { return zpl_char_is_digit(c) ? c - '0' : c - 'W'; }

zpl_inline zpl_i32 zpl_hex_digit_to_int(char c) {
    if (zpl_char_is_digit(c))
        return zpl_digit_to_int(c);
    else if (zpl_is_between(c, 'a', 'f'))
        return c - 'a' + 10;
    else if (zpl_is_between(c, 'A', 'F'))
        return c - 'A' + 10;
    return -1;
}

zpl_inline zpl_u8 zpl_char_to_hex_digit(char c) {
    if (c >= '0' && c <= '9')
        return (zpl_u8)(c - '0');
    if (c >= 'a' && c <= 'f')
        return (zpl_u8)(c - 'a');
    if (c >= 'A' && c <= 'F')
        return (zpl_u8)(c - 'A');
    return 0;
}


zpl_inline void zpl_str_to_lower(char *str) {
    if (!str) return;
    while (*str) {
        *str = zpl_char_to_lower(*str);
        str++;
    }
}

zpl_inline void zpl_str_to_upper(char *str) {
    if (!str) return;
    while (*str) {
        *str = zpl_char_to_upper(*str);
        str++;
    }
}

zpl_inline zpl_isize zpl_strlen(const char *str) {
    if (str == NULL) { return 0; }

    const char *begin = str;
    zpl_isize const *w;
    while (cast(zpl_uintptr) str % sizeof(zpl_usize)) {
        if (!*str) return str - begin;
        str++;
    }
    w = cast(zpl_isize const *) str;
    while (!ZPL__HAS_ZERO(*w)) w++;
    str = cast(const char *) w;
    while (*str) str++;
    return str - begin;
}

zpl_inline zpl_isize zpl_strnlen(const char *str, zpl_isize max_len) {
    const char *end = cast(const char *) zpl_memchr(str, 0, max_len);
    if (end) return end - str;
    return max_len;
}

zpl_inline zpl_isize zpl_utf8_strlen(zpl_u8 const *str) {
    zpl_isize count = 0;
    for (; *str; count++) {
        zpl_u8 c = *str;
        zpl_isize inc = 0;
        if (c < 0x80)
            inc = 1;
        else if ((c & 0xe0) == 0xc0)
            inc = 2;
        else if ((c & 0xf0) == 0xe0)
            inc = 3;
        else if ((c & 0xf8) == 0xf0)
            inc = 4;
        else
            return -1;

        str += inc;
    }
    return count;
}

zpl_inline zpl_isize zpl_utf8_strnlen(zpl_u8 const *str, zpl_isize max_len) {
    zpl_isize count = 0;
    for (; *str && max_len > 0; count++) {
        zpl_u8 c = *str;
        zpl_isize inc = 0;
        if (c < 0x80)
            inc = 1;
        else if ((c & 0xe0) == 0xc0)
            inc = 2;
        else if ((c & 0xf0) == 0xe0)
            inc = 3;
        else if ((c & 0xf8) == 0xf0)
            inc = 4;
        else
            return -1;

        str += inc;
        max_len -= inc;
    }
    return count;
}

zpl_inline zpl_i32 zpl_strcmp(const char *s1, const char *s2) {
    while (*s1 && (*s1 == *s2)) { s1++, s2++; }
    return *(zpl_u8 *)s1 - *(zpl_u8 *)s2;
}

zpl_inline char *zpl_strcpy(char *dest, const char *source) {
    ZPL_ASSERT_NOT_NULL(dest);
    if (source) {
        char *str = dest;
        while (*source) *str++ = *source++;
    }
    return dest;
}

zpl_inline char *zpl_strdup(zpl_allocator a, char *src, zpl_isize max_len) {
    ZPL_ASSERT_NOT_NULL(src);
    zpl_isize len = zpl_strlen(src);
    char *dest = cast(char *) zpl_alloc(a, max_len);
    zpl_memset(dest + len, 0, max_len - len);
    zpl_strncpy(dest, src, max_len);

    return dest;
}

zpl_inline char *zpl_strncpy(char *dest, const char *source, zpl_isize len) {
    ZPL_ASSERT_NOT_NULL(dest);
    if (source) {
        char *str = dest;
        while (len > 0 && *source) {
            *str++ = *source++;
            len--;
        }
        while (len > 0) {
            *str++ = '\0';
            len--;
        }
    }
    return dest;
}

zpl_inline zpl_isize zpl_strlcpy(char *dest, const char *source, zpl_isize len) {
    zpl_isize result = 0;
    ZPL_ASSERT_NOT_NULL(dest);
    if (source) {
        const char *source_start = source;
        char *str = dest;
        while (len > 0 && *source) {
            *str++ = *source++;
            len--;
        }
        while (len > 0) {
            *str++ = '\0';
            len--;
        }

        result = source - source_start;
    }
    return result;
}

zpl_inline char *zpl_strrev(char *str) {
    zpl_isize len = zpl_strlen(str);
    char *a = str + 0;
    char *b = str + len - 1;
    len /= 2;
    while (len--) {
        zpl_swap(char, *a, *b);
        a++, b--;
    }
    return str;
}

zpl_inline zpl_i32 zpl_strncmp(const char *s1, const char *s2, zpl_isize len) {
    for (; len > 0; s1++, s2++, len--) {
        if (*s1 != *s2)
            return ((s1 < s2) ? -1 : +1);
        else if (*s1 == '\0')
            return 0;
    }
    return 0;
}

zpl_inline const char *zpl_strtok(char *output, const char *src, const char *delimit) {
    while (*src && zpl_char_first_occurence(delimit, *src) == NULL) *output++ = *src++;

    *output = 0;
    return *src ? src + 1 : src;
}

zpl_inline char **zpl_str_split_lines(zpl_allocator alloc, char *source, zpl_b32 strip_whitespace) {
    char **lines = NULL, *p = source, *pd = p;
    zpl_array_init(lines, alloc);

    while (*p) {
        if (*pd == '\n') {
            *pd = 0;
            if (*(pd - 1) == '\r') *(pd - 1) = 0;
            if (strip_whitespace && (pd - p) == 0) {
                p = pd + 1;
                continue;
            }
            zpl_array_append(lines, p);
            p = pd + 1;
        }
        ++pd;
    }
    return lines;
}

zpl_inline zpl_b32 zpl__is_control_char(char c) {
    return !!zpl_strchr("\"\\/bfnrt", c);
}

zpl_inline zpl_b32 zpl__is_special_char(char c) { return !!zpl_strchr("<>:/", c); }
zpl_inline zpl_b32 zpl__is_assign_char(char c) { return !!zpl_strchr(":=|", c); }
zpl_inline zpl_b32 zpl__is_delim_char(char c) { return !!zpl_strchr(",|\n", c); }


zpl_inline char *zpl_str_control_skip(char *str, char c) {
    while ((*str && *str != c) || (*(str - 1) == '\\' && *str == c && zpl__is_control_char(c))) { ++str; }

    return str;
}


zpl_inline zpl_b32 zpl_str_has_prefix(const char *str, const char *prefix) {
    while (*prefix) {
        if (*str++ != *prefix++) return false;
    }
    return true;
}

zpl_inline zpl_b32 zpl_str_has_suffix(const char *str, const char *suffix) {
    zpl_isize i = zpl_strlen(str);
    zpl_isize j = zpl_strlen(suffix);
    if (j <= i) return zpl_strcmp(str + i - j, suffix) == 0;
    return false;
}

zpl_inline const char *zpl_char_first_occurence(const char *s, char c) {
    char ch = c;
    for (; *s != ch; s++) {
        if (*s == '\0') return NULL;
    }
    return s;
}

zpl_inline const char *zpl_char_last_occurence(const char *s, char c) {
    const char *result = NULL;
    do {
        if (*s == c) result = s;
    } while (*s++);

    return result;
}

zpl_inline char *zpl_str_trim(char *str, zpl_b32 skip_newline)
{
    while (*str && zpl_char_is_space(*str) && (!skip_newline || (skip_newline && *str != '\n'))) { ++str; }
    return str;
}

zpl_inline char *zpl_str_skip(char *str, char c) {
    while (*str && *str != c) { ++str; }
    return str;
}

zpl_inline void zpl_str_concat(char *dest, zpl_isize dest_len, const char *src_a, zpl_isize src_a_len, const char *src_b,
                               zpl_isize src_b_len) {
    ZPL_ASSERT(dest_len >= src_a_len + src_b_len + 1);
    if (dest) {
        zpl_memcopy(dest, src_a, src_a_len);
        zpl_memcopy(dest + src_a_len, src_b, src_b_len);
        dest[src_a_len + src_b_len] = '\0';
    }
}

zpl_internal zpl_isize zpl__scan_zpl_i64(const char *text, zpl_i32 base, zpl_i64 *value) {
    const char *text_begin = text;
    zpl_i64 result = 0;
    zpl_b32 negative = false;

    if (*text == '-') {
        negative = true;
        text++;
    }

    if (base == 16 && zpl_strncmp(text, "0x", 2) == 0) text += 2;

    for (;;) {
        zpl_i64 v;
        if (zpl_char_is_digit(*text))
            v = *text - '0';
        else if (base == 16 && zpl_char_is_hex_digit(*text))
            v = zpl_hex_digit_to_int(*text);
        else
            break;

        result *= base;
        result += v;
        text++;
    }

    if (value) {
        if (negative) result = -result;
        *value = result;
    }

    return (text - text_begin);
}

zpl_internal zpl_isize zpl__scan_zpl_u64(const char *text, zpl_i32 base, zpl_u64 *value) {
    const char *text_begin = text;
    zpl_u64 result = 0;

    if (base == 16 && zpl_strncmp(text, "0x", 2) == 0) text += 2;

    for (;;) {
        zpl_u64 v;
        if (zpl_char_is_digit(*text))
            v = *text - '0';
        else if (base == 16 && zpl_char_is_hex_digit(*text))
            v = zpl_hex_digit_to_int(*text);
        else {
            break;
        }

        result *= base;
        result += v;
        text++;
    }

    if (value) *value = result;

    return (text - text_begin);
}

// TODO: Make better
zpl_u64 zpl_str_to_u64(const char *str, char **end_ptr, zpl_i32 base) {
    zpl_isize len;
    zpl_u64 value = 0;

    if (!base) {
        if ((zpl_strlen(str) > 2) && (zpl_strncmp(str, "0x", 2) == 0))
            base = 16;
        else
            base = 10;
    }

    len = zpl__scan_zpl_u64(str, base, &value);
    if (end_ptr) *end_ptr = (char *)str + len;
    return value;
}

zpl_i64 zpl_str_to_i64(const char *str, char **end_ptr, zpl_i32 base) {
    zpl_isize len;
    zpl_i64 value;

    if (!base) {
        if ((zpl_strlen(str) > 2) && (zpl_strncmp(str, "0x", 2) == 0))
            base = 16;
        else
            base = 10;
    }

    len = zpl__scan_zpl_i64(str, base, &value);
    if (end_ptr) *end_ptr = (char *)str + len;
    return value;
}

// TODO: Are these good enough for characters?
zpl_global const char zpl__num_to_char_table[] = "0123456789"
"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
"abcdefghijklmnopqrstuvwxyz"
"@$";

zpl_inline void zpl_i64_to_str(zpl_i64 value, char *string, zpl_i32 base) {
    char *buf = string;
    zpl_b32 negative = false;
    zpl_u64 v;

    if (value < 0) {
        negative = true;
        value = -value;
    }

    v = cast(zpl_u64) value;
    if (v != 0) {
        while (v > 0) {
            *buf++ = zpl__num_to_char_table[v % base];
            v /= base;
        }
    } else {
        *buf++ = '0';
    }
    if (negative) *buf++ = '-';
    *buf = '\0';
    zpl_strrev(string);
}

zpl_inline void zpl_u64_to_str(zpl_u64 value, char *string, zpl_i32 base) {
    char *buf = string;

    if (value) {
        while (value > 0) {
            *buf++ = zpl__num_to_char_table[value % base];
            value /= base;
        }
    } else {
        *buf++ = '0';
    }
    *buf = '\0';

    zpl_strrev(string);
}

zpl_inline zpl_f32 zpl_str_to_f32(const char *str, char **end_ptr) {
    zpl_f64 f = zpl_str_to_f64(str, end_ptr);
    zpl_f32 r = cast(zpl_f32) f;
    return r;
}

zpl_inline zpl_f64 zpl_str_to_f64(const char *str, char **end_ptr) {
    zpl_f64 result, value, sign, scale;
    zpl_i32 frac;

    while (zpl_char_is_space(*str)) { str++; }

    sign = 1.0;
    if (*str == '-') {
        sign = -1.0;
        str++;
    } else if (*str == '+') {
        str++;
    }

    for (value = 0.0; zpl_char_is_digit(*str); str++) { value = value * 10.0 + (*str - '0'); }

    if (*str == '.') {
        zpl_f64 pow10 = 10.0;
        str++;
        while (zpl_char_is_digit(*str)) {
            value += (*str - '0') / pow10;
            pow10 *= 10.0;
            str++;
        }
    }

    frac = 0;
    scale = 1.0;
    if ((*str == 'e') || (*str == 'E')) {
        zpl_u32 exp;

        str++;
        if (*str == '-') {
            frac = 1;
            str++;
        } else if (*str == '+') {
            str++;
        }

        for (exp = 0; zpl_char_is_digit(*str); str++) { exp = exp * 10 + (*str - '0'); }
        if (exp > 308) exp = 308;

        while (exp >= 50) {
            scale *= 1e50;
            exp -= 50;
        }
        while (exp >= 8) {
            scale *= 1e8;
            exp -= 8;
        }
        while (exp > 0) {
            scale *= 10.0;
            exp -= 1;
        }
    }

    result = sign * (frac ? (value / scale) : (value * scale));

    if (end_ptr) *end_ptr = cast(char *) str;

    return result;
}

zpl_inline void zpl__set_string_length(zpl_string str, zpl_isize len) { ZPL_STRING_HEADER(str)->length = len; }
zpl_inline void zpl__set_string_capacity(zpl_string str, zpl_isize cap) { ZPL_STRING_HEADER(str)->capacity = cap; }

zpl_inline zpl_string zpl_string_make_reserve(zpl_allocator a, zpl_isize capacity) {
    zpl_isize header_size = zpl_size_of(zpl_string_header);
    void *ptr = zpl_alloc(a, header_size + capacity + 1);

    zpl_string str;
    zpl_string_header *header;

    if (ptr == NULL) return NULL;
    zpl_zero_size(ptr, header_size + capacity + 1);

    str = cast(char *) ptr + header_size;
    header = ZPL_STRING_HEADER(str);
    header->allocator = a;
    header->length = 0;
    header->capacity = capacity;
    str[capacity] = '\0';

    return str;
}

zpl_inline zpl_string zpl_string_make(zpl_allocator a, const char *str) {
    zpl_isize len = str ? zpl_strlen(str) : 0;
    return zpl_string_make_length(a, str, len);
}

zpl_string zpl_string_make_length(zpl_allocator a, void const *init_str, zpl_isize num_bytes) {
    zpl_isize header_size = zpl_size_of(zpl_string_header);
    void *ptr = zpl_alloc(a, header_size + num_bytes + 1);

    zpl_string str;
    zpl_string_header *header;

    if (ptr == NULL) return NULL;
    if (!init_str) zpl_zero_size(ptr, header_size + num_bytes + 1);

    str = cast(char *) ptr + header_size;
    header = ZPL_STRING_HEADER(str);
    header->allocator = a;
    header->length = num_bytes;
    header->capacity = num_bytes;
    if (num_bytes && init_str) zpl_memcopy(str, init_str, num_bytes);
    str[num_bytes] = '\0';

    return str;
}

zpl_string zpl_string_sprintf_buf(zpl_allocator a, const char *fmt, ...) {
    zpl_local_persist char buf[4096] = { 0 };
    va_list va;
    va_start(va, fmt);
    zpl_snprintf_va(buf, 4096, fmt, va);
    va_end(va);

    return zpl_string_make(a, buf);
}

zpl_string zpl_string_sprintf(zpl_allocator a, char *buf, zpl_isize num_bytes, const char *fmt, ...) {
    va_list va;
    va_start(va, fmt);
    zpl_snprintf_va(buf, num_bytes, fmt, va);
    va_end(va);

    return zpl_string_make(a, buf);
}

zpl_inline void zpl_string_free(zpl_string str) {
    if (str) {
        zpl_string_header *header = ZPL_STRING_HEADER(str);
        zpl_free(header->allocator, header);
    }
}

zpl_inline zpl_string zpl_string_duplicate(zpl_allocator a, zpl_string const str) {
    return zpl_string_make_length(a, str, zpl_string_length(str));
}

zpl_inline zpl_isize zpl_string_length(zpl_string const str) { return ZPL_STRING_HEADER(str)->length; }
zpl_inline zpl_isize zpl_string_capacity(zpl_string const str) { return ZPL_STRING_HEADER(str)->capacity; }

zpl_inline zpl_isize zpl_string_available_space(zpl_string const str) {
    zpl_string_header *h = ZPL_STRING_HEADER(str);
    if (h->capacity > h->length) return h->capacity - h->length;
    return 0;
}

zpl_inline void zpl_string_clear(zpl_string str) {
    zpl__set_string_length(str, 0);
    str[0] = '\0';
}

zpl_inline zpl_string zpl_string_append(zpl_string str, zpl_string const other) {
    return zpl_string_append_length(str, other, zpl_string_length(other));
}

zpl_string zpl_string_append_length(zpl_string str, void const *other, zpl_isize other_len) {
    if (other_len > 0) {
        zpl_isize curr_len = zpl_string_length(str);

        str = zpl_string_make_space_for(str, other_len);
        if (str == NULL) return NULL;

        zpl_memcopy(str + curr_len, other, other_len);
        str[curr_len + other_len] = '\0';
        zpl__set_string_length(str, curr_len + other_len);
    }
    return str;
}

zpl_inline zpl_string zpl_string_appendc(zpl_string str, const char *other) {
    return zpl_string_append_length(str, other, zpl_strlen(other));
}

zpl_inline zpl_string zpl_string_join(zpl_allocator a, const char **parts, zpl_isize count, const char *glue) {
    zpl_string ret;
    zpl_isize i;

    ret = zpl_string_make(a, NULL);

    for (i=0; i<count; ++i) {
        ret = zpl_string_appendc(ret, parts[i]);

        if ((i+1) < count) {
            ret = zpl_string_appendc(ret, glue);
        }
    }

    return ret;
}

zpl_string zpl_string_set(zpl_string str, const char *cstr) {
    zpl_isize len = zpl_strlen(cstr);
    if (zpl_string_capacity(str) < len) {
        str = zpl_string_make_space_for(str, len - zpl_string_length(str));
        if (str == NULL) return NULL;
    }

    zpl_memcopy(str, cstr, len);
    str[len] = '\0';
    zpl__set_string_length(str, len);

    return str;
}

zpl_string zpl_string_make_space_for(zpl_string str, zpl_isize add_len) {
    zpl_isize available = zpl_string_available_space(str);

    // NOTE: Return if there is enough space left
    if (available >= add_len) {
        return str;
    } else {
        zpl_isize new_len, old_size, new_size;
        void *ptr, *new_ptr;
        zpl_allocator a = ZPL_STRING_HEADER(str)->allocator;
        zpl_string_header *header;

        new_len = zpl_string_length(str) + add_len;
        ptr = ZPL_STRING_HEADER(str);
        old_size = zpl_size_of(zpl_string_header) + zpl_string_length(str) + 1;
        new_size = zpl_size_of(zpl_string_header) + new_len + 1;

        new_ptr = zpl_resize(a, ptr, old_size, new_size);
        if (new_ptr == NULL) return NULL;

        header = cast(zpl_string_header *) new_ptr;
        header->allocator = a;

        str = cast(zpl_string)(header + 1);
        zpl__set_string_capacity(str, new_len);

        return str;
    }
}

zpl_inline zpl_isize zpl_string_allocation_size(zpl_string const str) {
    zpl_isize cap = zpl_string_capacity(str);
    return zpl_size_of(zpl_string_header) + cap;
}

zpl_inline zpl_b32 zpl_string_are_equal(zpl_string const lhs, zpl_string const rhs) {
    zpl_isize lhs_len, rhs_len, i;
    lhs_len = zpl_string_length(lhs);
    rhs_len = zpl_string_length(rhs);
    if (lhs_len != rhs_len) return false;

    for (i = 0; i < lhs_len; i++) {
        if (lhs[i] != rhs[i]) return false;
    }

    return true;
}

zpl_string zpl_string_trim(zpl_string str, const char *cut_set) {
    char *start, *end, *start_pos, *end_pos;
    zpl_isize len;

    start_pos = start = str;
    end_pos = end = str + zpl_string_length(str) - 1;

    while (start_pos <= end && zpl_char_first_occurence(cut_set, *start_pos)) start_pos++;
    while (end_pos > start_pos && zpl_char_first_occurence(cut_set, *end_pos)) end_pos--;

    len = cast(zpl_isize)((start_pos > end_pos) ? 0 : ((end_pos - start_pos) + 1));

    if (str != start_pos) zpl_memmove(str, start_pos, len);
    str[len] = '\0';

    zpl__set_string_length(str, len);

    return str;
}

zpl_inline zpl_string zpl_string_trim_space(zpl_string str) { return zpl_string_trim(str, " \t\r\n\v\f"); }

zpl_string zpl_string_append_rune(zpl_string str, zpl_rune r) {
    if (r >= 0) {
        zpl_u8 buf[8] = { 0 };
        zpl_isize len = zpl_utf8_encode_rune(buf, r);
        return zpl_string_append_length(str, buf, len);
    }

    return str;
}

zpl_string zpl_string_append_fmt(zpl_string str, const char *fmt, ...) {
    zpl_isize res;
    char buf[4096] = { 0 };
    va_list va;
    va_start(va, fmt);
    res = zpl_snprintf_va(buf, zpl_count_of(buf) - 1, fmt, va) - 1;
    va_end(va);
    return zpl_string_append_length(str, buf, res);
}

////////////////////////////////////////////////////////////////
//
// Windows UTF-8 Handling
//
//

zpl_u16 *zpl_utf8_to_ucs2(zpl_u16 *buffer, zpl_isize len, zpl_u8 const *str) {
    zpl_rune c;
    zpl_isize i = 0;
    len--;
    while (*str) {
        if (i >= len) return NULL;
        if (!(*str & 0x80)) {
            buffer[i++] = *str++;
        } else if ((*str & 0xe0) == 0xc0) {
            if (*str < 0xc2) return NULL;
            c = (*str++ & 0x1f) << 6;
            if ((*str & 0xc0) != 0x80) return NULL;
            buffer[i++] = cast(zpl_u16)(c + (*str++ & 0x3f));
        } else if ((*str & 0xf0) == 0xe0) {
            if (*str == 0xe0 && (str[1] < 0xa0 || str[1] > 0xbf)) return NULL;
            if (*str == 0xed && str[1] > 0x9f) // str[1] < 0x80 is checked below
                return NULL;
            c = (*str++ & 0x0f) << 12;
            if ((*str & 0xc0) != 0x80) return NULL;
            c += (*str++ & 0x3f) << 6;
            if ((*str & 0xc0) != 0x80) return NULL;
            buffer[i++] = cast(zpl_u16)(c + (*str++ & 0x3f));
        } else if ((*str & 0xf8) == 0xf0) {
            if (*str > 0xf4) return NULL;
            if (*str == 0xf0 && (str[1] < 0x90 || str[1] > 0xbf)) return NULL;
            if (*str == 0xf4 && str[1] > 0x8f) // str[1] < 0x80 is checked below
                return NULL;
            c = (*str++ & 0x07) << 18;
            if ((*str & 0xc0) != 0x80) return NULL;
            c += (*str++ & 0x3f) << 12;
            if ((*str & 0xc0) != 0x80) return NULL;
            c += (*str++ & 0x3f) << 6;
            if ((*str & 0xc0) != 0x80) return NULL;
            c += (*str++ & 0x3f);
            // UTF-8 encodings of values used in surrogate pairs are invalid
            if ((c & 0xfffff800) == 0xd800) return NULL;
            if (c >= 0x10000) {
                c -= 0x10000;
                if (i + 2 > len) return NULL;
                buffer[i++] = 0xd800 | (0x3ff & (c >> 10));
                buffer[i++] = 0xdc00 | (0x3ff & (c));
            }
        } else {
            return NULL;
        }
    }
    buffer[i] = 0;
    return buffer;
}

zpl_u8 *zpl_ucs2_to_utf8(zpl_u8 *buffer, zpl_isize len, zpl_u16 const *str) {
    zpl_isize i = 0;
    len--;
    while (*str) {
        if (*str < 0x80) {
            if (i + 1 > len) return NULL;
            buffer[i++] = (char)*str++;
        } else if (*str < 0x800) {
            if (i + 2 > len) return NULL;
            buffer[i++] = cast(char)(0xc0 + (*str >> 6));
            buffer[i++] = cast(char)(0x80 + (*str & 0x3f));
            str += 1;
        } else if (*str >= 0xd800 && *str < 0xdc00) {
            zpl_rune c;
            if (i + 4 > len) return NULL;
            c = ((str[0] - 0xd800) << 10) + ((str[1]) - 0xdc00) + 0x10000;
            buffer[i++] = cast(char)(0xf0 + (c >> 18));
            buffer[i++] = cast(char)(0x80 + ((c >> 12) & 0x3f));
            buffer[i++] = cast(char)(0x80 + ((c >> 6) & 0x3f));
            buffer[i++] = cast(char)(0x80 + ((c)&0x3f));
            str += 2;
        } else if (*str >= 0xdc00 && *str < 0xe000) {
            return NULL;
        } else {
            if (i + 3 > len) return NULL;
            buffer[i++] = 0xe0 + (*str >> 12);
            buffer[i++] = 0x80 + ((*str >> 6) & 0x3f);
            buffer[i++] = 0x80 + ((*str) & 0x3f);
            str += 1;
        }
    }
    buffer[i] = 0;
    return buffer;
}

zpl_u16 *zpl_utf8_to_ucs2_buf(zpl_u8 const *str) { // NOTE: Uses locally persisting buffer
    zpl_local_persist zpl_u16 buf[4096];
    return zpl_utf8_to_ucs2(buf, zpl_count_of(buf), str);
}

zpl_u8 *zpl_ucs2_to_utf8_buf(zpl_u16 const *str) { // NOTE: Uses locally persisting buffer
    zpl_local_persist zpl_u8 buf[4096];
    return zpl_ucs2_to_utf8(buf, zpl_count_of(buf), str);
}

zpl_global zpl_u8 const zpl__utf8_first[256] = {
    0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x00-0x0F
    0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x10-0x1F
    0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x20-0x2F
    0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x30-0x3F
    0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x40-0x4F
    0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x50-0x5F
    0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x60-0x6F
    0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, // 0x70-0x7F
    0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, // 0x80-0x8F
    0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, // 0x90-0x9F
    0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, // 0xA0-0xAF
    0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, // 0xB0-0xBF
    0xf1, 0xf1, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, // 0xC0-0xCF
    0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, // 0xD0-0xDF
    0x13, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x23, 0x03, 0x03, // 0xE0-0xEF
    0x34, 0x04, 0x04, 0x04, 0x44, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, // 0xF0-0xFF
};


typedef struct zpl_utf8_accept_range {
    zpl_u8 lo, hi;
} zpl_utf8_accept_range;

zpl_global zpl_utf8_accept_range const zpl__utf8_accept_ranges[] = {
    { 0x80, 0xbf }, { 0xa0, 0xbf }, { 0x80, 0x9f }, { 0x90, 0xbf }, { 0x80, 0x8f },
};

zpl_isize zpl_utf8_decode(zpl_u8 const *str, zpl_isize str_len, zpl_rune *codepoint_out) {

    zpl_isize width = 0;
    zpl_rune codepoint = ZPL_RUNE_INVALID;

    if (str_len > 0) {
        zpl_u8 s0 = str[0];
        zpl_u8 x = zpl__utf8_first[s0], sz;
        zpl_u8 b1, b2, b3;
        zpl_utf8_accept_range accept;
        if (x >= 0xf0) {
            zpl_rune mask = (cast(zpl_rune) x << 31) >> 31;
            codepoint = (cast(zpl_rune) s0 & (~mask)) | (ZPL_RUNE_INVALID & mask);
            width = 1;
            goto end;
        }
        if (s0 < 0x80) {
            codepoint = s0;
            width = 1;
            goto end;
        }

        sz = x & 7;
        accept = zpl__utf8_accept_ranges[x >> 4];
        if (str_len < zpl_size_of(sz)) goto invalid_codepoint;

        b1 = str[1];
        if (b1 < accept.lo || accept.hi < b1) goto invalid_codepoint;

        if (sz == 2) {
            codepoint = (cast(zpl_rune) s0 & 0x1f) << 6 | (cast(zpl_rune) b1 & 0x3f);
            width = 2;
            goto end;
        }

        b2 = str[2];
        if (!zpl_is_between(b2, 0x80, 0xbf)) goto invalid_codepoint;

        if (sz == 3) {
            codepoint = (cast(zpl_rune) s0 & 0x1f) << 12 | (cast(zpl_rune) b1 & 0x3f) << 6 | (cast(zpl_rune) b2 & 0x3f);
            width = 3;
            goto end;
        }

        b3 = str[3];
        if (!zpl_is_between(b3, 0x80, 0xbf)) goto invalid_codepoint;

        codepoint = (cast(zpl_rune) s0 & 0x07) << 18 | (cast(zpl_rune) b1 & 0x3f) << 12 | (cast(zpl_rune) b2 & 0x3f) << 6 |
            (cast(zpl_rune) b3 & 0x3f);
        width = 4;
        goto end;

        invalid_codepoint:
        codepoint = ZPL_RUNE_INVALID;
        width = 1;
    }

    end:
    if (codepoint_out) *codepoint_out = codepoint;
    return width;
}

zpl_isize zpl_utf8_codepoint_size(zpl_u8 const *str, zpl_isize str_len) {
    zpl_isize i = 0;
    for (; i < str_len && str[i]; i++) {
        if ((str[i] & 0xc0) != 0x80) break;
    }
    return i + 1;
}

zpl_isize zpl_utf8_encode_rune(zpl_u8 buf[4], zpl_rune r) {
    zpl_u32 i = cast(zpl_u32) r;
    zpl_u8 mask = 0x3f;
    if (i <= (1 << 7) - 1) {
        buf[0] = cast(zpl_u8) r;
        return 1;
    }
    if (i <= (1 << 11) - 1) {
        buf[0] = 0xc0 | cast(zpl_u8)(r >> 6);
        buf[1] = 0x80 | (cast(zpl_u8)(r) & mask);
        return 2;
    }

    // Invalid or Surrogate range
    if (i > ZPL_RUNE_MAX || zpl_is_between(i, 0xd800, 0xdfff)) {
        r = ZPL_RUNE_INVALID;

        buf[0] = 0xe0 | cast(zpl_u8)(r >> 12);
        buf[1] = 0x80 | (cast(zpl_u8)(r >> 6) & mask);
        buf[2] = 0x80 | (cast(zpl_u8)(r) & mask);
        return 3;
    }

    if (i <= (1 << 16) - 1) {
        buf[0] = 0xe0 | cast(zpl_u8)(r >> 12);
        buf[1] = 0x80 | (cast(zpl_u8)(r >> 6) & mask);
        buf[2] = 0x80 | (cast(zpl_u8)(r) & mask);
        return 3;
    }

    buf[0] = 0xf0 | cast(zpl_u8)(r >> 18);
    buf[1] = 0x80 | (cast(zpl_u8)(r >> 12) & mask);
    buf[2] = 0x80 | (cast(zpl_u8)(r >> 6) & mask);
    buf[3] = 0x80 | (cast(zpl_u8)(r) & mask);
    return 4;
}


////////////////////////////////////////////////////////////////
//
// zpl_list
//

zpl_inline void zpl_list_init(zpl_list *list, void const *ptr) {
    zpl_list list_ = { 0 };
    *list = list_;
    list->ptr = ptr;
}

zpl_inline zpl_list *zpl_list_add(zpl_list *list, zpl_list *item) {
    item->next = NULL;

    if (list->next) { item->next = list->next; }

    list->next = item;
    item->prev = list;
    return item;
}

zpl_inline zpl_list *zpl_list_remove(zpl_list *list) {
    if (list->prev) { list->prev->next = list->next; }

    return list->next;
}

////////////////////////////////////////////////////////////////
//
// zpl_array
//
//

zpl_no_inline void *zpl__array_set_capacity(void *array, zpl_isize capacity, zpl_isize element_size) {
    zpl_array_header *h = ZPL_ARRAY_HEADER(array);

    ZPL_ASSERT(element_size > 0);

    if (capacity == h->capacity) return array;

    if (capacity < h->count) {
        if (h->capacity < capacity) {
            zpl_isize new_capacity = ZPL_ARRAY_GROW_FORMULA(h->capacity);
            if (new_capacity < capacity) new_capacity = capacity;
            zpl__array_set_capacity(array, new_capacity, element_size);
        }
        h->count = capacity;
    }

    {
        zpl_isize size = zpl_size_of(zpl_array_header) + element_size * capacity;
        zpl_array_header *nh = cast(zpl_array_header *) zpl_alloc(h->allocator, size);
        zpl_memmove(nh, h, zpl_size_of(zpl_array_header) + element_size * h->count);
        nh->allocator = h->allocator;
        nh->count = h->count;
        nh->data = (char *)nh + 1;
        nh->capacity = capacity;
        zpl_free(h->allocator, h);
        return nh + 1;
    }
}




////////////////////////////////////////////////////////////////
//
// File Handling
//
//

#if defined(ZPL_SYSTEM_WINDOWS)

zpl_internal wchar_t *zpl__alloc_utf8_to_ucs2(zpl_allocator a, char const *text, zpl_isize *w_len_) {
    wchar_t *w_text = NULL;
    zpl_isize len = 0, w_len = 0, w_len1 = 0;
    if (text == NULL) {
        if (w_len_) *w_len_ = w_len;
        return NULL;
    }
    len = zpl_strlen(text);
    if (len == 0) {
        if (w_len_) *w_len_ = w_len;
        return NULL;
    }
    w_len = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, text, cast(int) len, NULL, 0);
    if (w_len == 0) {
        if (w_len_) *w_len_ = w_len;
        return NULL;
    }
    w_text = zpl_alloc_array(a, wchar_t, w_len + 1);
    w_len1 = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, text, cast(int) len, w_text, cast(int) w_len);
    if (w_len1 == 0) {
        zpl_free(a, w_text);
        if (w_len_) *w_len_ = 0;
        return NULL;
    }
    w_text[w_len] = 0;
    if (w_len_) *w_len_ = w_len;
    return w_text;
}

zpl_internal ZPL_FILE_SEEK_PROC(zpl__win32_file_seek) {
    LARGE_INTEGER li_offset;
    li_offset.QuadPart = offset;
    if (!SetFilePointerEx(fd.p, li_offset, &li_offset, whence)) { return false; }

    if (new_offset) *new_offset = li_offset.QuadPart;
    return true;
}

zpl_internal ZPL_FILE_READ_AT_PROC(zpl__win32_file_read) {
    zpl_unused(stop_at_newline);
    zpl_b32 result = false;
    zpl__win32_file_seek(fd, offset, ZPL_SEEK_WHENCE_BEGIN, NULL);
    DWORD size_ = cast(DWORD)(size > ZPL_I32_MAX ? ZPL_I32_MAX : size);
    DWORD bytes_read_;
    if (ReadFile(fd.p, buffer, size_, &bytes_read_, NULL)) {
        if (bytes_read) *bytes_read = bytes_read_;
        result = true;
    }

    return result;
}

zpl_internal ZPL_FILE_WRITE_AT_PROC(zpl__win32_file_write) {
    DWORD size_ = cast(DWORD)(size > ZPL_I32_MAX ? ZPL_I32_MAX : size);
    DWORD bytes_written_;
    zpl__win32_file_seek(fd, offset, ZPL_SEEK_WHENCE_BEGIN, NULL);
    if (WriteFile(fd.p, buffer, size_, &bytes_written_, NULL)) {
        if (bytes_written) *bytes_written = bytes_written_;
        return true;
    }
    return false;
}

zpl_internal ZPL_FILE_CLOSE_PROC(zpl__win32_file_close) { CloseHandle(fd.p); }

zpl_file_operations const zpl_default_file_operations = { zpl__win32_file_read, zpl__win32_file_write,
    zpl__win32_file_seek, zpl__win32_file_close };

zpl_no_inline ZPL_FILE_OPEN_PROC(zpl__win32_file_open) {
    DWORD desired_access;
    DWORD creation_disposition;
    void *handle;
    wchar_t *w_text;

    switch (mode & ZPL_FILE_MODES) {
        case ZPL_FILE_MODE_READ:
            desired_access = GENERIC_READ;
            creation_disposition = OPEN_EXISTING;
            break;
        case ZPL_FILE_MODE_WRITE:
            desired_access = GENERIC_WRITE;
            creation_disposition = CREATE_ALWAYS;
            break;
        case ZPL_FILE_MODE_APPEND:
            desired_access = GENERIC_WRITE;
            creation_disposition = OPEN_ALWAYS;
            break;
        case ZPL_FILE_MODE_READ | ZPL_FILE_MODE_RW:
            desired_access = GENERIC_READ | GENERIC_WRITE;
            creation_disposition = OPEN_EXISTING;
        break;
        case ZPL_FILE_MODE_WRITE | ZPL_FILE_MODE_RW:
            desired_access = GENERIC_READ | GENERIC_WRITE;
            creation_disposition = CREATE_ALWAYS;
            break;
        case ZPL_FILE_MODE_APPEND | ZPL_FILE_MODE_RW:
            desired_access = GENERIC_READ | GENERIC_WRITE;
            creation_disposition = OPEN_ALWAYS;
            break;
        default: ZPL_PANIC("Invalid file mode"); return ZPL_FILE_ERROR_INVALID;
    }

    w_text = zpl__alloc_utf8_to_ucs2(zpl_heap_allocator( ), filename, NULL);
    handle = CreateFileW(w_text, desired_access, FILE_SHARE_READ | FILE_SHARE_DELETE, NULL, creation_disposition,
                         FILE_ATTRIBUTE_NORMAL, NULL);

    zpl_free(zpl_heap_allocator( ), w_text);

    if (handle == INVALID_HANDLE_VALUE) {
        DWORD err = GetLastError( );
        switch (err) {
            case ERROR_FILE_NOT_FOUND: return ZPL_FILE_ERROR_NOT_EXISTS;
            case ERROR_FILE_EXISTS: return ZPL_FILE_ERROR_EXISTS;
            case ERROR_ALREADY_EXISTS: return ZPL_FILE_ERROR_EXISTS;
            case ERROR_ACCESS_DENIED: return ZPL_FILE_ERROR_PERMISSION;
        }
        return ZPL_FILE_ERROR_INVALID;
    }

    if (mode & ZPL_FILE_MODE_APPEND) {
        LARGE_INTEGER offset = { 0 };
        if (!SetFilePointerEx(handle, offset, NULL, ZPL_SEEK_WHENCE_END)) {
            CloseHandle(handle);
            return ZPL_FILE_ERROR_INVALID;
        }
    }

    fd->p = handle;
    *ops = zpl_default_file_operations;
    return ZPL_FILE_ERROR_NONE;
}

#else // POSIX
zpl_internal ZPL_FILE_SEEK_PROC(zpl__posix_file_seek) {
#if defined(ZPL_SYSTEM_OSX)
    zpl_i64 res = lseek(fd.i, offset, whence);
#else // TODO(ZaKlaus): @fixme lseek64
    zpl_i64 res = lseek(fd.i, offset, whence);
#endif
    if (res < 0) return false;
    if (new_offset) *new_offset = res;
    return true;
}

zpl_internal ZPL_FILE_READ_AT_PROC(zpl__posix_file_read) {
    zpl_unused(stop_at_newline);
    zpl_isize res = pread(fd.i, buffer, size, offset);
    if (res < 0) return false;
    if (bytes_read) *bytes_read = res;
    return true;
}

zpl_internal ZPL_FILE_WRITE_AT_PROC(zpl__posix_file_write) {
    zpl_isize res;
    zpl_i64 curr_offset = 0;
    zpl__posix_file_seek(fd, 0, ZPL_SEEK_WHENCE_CURRENT, &curr_offset);
    if (curr_offset == offset) {
        // NOTE: Writing to stdout et al. doesn't like pwrite for numerous reasons
        res = write(cast(int) fd.i, buffer, size);
    } else {
        res = pwrite(cast(int) fd.i, buffer, size, offset);
    }
    if (res < 0) return false;
    if (bytes_written) *bytes_written = res;
    return true;
}

zpl_internal ZPL_FILE_CLOSE_PROC(zpl__posix_file_close) { close(fd.i); }

zpl_file_operations const zpl_default_file_operations = { zpl__posix_file_read, zpl__posix_file_write,
    zpl__posix_file_seek, zpl__posix_file_close };

zpl_no_inline ZPL_FILE_OPEN_PROC(zpl__posix_file_open) {
    zpl_i32 os_mode;
    switch (mode & ZPL_FILE_MODES) {
        case ZPL_FILE_MODE_READ: os_mode = O_RDONLY; break;
        case ZPL_FILE_MODE_WRITE: os_mode = O_WRONLY | O_CREAT | O_TRUNC; break;
        case ZPL_FILE_MODE_APPEND: os_mode = O_WRONLY | O_APPEND | O_CREAT; break;
        case ZPL_FILE_MODE_READ | ZPL_FILE_MODE_RW: os_mode = O_RDWR; break;
        case ZPL_FILE_MODE_WRITE | ZPL_FILE_MODE_RW: os_mode = O_RDWR | O_CREAT | O_TRUNC; break;
        case ZPL_FILE_MODE_APPEND | ZPL_FILE_MODE_RW: os_mode = O_RDWR | O_APPEND | O_CREAT; break;
        default: ZPL_PANIC("Invalid file mode"); return ZPL_FILE_ERROR_INVALID;
    }

    fd->i = open(filename, os_mode, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);
    if (fd->i < 0) {
        // TODO: More file errors
        return ZPL_FILE_ERROR_INVALID;
    }

    *ops = zpl_default_file_operations;
    return ZPL_FILE_ERROR_NONE;
}

#endif

zpl_file_error zpl_file_new(zpl_file *f, zpl_file_descriptor fd, zpl_file_operations ops, char const *filename) {
    zpl_file_error err = ZPL_FILE_ERROR_NONE;
    zpl_isize len = zpl_strlen(filename);

    f->ops = ops;
    f->fd = fd;
    f->filename = zpl_alloc_array(zpl_heap_allocator( ), char, len + 1);
    zpl_memcopy(cast(char *) f->filename, cast(char *) filename, len + 1);
    f->last_write_time = zpl_fs_last_write_time(f->filename);

    return err;
}

zpl_file_error zpl_file_open_mode(zpl_file *f, zpl_file_mode mode, char const *filename) {
    zpl_file file_ = {0};
    *f = file_;
    zpl_file_error err;
#if defined(ZPL_SYSTEM_WINDOWS)
    err = zpl__win32_file_open(&f->fd, &f->ops, mode, filename);
#else
    err = zpl__posix_file_open(&f->fd, &f->ops, mode, filename);
#endif
    if (err == ZPL_FILE_ERROR_NONE) return zpl_file_new(f, f->fd, f->ops, filename);
    return err;
}

zpl_internal void zpl__dirinfo_free_entry(zpl_dir_entry *entry);

zpl_file_error zpl_file_close(zpl_file *f) {
    if (!f) return ZPL_FILE_ERROR_INVALID;

    if (f->filename) zpl_free(zpl_heap_allocator( ), cast(char *) f->filename);

#if defined(ZPL_SYSTEM_WINDOWS)
    if (f->fd.p == INVALID_HANDLE_VALUE) return ZPL_FILE_ERROR_INVALID;
#else
    if (f->fd.i < 0) return ZPL_FILE_ERROR_INVALID;
#endif

    if (!f->ops.read_at) f->ops = zpl_default_file_operations;
    f->ops.close(f->fd);

    if (f->dir) {
        zpl__dirinfo_free_entry(f->dir);
        zpl_mfree(f->dir);
        f->dir = NULL;
    }

    return ZPL_FILE_ERROR_NONE;
}

zpl_inline zpl_b32 zpl_file_read_at_check(zpl_file *f, void *buffer, zpl_isize size, zpl_i64 offset, zpl_isize *bytes_read) {
    if (!f->ops.read_at) f->ops = zpl_default_file_operations;
    return f->ops.read_at(f->fd, buffer, size, offset, bytes_read, false);
}

zpl_inline zpl_b32 zpl_file_write_at_check(zpl_file *f, void const *buffer, zpl_isize size, zpl_i64 offset, zpl_isize *bytes_written) {
    if (!f->ops.read_at) f->ops = zpl_default_file_operations;
    return f->ops.write_at(f->fd, buffer, size, offset, bytes_written);
}

zpl_inline zpl_b32 zpl_file_read_at(zpl_file *f, void *buffer, zpl_isize size, zpl_i64 offset) {
    return zpl_file_read_at_check(f, buffer, size, offset, NULL);
}

zpl_inline zpl_b32 zpl_file_write_at(zpl_file *f, void const *buffer, zpl_isize size, zpl_i64 offset) {
    return zpl_file_write_at_check(f, buffer, size, offset, NULL);
}

zpl_inline zpl_i64 zpl_file_seek(zpl_file *f, zpl_i64 offset) {
    zpl_i64 new_offset = 0;
    if (!f->ops.read_at) f->ops = zpl_default_file_operations;
    f->ops.seek(f->fd, offset, ZPL_SEEK_WHENCE_BEGIN, &new_offset);
    return new_offset;
}

zpl_inline zpl_i64 zpl_file_seek_to_end(zpl_file *f) {
    zpl_i64 new_offset = 0;
    if (!f->ops.read_at) f->ops = zpl_default_file_operations;
    f->ops.seek(f->fd, 0, ZPL_SEEK_WHENCE_END, &new_offset);
    return new_offset;
}

// NOTE: Skips a certain amount of bytes
zpl_inline zpl_i64 zpl_file_skip(zpl_file *f, zpl_i64 bytes) {
    zpl_i64 new_offset = 0;
    if (!f->ops.read_at) f->ops = zpl_default_file_operations;
    f->ops.seek(f->fd, bytes, ZPL_SEEK_WHENCE_CURRENT, &new_offset);
    return new_offset;
}

zpl_inline zpl_i64 zpl_file_tell(zpl_file *f) {
    zpl_i64 new_offset = 0;
    if (!f->ops.read_at) f->ops = zpl_default_file_operations;
    f->ops.seek(f->fd, 0, ZPL_SEEK_WHENCE_CURRENT, &new_offset);
    return new_offset;
}

zpl_inline zpl_b32 zpl_file_read(zpl_file *f, void *buffer, zpl_isize size) {
    zpl_i64 cur_offset = zpl_file_tell(f);
    zpl_b32 result = zpl_file_read_at(f, buffer, size, zpl_file_tell(f));
    zpl_file_seek(f, cur_offset + size);
    return result;
}

zpl_inline zpl_b32 zpl_file_write(zpl_file *f, void const *buffer, zpl_isize size) {
    zpl_i64 cur_offset = zpl_file_tell(f);
    zpl_b32 result = zpl_file_write_at(f, buffer, size, zpl_file_tell(f));
    zpl_file_seek(f, cur_offset + size);
    return result;
}

zpl_file_error zpl_file_create(zpl_file *f, char const *filename) {
    return zpl_file_open_mode(f, ZPL_FILE_MODE_WRITE | ZPL_FILE_MODE_RW, filename);
}

zpl_file_error zpl_file_open(zpl_file *f, char const *filename) {
    return zpl_file_open_mode(f, ZPL_FILE_MODE_READ, filename);
}

char const *zpl_file_name(zpl_file *f) { return f->filename ? f->filename : ""; }

zpl_inline zpl_b32 zpl_file_has_changed(zpl_file *f) {
    zpl_b32 result = false;
    zpl_file_time last_write_time = zpl_fs_last_write_time(f->filename);
    if (f->last_write_time != last_write_time) {
        result = true;
        f->last_write_time = last_write_time;
    }
    return result;
}

// TODO: Is this a bad idea?
zpl_global zpl_b32 zpl__std_file_set = false;
zpl_global zpl_file zpl__std_files[ZPL_FILE_STANDARD_COUNT] = { { 0 } };

#if defined(ZPL_SYSTEM_WINDOWS)

zpl_inline zpl_file *zpl_file_get_standard(zpl_file_standard_type std) {
    if (!zpl__std_file_set) {
#define ZPL__SET_STD_FILE(type, v)                                                                                     \
        zpl__std_files[type].fd.p = v;                                                                                     \
        zpl__std_files[type].ops = zpl_default_file_operations
        ZPL__SET_STD_FILE(ZPL_FILE_STANDARD_INPUT, GetStdHandle(STD_INPUT_HANDLE));
        ZPL__SET_STD_FILE(ZPL_FILE_STANDARD_OUTPUT, GetStdHandle(STD_OUTPUT_HANDLE));
        ZPL__SET_STD_FILE(ZPL_FILE_STANDARD_ERROR, GetStdHandle(STD_ERROR_HANDLE));
#undef ZPL__SET_STD_FILE
        zpl__std_file_set = true;
    }
    return &zpl__std_files[std];
}

zpl_inline void zpl_file_connect_handle(zpl_file *file, void *handle) {
    ZPL_ASSERT_NOT_NULL(file);
    ZPL_ASSERT_NOT_NULL(handle);

    zpl_zero_item(file);

    file->fd.p = handle;
    file->ops = zpl_default_file_operations;
}


zpl_inline zpl_i64 zpl_file_size(zpl_file *f) {
    LARGE_INTEGER size;
    GetFileSizeEx(f->fd.p, &size);
    return size.QuadPart;
}

zpl_file_error zpl_file_truncate(zpl_file *f, zpl_i64 size) {
    zpl_file_error err = ZPL_FILE_ERROR_NONE;
    zpl_i64 prev_offset = zpl_file_tell(f);
    zpl_file_seek(f, size);
    if (!SetEndOfFile(f)) err = ZPL_FILE_ERROR_TRUNCATION_FAILURE;
    zpl_file_seek(f, prev_offset);
    return err;
}

zpl_b32 zpl_fs_exists(char const *name) {
    WIN32_FIND_DATAW data;
    wchar_t *w_text;
    void *handle;
    zpl_b32 found = false;
    zpl_allocator a = zpl_heap_allocator( );

    w_text = zpl__alloc_utf8_to_ucs2(a, name, NULL);
    if (w_text == NULL) { return false; }
    handle = FindFirstFileW(w_text, &data);
    zpl_free(a, w_text);
    found = handle != INVALID_HANDLE_VALUE;
    if (found) FindClose(handle);
    return found;
}

#else // POSIX

zpl_inline zpl_file *zpl_file_get_standard(zpl_file_standard_type std) {
    if (!zpl__std_file_set) {
#define ZPL__SET_STD_FILE(type, v)                                                                                     \
        zpl__std_files[type].fd.i = v;                                                                                     \
        zpl__std_files[type].ops = zpl_default_file_operations
        ZPL__SET_STD_FILE(ZPL_FILE_STANDARD_INPUT, 0);
        ZPL__SET_STD_FILE(ZPL_FILE_STANDARD_OUTPUT, 1);
        ZPL__SET_STD_FILE(ZPL_FILE_STANDARD_ERROR, 2);
#undef ZPL__SET_STD_FILE
        zpl__std_file_set = true;
    }
    return &zpl__std_files[std];
}

zpl_inline zpl_i64 zpl_file_size(zpl_file *f) {
    zpl_i64 size = 0;
    zpl_i64 prev_offset = zpl_file_tell(f);
    zpl_file_seek_to_end(f);
    size = zpl_file_tell(f);
    zpl_file_seek(f, prev_offset);
    return size;
}

zpl_inline zpl_file_error zpl_file_truncate(zpl_file *f, zpl_i64 size) {
    zpl_file_error err = ZPL_FILE_ERROR_NONE;
    int i = ftruncate(f->fd.i, size);
    if (i != 0) err = ZPL_FILE_ERROR_TRUNCATION_FAILURE;
    return err;
}

zpl_inline zpl_b32 zpl_fs_exists(char const *name) { return access(name, F_OK) != -1; }

#endif

zpl_file_error zpl_file_temp(zpl_file *file) {
#if defined(ZPL_SYSTEM_EMSCRIPTEN)
    ZPL_PANIC("zpl_file_temp is not supported for emscripten");
#else
    zpl_zero_item(file);
    FILE *fd = NULL;

#if ZPL_SYSTEM_WINDOWS && !defined(ZPL_COMPILER_GCC)
    errno_t errcode = tmpfile_s(&fd);

    if (errcode != 0) {
        fd = NULL;
    }
#else
    fd = tmpfile();
#endif

    if (fd == NULL) { return ZPL_FILE_ERROR_INVALID; }

    file->fd.p = fd;
    file->ops = zpl_default_file_operations;
#endif
    return ZPL_FILE_ERROR_NONE;
}

#if defined(ZPL_SYSTEM_WINDOWS)
zpl_file_time zpl_fs_last_write_time(char const *filepath) {
    ULARGE_INTEGER li = { 0 };
    FILETIME last_write_time = { 0 };
    WIN32_FILE_ATTRIBUTE_DATA data = { 0 };
    zpl_allocator a = zpl_heap_allocator( );

    wchar_t *w_text = zpl__alloc_utf8_to_ucs2(a, filepath, NULL);
    if (w_text == NULL) { return 0; }
    if (GetFileAttributesExW(w_text, GetFileExInfoStandard, &data)) last_write_time = data.ftLastWriteTime;

    zpl_free(a, w_text);

    li.LowPart = last_write_time.dwLowDateTime;
    li.HighPart = last_write_time.dwHighDateTime;
    return cast(zpl_file_time) li.QuadPart;
}

zpl_inline zpl_b32 zpl_fs_copy(char const *existing_filename, char const *new_filename, zpl_b32 fail_if_exists) {
    zpl_b32 result = false;
    zpl_allocator a = zpl_heap_allocator( );

    wchar_t *w_old = zpl__alloc_utf8_to_ucs2(a, existing_filename, NULL);
    if (w_old == NULL) { return false; }

    wchar_t *w_new = zpl__alloc_utf8_to_ucs2(a, new_filename, NULL);
    if (w_new != NULL) { result = CopyFileW(w_old, w_new, fail_if_exists); }

    zpl_free(a, w_old);
    zpl_free(a, w_new);
    return result;
}

zpl_inline zpl_b32 zpl_fs_move(char const *existing_filename, char const *new_filename) {
    zpl_b32 result = false;
    zpl_allocator a = zpl_heap_allocator( );

    wchar_t *w_old = zpl__alloc_utf8_to_ucs2(a, existing_filename, NULL);
    if (w_old == NULL) { return false; }

    wchar_t *w_new = zpl__alloc_utf8_to_ucs2(a, new_filename, NULL);
    if (w_new != NULL) { result = MoveFileW(w_old, w_new); }

    zpl_free(a, w_old);
    zpl_free(a, w_new);
    return result;
}

zpl_inline zpl_b32 zpl_fs_remove(char const *filename) {
    zpl_b32 result = false;
    zpl_allocator a = zpl_heap_allocator( );

    wchar_t *w_filename = zpl__alloc_utf8_to_ucs2(a, filename, NULL);
    if (w_filename == NULL) { return false; }

    result = DeleteFileW(w_filename);

    zpl_free(a, w_filename);
    return result;
}

#else

zpl_file_time zpl_fs_last_write_time(char const *filepath) {
    time_t result = 0;
    struct stat file_stat;

    if (stat(filepath, &file_stat)) result = file_stat.st_mtime;

    return cast(zpl_file_time) result;
}

zpl_inline zpl_b32 zpl_fs_copy(char const *existing_filename, char const *new_filename, zpl_b32 fail_if_exists) {
    zpl_unused(fail_if_exists);
#if defined(ZPL_SYSTEM_OSX)
    return copyfile(existing_filename, new_filename, NULL, COPYFILE_DATA) == 0;
#else
    zpl_isize size;
    int existing_fd = open(existing_filename, O_RDONLY, 0);
    int new_fd = open(new_filename, O_WRONLY | O_CREAT, 0666);

    struct stat stat_existing;
    fstat(existing_fd, &stat_existing);

    size = sendfile(new_fd, existing_fd, 0, stat_existing.st_size);

    close(new_fd);
    close(existing_fd);

    return size == stat_existing.st_size;
#endif
}

zpl_inline zpl_b32 zpl_fs_move(char const *existing_filename, char const *new_filename) {
    if (link(existing_filename, new_filename) == 0) { return (unlink(existing_filename) != -1); }
    return false;
}

zpl_inline zpl_b32 zpl_fs_remove(char const *filename) {
#if defined(ZPL_SYSTEM_OSX) || defined(ZPL_SYSTEM_EMSCRIPTEN)
    return (unlink(filename) != -1);
#else
    return (remove(filename) == 0);
#endif
}

#endif

zpl_file_contents zpl_file_read_contents(zpl_allocator a, zpl_b32 zero_terminate, char const *filepath) {
    zpl_file_contents result = { 0 };
    zpl_file file = { 0 };

    result.allocator = a;

    if (zpl_file_open(&file, filepath) == ZPL_FILE_ERROR_NONE) {
        zpl_isize file_size = cast(zpl_isize) zpl_file_size(&file);
        if (file_size > 0) {
            result.data = zpl_alloc(a, zero_terminate ? file_size + 1 : file_size);
            result.size = file_size;
            zpl_file_read_at(&file, result.data, result.size, 0);
            if (zero_terminate) {
                zpl_u8 *str = cast(zpl_u8 *) result.data;
                str[file_size] = '\0';
            }
        }
        zpl_file_close(&file);
    }

    return result;
}

char *zpl_file_read_lines(zpl_allocator alloc, char ***lines, char const *filename, zpl_b32 strip_whitespace) {
    zpl_file f = { 0 };
    zpl_file_open(&f, filename);
    zpl_isize fsize = (zpl_isize)zpl_file_size(&f);

    char *contents = (char *)zpl_alloc(alloc, fsize + 1);
    zpl_file_read(&f, contents, fsize);
    contents[fsize] = 0;
    *lines = zpl_str_split_lines(alloc, contents, strip_whitespace);
    zpl_file_close(&f);

    return contents;
}

void zpl_file_free_contents(zpl_file_contents *fc) {
    ZPL_ASSERT_NOT_NULL(fc->data);
    zpl_free(fc->allocator, fc->data);
    fc->data = NULL;
    fc->size = 0;
}

zpl_inline zpl_b32 zpl_path_is_absolute(char const *path) {
    zpl_b32 result = false;
    ZPL_ASSERT_NOT_NULL(path);
#if defined(ZPL_SYSTEM_WINDOWS)
    result = (zpl_strlen(path) > 2) && zpl_char_is_alpha(path[0]) && (path[1] == ':' && path[2] == ZPL_PATH_SEPARATOR);
#else
    result = (zpl_strlen(path) > 0 && path[0] == ZPL_PATH_SEPARATOR);
#endif
    return result;
}

zpl_inline zpl_b32 zpl_path_is_relative(char const *path) { return !zpl_path_is_absolute(path); }

zpl_inline zpl_b32 zpl_path_is_root(char const *path) {
    zpl_b32 result = false;
    ZPL_ASSERT_NOT_NULL(path);
#if defined(ZPL_SYSTEM_WINDOWS)
    result = zpl_path_is_absolute(path) && (zpl_strlen(path) == 3);
#else
    result = zpl_path_is_absolute(path) && (zpl_strlen(path) == 1);
#endif
    return result;
}

zpl_inline char const *zpl_path_base_name(char const *path) {
    char const *ls;
    ZPL_ASSERT_NOT_NULL(path);
    zpl_path_fix_slashes((char *)path);
    ls = zpl_char_last_occurence(path, ZPL_PATH_SEPARATOR);
    return (ls == NULL) ? path : ls + 1;
}

zpl_inline char const *zpl_path_extension(char const *path) {
    char const *ld;
    ZPL_ASSERT_NOT_NULL(path);
    ld = zpl_char_last_occurence(path, '.');
    return (ld == NULL) ? NULL : ld + 1;
}

#if !defined(_WINDOWS_) && defined(ZPL_SYSTEM_WINDOWS)
ZPL_DLL_IMPORT DWORD WINAPI GetFullPathNameA(char const *lpFileName, DWORD nBufferLength, char *lpBuffer,
                                             char **lpFilePart);
ZPL_DLL_IMPORT DWORD WINAPI GetFullPathNameW(wchar_t const *lpFileName, DWORD nBufferLength, wchar_t *lpBuffer,
                                             wchar_t **lpFilePart);
#endif

char *zpl_path_get_full_name(zpl_allocator a, char const *path) {
#if defined(ZPL_SYSTEM_WINDOWS)
    wchar_t *w_path = NULL;
    wchar_t *w_fullpath = NULL;
    zpl_isize w_len = 0;
    zpl_isize new_len = 0;
    zpl_isize new_len1 = 0;
    char *new_path = 0;

    w_path = zpl__alloc_utf8_to_ucs2(zpl_heap_allocator( ), path, NULL);
    if (w_path == NULL) { return NULL; }

    w_len = GetFullPathNameW(w_path, 0, NULL, NULL);
    if (w_len == 0) { return NULL; }

    w_fullpath = zpl_alloc_array(zpl_heap_allocator( ), wchar_t, w_len + 1);
    GetFullPathNameW(w_path, cast(int) w_len, w_fullpath, NULL);
    w_fullpath[w_len] = 0;

    zpl_free(zpl_heap_allocator( ), w_path);

    new_len = WideCharToMultiByte(CP_UTF8, WC_ERR_INVALID_CHARS, w_fullpath, cast(int) w_len, NULL, 0, NULL, NULL);

    if (new_len == 0) {
        zpl_free(zpl_heap_allocator( ), w_fullpath);
        return NULL;
    }

    new_path = zpl_alloc_array(a, char, new_len1);
    new_len1 = WideCharToMultiByte(CP_UTF8, WC_ERR_INVALID_CHARS, w_fullpath, cast(int) w_len, new_path,
                                   cast(int) new_len, NULL, NULL);

    if (new_len1 == 0) {
        zpl_free(zpl_heap_allocator( ), w_fullpath);
        zpl_free(a, new_path);
        return NULL;
    }

    new_path[new_len] = 0;
    return new_path;
#else
    char *p, *result, *fullpath = NULL;
    zpl_isize len;
    p = realpath(path, NULL);
    fullpath = p;
    if (p == NULL) {
        // NOTE(bill): File does not exist
        fullpath = cast(char *) path;
    }

    len = zpl_strlen(fullpath);

    result = zpl_alloc_array(a, char, len + 1);
    zpl_memmove(result, fullpath, len);
    result[len] = 0;
    zpl_free(a, p);

    return result;
#endif
}

zpl_file_error zpl_path_mkdir(char const *path, zpl_i32 mode) {
    zpl_i32 error = 0;
#if defined(ZPL_SYSTEM_WINDOWS)
    error = _wmkdir((const wchar_t *)zpl_utf8_to_ucs2_buf((const zpl_u8 *)path));
#else
    error = mkdir(path, (mode_t)mode);
#endif

    if (error == 0) { return ZPL_FILE_ERROR_NONE; }

    switch (errno) {
        case EPERM:
        case EACCES: return ZPL_FILE_ERROR_PERMISSION;
        case EEXIST: return ZPL_FILE_ERROR_EXISTS;
        case ENAMETOOLONG: return ZPL_FILE_ERROR_NAME_TOO_LONG;
    }

    return ZPL_FILE_ERROR_UNKNOWN;
}

zpl_file_error zpl_path_rmdir(char const *path) {
    zpl_i32 error = 0;
#if defined(ZPL_SYSTEM_WINDOWS)
    error = _wrmdir((const wchar_t *)zpl_utf8_to_ucs2_buf((const zpl_u8 *)path));
#else
    error = rmdir(path);
#endif

    if (error == 0) { return ZPL_FILE_ERROR_NONE; }

    switch (errno) {
        case EPERM:
        case EACCES: return ZPL_FILE_ERROR_PERMISSION;
        case ENOENT: return ZPL_FILE_ERROR_NOT_EXISTS;
        case ENOTEMPTY: return ZPL_FILE_ERROR_NOT_EMPTY;
        case ENAMETOOLONG: return ZPL_FILE_ERROR_NAME_TOO_LONG;
    }

    return ZPL_FILE_ERROR_UNKNOWN;
}

void zpl__file_direntry(zpl_allocator alloc, char const *dirname, zpl_string *output, zpl_b32 recurse) {
#if defined(ZPL_SYSTEM_UNIX) || defined(ZPL_SYSTEM_OSX)
    DIR *d, *cd;
    struct dirent *dir;
    d = opendir(dirname);

    if (d) {
        while ((dir = readdir(d))) {
            if (!zpl_strncmp(dir->d_name, "..", 2)) continue;
            if (dir->d_name[0] == '.' && dir->d_name[1] == 0) continue;

            zpl_string dirpath = zpl_string_make(alloc, dirname);
            dirpath = zpl_string_appendc(dirpath, "/");
            dirpath = zpl_string_appendc(dirpath, dir->d_name);

            *output = zpl_string_appendc(*output, dirpath);
            *output = zpl_string_appendc(*output, "\n");

            if (recurse && (cd = opendir(dirpath)) != NULL) { zpl__file_direntry(alloc, dirpath, output, recurse); }
            zpl_string_free(dirpath);
        }
    }
#elif defined(ZPL_SYSTEM_WINDOWS)
    zpl_usize length = zpl_strlen(dirname);
    struct _wfinddata_t data;
    zpl_intptr findhandle;

    char directory[MAX_PATH] = { 0 };
    zpl_strncpy(directory, dirname, length);

    // keeping it native
    for (zpl_usize i = 0; i < length; i++) {
        if (directory[i] == '/') directory[i] = '\\';
    }

    // remove trailing slashses
    if (directory[length - 1] == '\\') { directory[length - 1] = '\0'; }

    // attach search parttern
    zpl_string findpath = zpl_string_make(alloc, directory);
    findpath = zpl_string_appendc(findpath, "\\");
    findpath = zpl_string_appendc(findpath, "*");

    findhandle = _wfindfirst((const wchar_t *)zpl_utf8_to_ucs2_buf((const zpl_u8 *)findpath), &data);
    zpl_string_free(findpath);

    if (findhandle != -1) {
        do {
            char *filename = (char *)zpl_ucs2_to_utf8_buf((const zpl_u16 *)data.name);
            if (!zpl_strncmp(filename, "..", 2)) continue;
            if (filename[0] == '.' && filename[1] == 0) continue;

            zpl_string dirpath = zpl_string_make(alloc, directory);
            dirpath = zpl_string_appendc(dirpath, "\\");
            dirpath = zpl_string_appendc(dirpath, filename);

            *output = zpl_string_appendc(*output, dirpath);
            *output = zpl_string_appendc(*output, "\n");

            if (recurse && (data.attrib & _A_SUBDIR)) { zpl__file_direntry(alloc, dirpath, output, recurse); }

            zpl_string_free(dirpath);
        } while (_wfindnext(findhandle, &data) != -1);
        _findclose(findhandle);
    }
#else
    // TODO: Implement other OSes
#endif
}

zpl_string zpl_path_dirlist(zpl_allocator alloc, char const *dirname, zpl_b32 recurse) {
    zpl_string buf = zpl_string_make_reserve(alloc, 4);
    zpl__file_direntry(alloc, dirname, &buf, recurse);
    return buf;
}

void zpl_dirinfo_init(zpl_dir_info *dir, char const *path) {
    ZPL_ASSERT_NOT_NULL(dir);

    zpl_dir_info dir_ = {0};
    *dir = dir_;
    dir->fullpath = (char const*)zpl_malloc(zpl_strlen(path));
    zpl_strcpy((char *)dir->fullpath, path);


    zpl_string dirlist = zpl_path_dirlist(zpl_heap(), path, false);
    char **files=zpl_str_split_lines(zpl_heap(), dirlist, false);
    dir->filenames = files;
    dir->buf = dirlist;

    zpl_array_init(dir->entries, zpl_heap());

    for (zpl_i32 i=0; i<zpl_array_count(files); ++i) {
        zpl_dir_entry entry = {0};
        entry.filename = files[i];
        entry.type = zpl_fs_get_type(entry.filename);

        zpl_array_append(dir->entries, entry);
    }
}

zpl_internal void zpl__dirinfo_free_entry(zpl_dir_entry *entry) {
    if (entry->dir_info) {
        zpl_dirinfo_free(entry->dir_info);
        zpl_mfree(entry->dir_info);
        entry->dir_info = NULL;
    }
}

void zpl_dirinfo_free(zpl_dir_info *dir) {
    ZPL_ASSERT_NOT_NULL(dir);

    for (zpl_isize i = 0; i < zpl_array_count(dir->entries); ++i) {
        zpl__dirinfo_free_entry(dir->entries + i);
    }

    zpl_array_free(dir->entries);
    zpl_array_free(dir->filenames);
    zpl_string_free(dir->buf);
    zpl_mfree((void *)dir->fullpath);
}


zpl_u8 zpl_fs_get_type(char const *path) {
#ifdef ZPL_SYSTEM_WINDOWS
    DWORD attrs = GetFileAttributesW((const wchar_t *)zpl_utf8_to_ucs2_buf((const zpl_u8 *)path));

    if (attrs == INVALID_FILE_ATTRIBUTES) {
        return ZPL_DIR_TYPE_UNKNOWN;
    }

    if (attrs & FILE_ATTRIBUTE_DIRECTORY) {
        return ZPL_DIR_TYPE_FOLDER;
    }
    else {
        return ZPL_DIR_TYPE_FILE;
    }

#else
    struct stat s;
    if( stat(path,&s) == 0 )
    {
        if( s.st_mode & S_IFDIR )
        {
            return ZPL_DIR_TYPE_FOLDER;
        }
        else
        {
            return ZPL_DIR_TYPE_FILE;
        }
    }
#endif

    return ZPL_DIR_TYPE_UNKNOWN;
}

void zpl_dirinfo_step(zpl_dir_entry *entry) {
    if (entry->dir_info) {
        zpl__dirinfo_free_entry(entry);
    }

    entry->dir_info = (zpl_dir_info *)zpl_malloc(sizeof(zpl_dir_info));
    zpl_dir_info dir_ = {0};
    *entry->dir_info = dir_;

    zpl_local_persist char buf[128] = {0};
    char const *path = entry->filename;

    if (entry->type != ZPL_DIR_TYPE_FOLDER) {
        zpl_path_fix_slashes((char *)path);
        char const* slash = zpl_char_last_occurence(path, ZPL_PATH_SEPARATOR);
        zpl_strncpy(buf, path, slash-path);
        path = buf;
    }

    zpl_dirinfo_init(entry->dir_info, path);
}

void zpl_file_dirinfo_refresh(zpl_file *file) {
    if (file->dir) {
        zpl__dirinfo_free_entry(file->dir);
        zpl_mfree(file->dir);
        file->dir = NULL;
    }

    file->dir = (zpl_dir_entry *)zpl_malloc(sizeof(zpl_dir_entry));
    zpl_dir_entry dir_ = {0};
    *file->dir = dir_;
    file->dir->filename = file->filename;
    file->dir->type = ZPL_DIR_TYPE_FILE;

    zpl_dirinfo_step(file->dir);
}

void zpl_path_fix_slashes(char *path) {
#ifdef ZPL_SYSTEM_WINDOWS
    char *p = path;

    while (*p != '\0') {
        if (*p == '/')
            *p = '\\';

        ++p;
    }
#endif
}


////////////////////////////////////////////////////////////////
//
// Printing
//
//

zpl_isize zpl_printf(char const *fmt, ...) {
    zpl_isize res;
    va_list va;
    va_start(va, fmt);
    res = zpl_printf_va(fmt, va);
    va_end(va);
    return res;
}

zpl_isize zpl_printf_err(char const *fmt, ...) {
    zpl_isize res;
    va_list va;
    va_start(va, fmt);
    res = zpl_printf_err_va(fmt, va);
    va_end(va);
    return res;
}

zpl_isize zpl_fprintf(struct zpl_file *f, char const *fmt, ...) {
    zpl_isize res;
    va_list va;
    va_start(va, fmt);
    res = zpl_fprintf_va(f, fmt, va);
    va_end(va);
    return res;
}

char *zpl_bprintf(char const *fmt, ...) {
    va_list va;
    char *str;
    va_start(va, fmt);
    str = zpl_bprintf_va(fmt, va);
    va_end(va);
    return str;
}

zpl_isize zpl_snprintf(char *str, zpl_isize n, char const *fmt, ...) {
    zpl_isize res;
    va_list va;
    va_start(va, fmt);
    res = zpl_snprintf_va(str, n, fmt, va);
    va_end(va);
    return res;
}

zpl_inline zpl_isize zpl_printf_va(char const *fmt, va_list va) {
    return zpl_fprintf_va(zpl_file_get_standard(ZPL_FILE_STANDARD_OUTPUT), fmt, va);
}

zpl_inline zpl_isize zpl_printf_err_va(char const *fmt, va_list va) {
    return zpl_fprintf_va(zpl_file_get_standard(ZPL_FILE_STANDARD_ERROR), fmt, va);
}

zpl_inline zpl_isize zpl_fprintf_va(struct zpl_file *f, char const *fmt, va_list va) {
    zpl_local_persist char buf[4096];
    zpl_isize len = zpl_snprintf_va(buf, zpl_size_of(buf), fmt, va);
    zpl_file_write(f, buf, len - 1); // NOTE: prevent extra whitespace
    return len;
}

zpl_inline char *zpl_bprintf_va(char const *fmt, va_list va) {
    zpl_local_persist char buffer[4096];
    zpl_snprintf_va(buffer, zpl_size_of(buffer), fmt, va);
    return buffer;
}

enum {
    ZPL_FMT_MINUS = ZPL_BIT(0),
    ZPL_FMT_PLUS  = ZPL_BIT(1),
    ZPL_FMT_ALT   = ZPL_BIT(2),
    ZPL_FMT_SPACE = ZPL_BIT(3),
    ZPL_FMT_ZERO  = ZPL_BIT(4),

    ZPL_FMT_CHAR   = ZPL_BIT(5),
    ZPL_FMT_SHORT  = ZPL_BIT(6),
    ZPL_FMT_INT    = ZPL_BIT(7),
    ZPL_FMT_LONG   = ZPL_BIT(8),
    ZPL_FMT_LLONG  = ZPL_BIT(9),
    ZPL_FMT_SIZE   = ZPL_BIT(10),
    ZPL_FMT_INTPTR = ZPL_BIT(11),

    ZPL_FMT_UNSIGNED = ZPL_BIT(12),
    ZPL_FMT_LOWER    = ZPL_BIT(13),
    ZPL_FMT_UPPER    = ZPL_BIT(14),

    ZPL_FMT_DONE = ZPL_BIT(30),

    ZPL_FMT_INTS =
        ZPL_FMT_CHAR | ZPL_FMT_SHORT | ZPL_FMT_INT  |
        ZPL_FMT_LONG | ZPL_FMT_LLONG | ZPL_FMT_SIZE | ZPL_FMT_INTPTR
};

typedef struct {
    zpl_i32 base;
    zpl_i32 flags;
    zpl_i32 width;
    zpl_i32 precision;
} zpl__format_info;

zpl_internal zpl_isize zpl__print_string(char *text, zpl_isize max_len, zpl__format_info *info, char const *str) {
    // TODO: Get precision and width to work correctly. How does it actually work?!
    // TODO: This looks very buggy indeed.
    zpl_isize res = 0, len;
    zpl_isize remaining = max_len;

    if (str == NULL && max_len >= 4) {
        res += zpl_strlcpy(text, "(null)", 6);
        return 6;
    }

    if (info && info->precision >= 0)
        len = zpl_strnlen(str, info->precision);
    else
        len = zpl_strlen(str);

    if (info && (info->width == 0 || info->flags & ZPL_FMT_MINUS)) {
        if (info->precision > 0) len = info->precision < len ? info->precision : len;

        res += zpl_strlcpy(text, str, len);

        if (info->width > res) {
            zpl_isize padding = info->width - len;
            char pad = (info->flags & ZPL_FMT_ZERO) ? '0' : ' ';
            while (padding-- > 0 && remaining-- > 0) *text++ = pad, res++;
        }
    } else {
        if (info && (info->width > res)) {
            zpl_isize padding = info->width - len;
            char pad = (info->flags & ZPL_FMT_ZERO) ? '0' : ' ';
            while (padding-- > 0 && remaining-- > 0) *text++ = pad, res++;
        }

        res += zpl_strlcpy(text, str, len);
    }

    if (info) {
        if (info->flags & ZPL_FMT_UPPER)
            zpl_str_to_upper(text);
        else if (info->flags & ZPL_FMT_LOWER)
            zpl_str_to_lower(text);
    }

    return res;
}

zpl_internal zpl_isize zpl__print_char(char *text, zpl_isize max_len, zpl__format_info *info, char arg) {
    char str[2] = "";
    str[0] = arg;
    return zpl__print_string(text, max_len, info, str);
}

zpl_internal zpl_isize zpl__print_i64(char *text, zpl_isize max_len, zpl__format_info *info, zpl_i64 value) {
    char num[130];
    zpl_i64_to_str(value, num, info ? info->base : 10);
    return zpl__print_string(text, max_len, info, num);
}

zpl_internal zpl_isize zpl__print_u64(char *text, zpl_isize max_len, zpl__format_info *info, zpl_u64 value) {
    char num[130];
    zpl_u64_to_str(value, num, info ? info->base : 10);
    return zpl__print_string(text, max_len, info, num);
}

zpl_internal zpl_isize zpl__print_f64(char *text, zpl_isize max_len, zpl__format_info *info, zpl_f64 arg) {
    // TODO: Handle exponent notation
    zpl_isize width, len, remaining = max_len;
    char *text_begin = text;

    if (arg) {
        zpl_u64 value;
        if (arg < 0) {
            if (remaining > 1) *text = '-', remaining--;
            text++;
            arg = -arg;
        } else if (info->flags & ZPL_FMT_MINUS) {
            if (remaining > 1) *text = '+', remaining--;
            text++;
        }

        value = cast(zpl_u64) arg;
        len = zpl__print_u64(text, remaining, NULL, value);
        text += len;

        if (len >= remaining)
            remaining = zpl_min(remaining, 1);
        else
            remaining -= len;
        arg -= value;

        if (info->precision < 0) info->precision = 6;

        if ((info->flags & ZPL_FMT_ALT) || info->precision > 0) {
            zpl_i64 mult = 10;
            if (remaining > 1) *text = '.', remaining--;
            text++;
            while (info->precision-- > 0) {
                value = cast(zpl_u64)(arg * mult);
                len = zpl__print_u64(text, remaining, NULL, value);
                text += len;
                if (len >= remaining)
                    remaining = zpl_min(remaining, 1);
                else
                    remaining -= len;
                arg -= cast(zpl_f64) value / mult;
                mult *= 10;
            }
        }
    } else {
        if (remaining > 1) *text = '0', remaining--;
        text++;
        if (info->flags & ZPL_FMT_ALT) {
            if (remaining > 1) *text = '.', remaining--;
            text++;
        }
    }

    width = info->width - (text - text_begin);
    if (width > 0) {
        char fill = (info->flags & ZPL_FMT_ZERO) ? '0' : ' ';
        char *end = text + remaining - 1;
        len = (text - text_begin);

        for (len = (text - text_begin); len--;) {
            if ((text_begin + len + width) < end) *(text_begin + len + width) = *(text_begin + len);
        }

        len = width;
        text += len;
        if (len >= remaining)
            remaining = zpl_min(remaining, 1);
        else
            remaining -= len;

        while (len--) {
            if (text_begin + len < end) text_begin[len] = fill;
        }
    }

    return (text - text_begin);
}

zpl_no_inline zpl_isize zpl_snprintf_va(char *text, zpl_isize max_len, char const *fmt, va_list va) {
    char const *text_begin = text;
    zpl_isize remaining = max_len, res;

    while (*fmt) {
        zpl__format_info info = { 0 };
        zpl_isize len = 0;
        info.precision = -1;

        while (*fmt && *fmt != '%' && remaining) *text++ = *fmt++;

        if (*fmt == '%') {
            do {
                switch (*++fmt) {
                    case '-': info.flags |= ZPL_FMT_MINUS; break;
                    case '+': info.flags |= ZPL_FMT_PLUS; break;
                    case '#': info.flags |= ZPL_FMT_ALT; break;
                    case ' ': info.flags |= ZPL_FMT_SPACE; break;
                    case '0': info.flags |= ZPL_FMT_ZERO; break;
                    default: info.flags |= ZPL_FMT_DONE; break;
                }
            } while (!(info.flags & ZPL_FMT_DONE));
        }

        // NOTE: Optional Width
        if (*fmt == '*') {
            int width = va_arg(va, int);
            if (width < 0) {
                info.flags |= ZPL_FMT_MINUS;
                info.width = -width;
            } else {
                info.width = width;
            }
            fmt++;
        } else {
            info.width = cast(zpl_i32) zpl_str_to_i64(fmt, cast(char **) & fmt, 10);
        }

        // NOTE: Optional Precision
        if (*fmt == '.') {
            fmt++;
            if (*fmt == '*') {
                info.precision = va_arg(va, int);
                fmt++;
            } else {
                info.precision = cast(zpl_i32) zpl_str_to_i64(fmt, cast(char **) & fmt, 10);
            }
            info.flags &= ~ZPL_FMT_ZERO;
        }

        switch (*fmt++) {
            case 'h':
            if (*fmt == 'h') { // hh => char
                info.flags |= ZPL_FMT_CHAR;
                fmt++;
            } else { // h => short
                info.flags |= ZPL_FMT_SHORT;
            }
            break;

            case 'l':
            if (*fmt == 'l') { // ll => long long
                info.flags |= ZPL_FMT_LLONG;
                fmt++;
            } else { // l => long
                info.flags |= ZPL_FMT_LONG;
            }
            break;

            break;

            case 'z': // NOTE: zpl_usize
                info.flags |= ZPL_FMT_UNSIGNED;
                // fallthrough
            case 't': // NOTE: zpl_isize
                info.flags |= ZPL_FMT_SIZE;
                break;

            default: fmt--; break;
        }

        switch (*fmt) {
            case 'u':
                info.flags |= ZPL_FMT_UNSIGNED;
                // fallthrough
            case 'd':
            case 'i': info.base = 10; break;

            case 'o': info.base = 8; break;

            case 'x':
                info.base = 16;
                info.flags |= (ZPL_FMT_UNSIGNED | ZPL_FMT_LOWER);
                break;

            case 'X':
                info.base = 16;
                info.flags |= (ZPL_FMT_UNSIGNED | ZPL_FMT_UPPER);
                break;

            case 'f':
            case 'F':
            case 'g':
            case 'G': len = zpl__print_f64(text, remaining, &info, va_arg(va, zpl_f64)); break;

            case 'a':
            case 'A':
                // TODO:
                break;

            case 'c': len = zpl__print_char(text, remaining, &info, cast(char) va_arg(va, int)); break;

            case 's': len = zpl__print_string(text, remaining, &info, va_arg(va, char *)); break;

            case 'p':
                info.base = 16;
                info.flags |= (ZPL_FMT_LOWER | ZPL_FMT_UNSIGNED | ZPL_FMT_ALT | ZPL_FMT_INTPTR);
                break;

            case '%': len = zpl__print_char(text, remaining, &info, '%'); break;

            default: fmt--; break;
        }

        fmt++;

        if (info.base != 0) {
            if (info.flags & ZPL_FMT_UNSIGNED) {
                zpl_u64 value = 0;
                switch (info.flags & ZPL_FMT_INTS) {
                    case ZPL_FMT_CHAR:   value = cast(zpl_u64) cast(zpl_u8) va_arg(va, int); break;
                    case ZPL_FMT_SHORT:  value = cast(zpl_u64) cast(zpl_u16) va_arg(va, int); break;
                    case ZPL_FMT_LONG:   value = cast(zpl_u64) va_arg(va, unsigned long); break;
                    case ZPL_FMT_LLONG:  value = cast(zpl_u64) va_arg(va, unsigned long long); break;
                    case ZPL_FMT_SIZE:   value = cast(zpl_u64) va_arg(va, zpl_usize); break;
                    case ZPL_FMT_INTPTR: value = cast(zpl_u64) va_arg(va, zpl_uintptr); break;
                    default: value             = cast(zpl_u64) va_arg(va, unsigned int); break;
                }

                len = zpl__print_u64(text, remaining, &info, value);

            } else {
                zpl_i64 value = 0;
                switch (info.flags & ZPL_FMT_INTS) {
                    case ZPL_FMT_CHAR:   value = cast(zpl_i64) cast(zpl_i8) va_arg(va, int); break;
                    case ZPL_FMT_SHORT:  value = cast(zpl_i64) cast(zpl_i16) va_arg(va, int); break;
                    case ZPL_FMT_LONG:   value = cast(zpl_i64) va_arg(va, long); break;
                    case ZPL_FMT_LLONG:  value = cast(zpl_i64) va_arg(va, long long); break;
                    case ZPL_FMT_SIZE:   value = cast(zpl_i64) va_arg(va, zpl_usize); break;
                    case ZPL_FMT_INTPTR: value = cast(zpl_i64) va_arg(va, zpl_uintptr); break;
                    default: value             = cast(zpl_i64) va_arg(va, int); break;
                }

                len = zpl__print_i64(text, remaining, &info, value);
            }
        }

        text += len;
        if (len >= remaining)
            remaining = zpl_min(remaining, 1);
        else
            remaining -= len;
    }

    *text++ = '\0';
    res = (text - text_begin);
    return (res >= max_len || res < 0) ? -1 : res;
}


////////////////////////////////////////////////////////////////
//
// Time
//
//

#if defined(ZPL_COMPILER_MSVC) && !defined(__clang__)
zpl_inline zpl_u64 zpl_rdtsc(void) { return __rdtsc( ); }
#elif defined(__i386__)
zpl_inline zpl_u64 zpl_rdtsc(void) {
    zpl_u64 x;
    __asm__ volatile(".byte 0x0f, 0x31" : "=A"(x));
    return x;
}
#elif defined(__x86_64__)
zpl_inline zpl_u64 zpl_rdtsc(void) {
    zpl_u32 hi, lo;
    __asm__ __volatile__("rdtsc" : "=a"(lo), "=d"(hi));
    return (cast(zpl_u64) lo) | ((cast(zpl_u64) hi) << 32);
}
#elif defined(__powerpc__)
zpl_inline zpl_u64 zpl_rdtsc(void) {
    zpl_u64 result = 0;
    zpl_u32 upper, lower, tmp;
    __asm__ volatile("0:                   \n"
                     "\tmftbu   %0         \n"
                     "\tmftb    %1         \n"
                     "\tmftbu   %2         \n"
                     "\tcmpw    %2,%0      \n"
                     "\tbne     0b         \n"
                     : "=r"(upper), "=r"(lower), "=r"(tmp));
    result = upper;
    result = result << 32;
    result = result | lower;

    return result;
}
#elif defined(ZPL_CPU_ARM)
zpl_inline zpl_u64 zpl_rdtsc(void) {
#if defined(__aarch64__)
    int64_t r = 0;
    asm volatile("mrs %0, cntvct_el0" : "=r"(r));
#elif defined(__ARM_ARCH_7A__)
    uint32_t r = 0;
    asm volatile("mrc p15, 0, %0, c9, c13, 0" : "=r"(r));
#elif (__ARM_ARCH >= 6)
    uint32_t pmccntr;
    uint32_t pmuseren;
    uint32_t pmcntenset;

    // Read the user mode perf monitor counter access permissions.
    asm volatile("mrc p15, 0, %0, c9, c14, 0" : "=r"(pmuseren));
    if (pmuseren & 1) { // Allows reading perfmon counters for user mode code.
        asm volatile("mrc p15, 0, %0, c9, c12, 1" : "=r"(pmcntenset));
        if (pmcntenset & 0x80000000ul) { // Is it counting?
            asm volatile("mrc p15, 0, %0, c9, c13, 0" : "=r"(pmccntr));
            // The counter is set up to count every 64th cycle
            return ((int64_t)pmccntr) * 64; // Should optimize to << 6
        }
    }
#else
#error "No suitable method for zpl_rdtsc for this cpu type"
#endif
    return r;
}
#endif

#if defined(ZPL_SYSTEM_WINDOWS)

zpl_inline zpl_f64 zpl_time_now(void) {
    zpl_local_persist LARGE_INTEGER win32_perf_count_freq = { 0 };
    zpl_f64 result;
    LARGE_INTEGER counter;
    zpl_local_persist LARGE_INTEGER win32_perf_counter = { 0 };
    if (!win32_perf_count_freq.QuadPart) {
        QueryPerformanceFrequency(&win32_perf_count_freq);
        ZPL_ASSERT(win32_perf_count_freq.QuadPart != 0);
        QueryPerformanceCounter(&win32_perf_counter);
    }

    QueryPerformanceCounter(&counter);

    result = (counter.QuadPart - win32_perf_counter.QuadPart) / cast(zpl_f64)(win32_perf_count_freq.QuadPart);
    return result;
}

zpl_inline zpl_f64 zpl_utc_time_now(void) {
    FILETIME ft;
    ULARGE_INTEGER li;

    GetSystemTimeAsFileTime(&ft);
    li.LowPart = ft.dwLowDateTime;
    li.HighPart = ft.dwHighDateTime;

    return li.QuadPart / 10 / 10e5;
}

zpl_inline void zpl_sleep_ms(zpl_u32 ms) { Sleep(ms); }

#else

#if defined(ZPL_SYSTEM_LINUX)
zpl_f64 zpl__unix_getime(void) {
    struct timespec t;
    zpl_f64 result;

    clock_gettime(1 /*CLOCK_MONOTONIC*/, &t);
    result = t.tv_sec + 1.0e-9 * t.tv_nsec;
    return result;
}
#endif

zpl_inline zpl_f64 zpl_time_now(void) {
#if defined(ZPL_SYSTEM_OSX)
    zpl_f64 result;

    zpl_local_persist zpl_f64 timebase = 0.0;
    zpl_local_persist zpl_u64 timestart = 0;

    if (!timestart) {
        mach_timebase_info_data_t tb = { 0 };
        mach_timebase_info(&tb);
        timebase = tb.numer;
        timebase /= tb.denom;
        timestart = mach_absolute_time( );
    }

    // NOTE: mach_absolute_time() returns things in nanoseconds
    result = 1.0e-9 * (mach_absolute_time( ) - timestart) * timebase;
    return result;
#else
    zpl_local_persist zpl_f64 unix_timestart = 0.0;

    if (!unix_timestart) { unix_timestart = zpl__unix_getime( ); }

    zpl_f64 now = zpl__unix_getime( );

    return (now - unix_timestart);
#endif
}

zpl_inline zpl_f64 zpl_utc_time_now(void) {
    struct timespec t;
#if defined(ZPL_SYSTEM_OSX)
    clock_serv_t cclock;
    mach_timespec_t mts;
    host_get_clock_service(mach_host_self( ), CALENDAR_CLOCK, &cclock);
    clock_get_time(cclock, &mts);
    mach_port_deallocate(mach_task_self( ), cclock);
    t.tv_sec = mts.tv_sec;
    t.tv_nsec = mts.tv_nsec;
#else
    clock_gettime(0 /*CLOCK_REALTIME*/, &t);
#endif
    return (cast(zpl_u64) t.tv_sec * 1000000ull + t.tv_nsec / 1000 + 11644473600000000ull) / 10e5;
}

zpl_inline void zpl_sleep_ms(zpl_u32 ms) {
    struct timespec req = { cast(time_t) ms / 1000, cast(long)((ms % 1000) * 1000000) };
    struct timespec rem = { 0, 0 };
    nanosleep(&req, &rem);
}

#endif

////////////////////////////////////////////////////////////////
//
// Timer
//
//

zpl_inline zpl_timer *zpl_timer_add(zpl_timer_pool pool) {
    ZPL_ASSERT(pool);

    zpl_timer t = { 0 };
    zpl_array_append(pool, t);
    return pool + (zpl_array_count(pool) - 1);
}

zpl_inline void zpl_timer_set(zpl_timer *t, zpl_f64 duration, zpl_i32 count, zpl_timer_cb cb) {
    ZPL_ASSERT(t);

    t->duration = duration;
    t->remaining_calls = t->initial_calls = count;
    t->callback = cb;
    t->enabled = false;
}

zpl_inline void zpl_timer_start(zpl_timer *t, zpl_f64 delay_start) {
    ZPL_ASSERT(t && !t->enabled);

    t->enabled = true;
    t->remaining_calls = t->initial_calls;
    t->next_call_ts = zpl_time_now( ) + delay_start;
}

zpl_inline void zpl_timer_stop(zpl_timer *t) {
    ZPL_ASSERT(t && t->enabled);

    t->enabled = false;
}

zpl_inline void zpl_timer_update(zpl_timer_pool pool) {
    ZPL_ASSERT(pool);

    zpl_f64 now = zpl_time_now( );

    for (zpl_isize i = 0; i < zpl_array_count(pool); ++i) {
        zpl_timer *t = pool + i;

        if (t->enabled) {
            if (t->remaining_calls > 0 || t->initial_calls == -1) {
                if (t->next_call_ts <= now) {
                    if (t->initial_calls != -1) { --t->remaining_calls; }

                    if (t->remaining_calls == 0) {
                        t->enabled = false;
                    } else {
                        t->next_call_ts = now + t->duration;
                    }

                    t->callback(t->user_data);
                }
            }
        }
    }
}


////////////////////////////////////////////////////////////////
//
// Miscellany
//
//

zpl_global zpl_i32 zpl__random_shared_counter = 0;

zpl_internal zpl_u32 zpl__get_noise_from_time(void) {
    zpl_u32 accum = 0;
    zpl_f64 start, remaining, end, curr = 0;
    zpl_u64 interval = 100000ll;

    start     = zpl_time_now();
    remaining = (interval - cast(zpl_u64)(interval*start)%interval) / cast(zpl_f64)interval;
    end       = start + remaining;

    do {
        curr = zpl_time_now();
        accum += cast(zpl_u32)curr;
    } while (curr >= end);
    return accum;
}

// NOTE: Partly from http://preshing.com/20121224/how-to-generate-a-sequence-of-unique-random-integers/
// But the generation is even more random-er-est

zpl_internal zpl_inline zpl_u32 zpl__permute_qpr(zpl_u32 x) {
    zpl_local_persist zpl_u32 const prime = 4294967291; // 2^32 - 5
    if (x >= prime) {
        return x;
    } else {
        zpl_u32 residue = cast(zpl_u32)(cast(zpl_u64) x * x) % prime;
        if (x <= prime / 2)
            return residue;
        else
            return prime - residue;
    }
}

zpl_internal zpl_inline zpl_u32 zpl__permute_with_offset(zpl_u32 x, zpl_u32 offset) {
    return (zpl__permute_qpr(x) + offset) ^ 0x5bf03635;
}


void zpl_random_init(zpl_random *r) {
    zpl_u64 time, tick;
    zpl_isize i, j;
    zpl_u32 x = 0;
    r->value = 0;

    r->offsets[0] = zpl__get_noise_from_time();
    r->offsets[1] = zpl__random_shared_counter++;
    r->offsets[2] = 0;
    r->offsets[3] = 1;
    time = cast(zpl_u64)zpl_utc_time_now();
    r->offsets[4] = cast(zpl_u32)(time >> 32);
    r->offsets[5] = cast(zpl_u32)time;
    r->offsets[6] = zpl__get_noise_from_time();
    tick = zpl_rdtsc();
    r->offsets[7] = cast(zpl_u32)(tick ^ (tick >> 32));

    for (j = 0; j < 4; j++) {
        for (i = 0; i < zpl_count_of(r->offsets); i++) {
            r->offsets[i] = x = zpl__permute_with_offset(x, r->offsets[i]);
        }
    }
}

zpl_u32 zpl_random_gen_u32(zpl_random *r) {
    zpl_u32 x = r->value;
    zpl_u32 carry = 1;
    zpl_isize i;
    for (i = 0; i < zpl_count_of(r->offsets); i++) {
        x = zpl__permute_with_offset(x, r->offsets[i]);
        if (carry > 0) {
            carry = ++r->offsets[i] ? 0 : 1;
        }
    }

    r->value = x;
    return x;
}

zpl_u32 zpl_random_gen_u32_unique(zpl_random *r) {
    zpl_u32 x = r->value;
    zpl_isize i;
    r->value++;
    for (i = 0; i < zpl_count_of(r->offsets); i++) {
        x = zpl__permute_with_offset(x, r->offsets[i]);
    }

    return x;
}

zpl_u64 zpl_random_gen_u64(zpl_random *r) {
    return ((cast(zpl_u64)zpl_random_gen_u32(r)) << 32) | zpl_random_gen_u32(r);
}


zpl_isize zpl_random_gen_isize(zpl_random *r) {
    zpl_u64 u = zpl_random_gen_u64(r);
    return *cast(zpl_isize *)&u;
}




zpl_i64 zpl_random_range_i64(zpl_random *r, zpl_i64 lower_inc, zpl_i64 higher_inc) {
    zpl_u64 u = zpl_random_gen_u64(r);
    zpl_i64 i = *cast(zpl_i64 *)&u;
    zpl_i64 diff = higher_inc-lower_inc+1;
    i %= diff;
    i += lower_inc;
    return i;
}

zpl_isize zpl_random_range_isize(zpl_random *r, zpl_isize lower_inc, zpl_isize higher_inc) {
    zpl_u64 u = zpl_random_gen_u64(r);
    zpl_isize i = *cast(zpl_isize *)&u;
    zpl_isize diff = higher_inc-lower_inc+1;
    i %= diff;
    i += lower_inc;
    return i;
}

zpl_f64 zpl_random_range_f64(zpl_random *r, zpl_f64 lower_inc, zpl_f64 higher_inc) {
    zpl_u64 u = zpl_random_gen_u64(r);
    zpl_f64 f = *cast(zpl_f64 *)&u;
    zpl_f64 diff = higher_inc-lower_inc+1.0;
    f = zpl_mod64(f, diff);
    f += lower_inc;
    return f;
}



#if defined(ZPL_SYSTEM_WINDOWS)
zpl_inline void zpl_exit(zpl_u32 code) { ExitProcess(code); }
#else
zpl_inline void zpl_exit(zpl_u32 code) { exit(code); }
#endif

zpl_inline void zpl_yield(void) {
#if defined(ZPL_SYSTEM_WINDOWS)
    Sleep(0);
#else
    sched_yield();
#endif
}

zpl_inline const char *zpl_get_env(const char *name) {
    char *buffer = NULL;
    const char *ptr = zpl_get_env_buf(name);

    if (ptr == NULL) {
        return NULL;
    }

    zpl_isize ptr_size = zpl_strlen(ptr);
    buffer = (char *)zpl_malloc(ptr_size * sizeof(char)+1);
    zpl_memcopy((char *)buffer, ptr, ptr_size+1);
    return buffer;
}

zpl_inline const char *zpl_get_env_buf(const char *name) {
#ifdef ZPL_SYSTEM_WINDOWS
    zpl_local_persist wchar_t wbuffer[32767] = {0};
    zpl_local_persist char buffer[32767] = {0};

    if (!GetEnvironmentVariableW(
            cast(LPCWSTR)zpl_utf8_to_ucs2_buf(cast(const zpl_u8 *)name),
            cast(LPWSTR)wbuffer, 32767)) {
        return NULL;
    }

    zpl_ucs2_to_utf8(cast(zpl_u8*)buffer, 32767, cast(const zpl_u16*)wbuffer);

    return (const char *)buffer;
#else
    return (const char *)getenv(name);
#endif
}

zpl_inline zpl_string zpl_get_env_str(const char *name) {
    const char *buf = zpl_get_env_buf(name);

    if (buf == NULL) {
        return NULL;
    }

    zpl_string str = zpl_string_make(zpl_heap(), buf);
    return str;
}

zpl_inline void zpl_set_env(const char *name, const char *value) {
#if defined(ZPL_SYSTEM_WINDOWS)
    SetEnvironmentVariableA(name, value);
#else
    setenv(name, value, 1);
#endif
}

zpl_inline void zpl_unset_env(const char *name) {
#if defined(ZPL_SYSTEM_WINDOWS)
    SetEnvironmentVariableA(name, NULL);
#else
    unsetenv(name);
#endif
}


zpl_inline zpl_u16 zpl_endian_swap16(zpl_u16 i) {
    return (i>>8) | (i<<8);
}

zpl_inline zpl_u32 zpl_endian_swap32(zpl_u32 i) {
    return (i>>24) |(i<<24) |
        ((i&0x00ff0000u)>>8)  | ((i&0x0000ff00u)<<8);
}

zpl_inline zpl_u64 zpl_endian_swap64(zpl_u64 i) {
    return (i>>56) | (i<<56) |
        ((i&0x00ff000000000000ull)>>40) | ((i&0x000000000000ff00ull)<<40) |
        ((i&0x0000ff0000000000ull)>>24) | ((i&0x0000000000ff0000ull)<<24) |
        ((i&0x000000ff00000000ull)>>8)  | ((i&0x00000000ff000000ull)<<8);
}


zpl_inline zpl_isize zpl_count_set_bits(zpl_u64 mask) {
    zpl_isize count = 0;
    while (mask) {
        count += (mask & 1);
        mask >>= 1;
    }
    return count;
}

#if !defined(ZPL_SYSTEM_WINDOWS)
extern char **environ;
#endif

zpl_inline zpl_u32 zpl_system_command(const char *command, zpl_usize buffer_len, char *buffer) {
#if defined(ZPL_SYSTEM_EMSCRIPTEN)
    ZPL_PANIC("zpl_system_command not supported");
#else

#if defined(ZPL_SYSTEM_WINDOWS)
    FILE *handle = _popen(command, "r");
#else
    FILE *handle =  popen(command, "r");
#endif

    if(!handle) return 0;

    int c;
    zpl_usize i=0;
    while ((c = getc(handle)) != EOF && i++ < buffer_len) {
        *buffer++ = c;
    }
#if defined(ZPL_SYSTEM_WINDOWS)
    _pclose(handle);
#else
    pclose(handle);
#endif

#endif
    return 1;
}

zpl_inline zpl_string zpl_system_command_str(const char *command, zpl_allocator backing) {
#if defined(ZPL_SYSTEM_EMSCRIPTEN)
    ZPL_PANIC("zpl_system_command not supported");
#else

#if defined(ZPL_SYSTEM_WINDOWS)
    FILE *handle = _popen(command, "r");
#else
    FILE *handle =  popen(command, "r");
#endif

    if(!handle) return NULL;

    zpl_string output = zpl_string_make_reserve(backing, 4);

    int c;
    while ((c = getc(handle)) != EOF) {
        char ins[2] = {(char)c,0};
        output = zpl_string_appendc(output, ins);
    }



#if defined(ZPL_SYSTEM_WINDOWS)
    _pclose(handle);
#else
    pclose(handle);
#endif

#endif
    return output;
}


////////////////////////////////////////////////////////////////
//
// CLI Options
//
//

void zpl_opts_init(zpl_opts *opts, zpl_allocator a, char const *app) {
    zpl_opts opts_ = { 0 };
    *opts = opts_;
    opts->alloc = a;
    opts->appname = app;

    zpl_array_init(opts->entries, a);
    zpl_array_init(opts->positioned, a);
    zpl_array_init(opts->errors, a);
}

void zpl_opts_free(zpl_opts *opts) {

    for (zpl_i32 i = 0; i < zpl_array_count(opts->entries); ++i) {
        zpl_opts_entry *e = opts->entries + i;
        if (e->type == ZPL_OPTS_STRING) {
            zpl_string_free(e->text);
        }
    }

    zpl_array_free(opts->entries);
    zpl_array_free(opts->positioned);
    zpl_array_free(opts->errors);
}

void zpl_opts_add(zpl_opts *opts, char const *name, char const *lname, const char *desc, zpl_u8 type) {
    zpl_opts_entry e = { 0 };

    e.name = name;
    e.lname = lname;
    e.desc = desc;
    e.type = type;
    e.met = false;
    e.pos = false;

    zpl_array_append(opts->entries, e);
}

zpl_opts_entry *zpl__opts_find(zpl_opts *opts, char const *name, zpl_usize len, zpl_b32 longname) {
    zpl_opts_entry *e = 0;

    for (int i = 0; i < zpl_array_count(opts->entries); ++i) {
        e = opts->entries + i;
        char const *n = (longname ? e->lname : e->name);

        if (zpl_strnlen(name, len) == zpl_strlen(n) && !zpl_strncmp(n, name, len)) { return e; }
    }

    return NULL;
}

void zpl_opts_positional_add(zpl_opts *opts, char const *name) {
    zpl_opts_entry *e = zpl__opts_find(opts, name, zpl_strlen(name), true);

    if (e) {
        e->pos = true;
        zpl_array_append_at(opts->positioned, e, 0);
    }
}

zpl_b32 zpl_opts_positionals_filled(zpl_opts *opts) { return zpl_array_count(opts->positioned) == 0; }

zpl_string zpl_opts_string(zpl_opts *opts, char const *name, char const *fallback) {
    zpl_opts_entry *e = zpl__opts_find(opts, name, zpl_strlen(name), true);

    return (char *)((e && e->met) ? e->text : fallback);
}

zpl_f64 zpl_opts_real(zpl_opts *opts, char const *name, zpl_f64 fallback) {
    zpl_opts_entry *e = zpl__opts_find(opts, name, zpl_strlen(name), true);

    return (e && e->met) ? e->real : fallback;
}

zpl_i64 zpl_opts_integer(zpl_opts *opts, char const *name, zpl_i64 fallback) {
    zpl_opts_entry *e = zpl__opts_find(opts, name, zpl_strlen(name), true);

    return (e && e->met) ? e->integer : fallback;
}

void zpl__opts_set_value(zpl_opts *opts, zpl_opts_entry *t, char *b) {
    t->met = true;

    switch (t->type) {
        case ZPL_OPTS_STRING: {
            t->text = zpl_string_make(opts->alloc, b);
        } break;

        case ZPL_OPTS_FLOAT: {
            t->real = zpl_str_to_f64(b, NULL);
        } break;

        case ZPL_OPTS_INT: {
            t->integer = zpl_str_to_i64(b, NULL, 10);
        } break;
    }

    for (zpl_isize i=0; i < zpl_array_count(opts->positioned); i++) {
        if (!zpl_strcmp(opts->positioned[i]->lname, t->lname)) {
            zpl_array_remove_at(opts->positioned, i);
            break;
        }
    }
}

zpl_b32 zpl_opts_has_arg(zpl_opts *opts, char const *name) {
    zpl_opts_entry *e = zpl__opts_find(opts, name, zpl_strlen(name), true);

    if (e) { return e->met; }

    return false;
}

void zpl_opts_print_help(zpl_opts *opts) {
    zpl_printf("USAGE: %s", opts->appname);

    for (zpl_isize i = zpl_array_count(opts->entries); i >= 0; --i) {
        zpl_opts_entry *e = opts->entries + i;

        if (e->pos == (zpl_b32) true) { zpl_printf(" [%s]", e->lname); }
    }

    zpl_printf("\nOPTIONS:\n");

    for (zpl_isize i = 0; i < zpl_array_count(opts->entries); ++i) {
        zpl_opts_entry *e = opts->entries + i;

        zpl_printf("\t-%s, --%s: %s\n", e->name, e->lname, e->desc);
    }
}

void zpl_opts_print_errors(zpl_opts *opts) {
    for (int i = 0; i < zpl_array_count(opts->errors); ++i) {
        zpl_opts_err *err = (opts->errors + i);

        zpl_printf("ERROR: ");

        switch (err->type) {
            case ZPL_OPTS_ERR_OPTION: zpl_printf("Invalid option \"%s\"", err->val); break;

            case ZPL_OPTS_ERR_VALUE: zpl_printf("Invalid value \"%s\"", err->val); break;

            case ZPL_OPTS_ERR_MISSING_VALUE: zpl_printf("Missing value for option \"%s\"", err->val); break;

            case ZPL_OPTS_ERR_EXTRA_VALUE: zpl_printf("Extra value for option \"%s\"", err->val); break;
        }

        zpl_printf("\n");
    }
}

void zpl__opts_push_error(zpl_opts *opts, char *b, zpl_u8 errtype) {
    zpl_opts_err err = { 0 };
    err.val = b;
    err.type = errtype;
    zpl_array_append(opts->errors, err);
}

zpl_b32 zpl_opts_compile(zpl_opts *opts, int argc, char **argv) {
    zpl_b32 had_errors = false;
    for (int i = 1; i < argc; ++i) {
        char *p = argv[i];

        if (*p) {
            p = zpl_str_trim(p, false);
            if (*p == '-') {
                zpl_opts_entry *t = 0;
                zpl_b32 checkln = false;
                if (*(p + 1) == '-') {
                    checkln = true;
                    ++p;
                }

                char *b = p + 1, *e = b;

                while (zpl_char_is_alphanumeric(*e)) { ++e; }

                t = zpl__opts_find(opts, b, (e - b), checkln);

                if (t) {
                    char *ob = b;
                    b = e;

                    /**/ if (*e == '=') {
                        if (t->type == ZPL_OPTS_FLAG) {
                            *e = '\0';
                            zpl__opts_push_error(opts, ob, ZPL_OPTS_ERR_EXTRA_VALUE);
                            had_errors = true;
                            continue;
                        }

                        b = e = e + 1;
                    } else if (*e == '\0') {
                        char *sp = argv[i+1];

                        if (sp && *sp != '-' && (zpl_array_count(opts->positioned) < 1  || t->type != ZPL_OPTS_FLAG)) {
                            if (t->type == ZPL_OPTS_FLAG) {
                                zpl__opts_push_error(opts, b, ZPL_OPTS_ERR_EXTRA_VALUE);
                                had_errors = true;
                                continue;
                            }

                            p = sp;
                            b = e = sp;
                            ++i;
                        } else {
                            if (t->type != ZPL_OPTS_FLAG) {
                                zpl__opts_push_error(opts, ob, ZPL_OPTS_ERR_MISSING_VALUE);
                                had_errors = true;
                                continue;
                            }
                            t->met = true;
                            continue;
                        }
                    }

                    e = zpl_str_control_skip(e, '\0');
                    zpl__opts_set_value(opts, t, b);
                } else {
                    zpl__opts_push_error(opts, b, ZPL_OPTS_ERR_OPTION);
                    had_errors = true;
                }
            } else if (zpl_array_count(opts->positioned)) {
                zpl_opts_entry *l = zpl_array_back(opts->positioned);
                zpl_array_pop(opts->positioned);
                zpl__opts_set_value(opts, l, p);
            } else {
                zpl__opts_push_error(opts, p, ZPL_OPTS_ERR_VALUE);
                had_errors = true;
            }
        }
    }
    return !had_errors;
}


////////////////////////////////////////////////////////////////
//
// Math
//

/* NOTE: To remove the need for memcpy */
static void zpl__memcpy_4byte(void *dest, void const *src, zpl_isize size) {
    zpl_isize i;
    unsigned int *d, *s;
    d = (unsigned int *)dest;
    s = (unsigned int *)src;
    for (i = 0; i < size / 4; i++) { *d++ = *s++; }
}

zpl_f32 zpl_to_radians(zpl_f32 degrees) { return degrees * ZPL_TAU / 360.0f; }
zpl_f32 zpl_to_degrees(zpl_f32 radians) { return radians * 360.0f / ZPL_TAU; }

zpl_f32 zpl_angle_diff(zpl_f32 radians_a, zpl_f32 radians_b) {
    zpl_f32 delta = zpl_mod(radians_b - radians_a, ZPL_TAU);
    delta = zpl_mod(delta + 1.5f * ZPL_TAU, ZPL_TAU);
    delta -= 0.5f * ZPL_TAU;
    return delta;
}

zpl_f32 zpl_copy_sign(zpl_f32 x, zpl_f32 y) {
    int ix, iy;
    ix = *(int *)&x;
    iy = *(int *)&y;

    ix &= 0x7fffffff;
    ix |= iy & 0x80000000;
    return *(zpl_f32 *)&ix;
}

zpl_f32 zpl_remainder(zpl_f32 x, zpl_f32 y) { return x - (zpl_round(x / y) * y); }

zpl_f32 zpl_mod(zpl_f32 x, zpl_f32 y) {
    zpl_f32 result;
    y = zpl_abs(y);
    result = zpl_remainder(zpl_abs(x), y);
    if (zpl_sign(result)) result += y;
    return zpl_copy_sign(result, x);
}

zpl_f64 zpl_copy_sign64(zpl_f64 x, zpl_f64 y) {
    zpl_i64 ix, iy;
    ix = *(zpl_i64 *)&x;
    iy = *(zpl_i64 *)&y;

    ix &= 0x7fffffffffffffff;
    ix |= iy & 0x8000000000000000;
    return *cast(zpl_f64 *) & ix;
}

zpl_f64 zpl_floor64(zpl_f64 x)                { return cast(zpl_f64)((x >= 0.0) ? cast(zpl_i64) x : cast(zpl_i64)(x - 0.9999999999999999)); }
zpl_f64 zpl_ceil64(zpl_f64 x)                 { return cast(zpl_f64)((x < 0) ? cast(zpl_i64) x : (cast(zpl_i64) x) + 1); }
zpl_f64 zpl_round64(zpl_f64 x)                { return cast(zpl_f64)((x >= 0.0) ? zpl_floor64(x + 0.5) : zpl_ceil64(x - 0.5)); }
zpl_f64 zpl_remainder64(zpl_f64 x, zpl_f64 y) { return x - (zpl_round64(x / y) * y); }
zpl_f64 zpl_abs64(zpl_f64 x)                  { return x < 0 ? -x : x; }
zpl_f64 zpl_sign64(zpl_f64 x)                 { return x < 0 ? -1.0 : +1.0; }

zpl_f64 zpl_mod64(zpl_f64 x, zpl_f64 y) {
    zpl_f64 result;
    y = zpl_abs64(y);
    result = zpl_remainder64(zpl_abs64(x), y);
    if (zpl_sign64(result)) result += y;
    return zpl_copy_sign64(result, x);
}

zpl_f32 zpl_quake_rsqrt(zpl_f32 a) {
    union {
        int i;
        zpl_f32 f;
    } t;
    zpl_f32 x2;
    zpl_f32 const three_halfs = 1.5f;

    x2 = a * 0.5f;
    t.f = a;
    t.i = 0x5f375a86 - (t.i >> 1);                /* What the fuck? */
    t.f = t.f * (three_halfs - (x2 * t.f * t.f)); /* 1st iteration */
    t.f = t.f * (three_halfs - (x2 * t.f * t.f)); /* 2nd iteration, this can be removed */

    return t.f;
}

#if defined(ZPL_NO_MATH_H)
#if defined(_MSC_VER)

zpl_f32 zpl_rsqrt(zpl_f32 a) { return _mm_cvtss_f32(_mm_rsqrt_ss(_mm_set_ss(a))); }
zpl_f32 zpl_sqrt(zpl_f32 a)  { return _mm_cvtss_f32(_mm_sqrt_ss(_mm_set_ss(a))); };

zpl_f32 zpl_sin(zpl_f32 a) {
    static zpl_f32 const a0 = +1.91059300966915117e-31f;
    static zpl_f32 const a1 = +1.00086760103908896f;
    static zpl_f32 const a2 = -1.21276126894734565e-2f;
    static zpl_f32 const a3 = -1.38078780785773762e-1f;
    static zpl_f32 const a4 = -2.67353392911981221e-2f;
    static zpl_f32 const a5 = +2.08026600266304389e-2f;
    static zpl_f32 const a6 = -3.03996055049204407e-3f;
    static zpl_f32 const a7 = +1.38235642404333740e-4f;
    return a0 + a * (a1 + a * (a2 + a * (a3 + a * (a4 + a * (a5 + a * (a6 + a * a7))))));
}

zpl_f32 zpl_cos(zpl_f32 a) {
    static zpl_f32 const a0 = +1.00238601909309722f;
    static zpl_f32 const a1 = -3.81919947353040024e-2f;
    static zpl_f32 const a2 = -3.94382342128062756e-1f;
    static zpl_f32 const a3 = -1.18134036025221444e-1f;
    static zpl_f32 const a4 = +1.07123798512170878e-1f;
    static zpl_f32 const a5 = -1.86637164165180873e-2f;
    static zpl_f32 const a6 = +9.90140908664079833e-4f;
    static zpl_f32 const a7 = -5.23022132118824778e-14f;
    return a0 + a * (a1 + a * (a2 + a * (a3 + a * (a4 + a * (a5 + a * (a6 + a * a7))))));
}

zpl_f32 zpl_tan(zpl_f32 radians) {
    zpl_f32 rr = radians * radians;
    zpl_f32 a = 9.5168091e-03f;
    a *= rr;
    a += 2.900525e-03f;
    a *= rr;
    a += 2.45650893e-02f;
    a *= rr;
    a += 5.33740603e-02f;
    a *= rr;
    a += 1.333923995e-01f;
    a *= rr;
    a += 3.333314036e-01f;
    a *= rr;
    a += 1.0f;
    a *= radians;
    return a;
}

zpl_f32 zpl_arcsin(zpl_f32 a) { return zpl_arctan2(a, zpl_sqrt((1.0f + a) * (1.0f - a))); }
zpl_f32 zpl_arccos(zpl_f32 a) { return zpl_arctan2(zpl_sqrt((1.0f + a) * (1.0f - a)), a); }

zpl_f32 zpl_arctan(zpl_f32 a) {
    zpl_f32 u = a * a;
    zpl_f32 u2 = u * u;
    zpl_f32 u3 = u2 * u;
    zpl_f32 u4 = u3 * u;
    zpl_f32 f = 1.0f + 0.33288950512027f * u - 0.08467922817644f * u2 + 0.03252232640125f * u3 - 0.00749305860992f * u4;
    return a / f;
}

zpl_f32 zpl_arctan2(zpl_f32 y, zpl_f32 x) {
    if (zpl_abs(x) > zpl_abs(y)) {
        zpl_f32 a = zpl_arctan(y / x);
        if (x > 0.0f)
            return a;
        else
            return y > 0.0f ? a + ZPL_TAU_OVER_2 : a - ZPL_TAU_OVER_2;
    } else {
        zpl_f32 a = zpl_arctan(x / y);
        if (x > 0.0f)
            return y > 0.0f ? ZPL_TAU_OVER_4 - a : -ZPL_TAU_OVER_4 - a;
        else
            return y > 0.0f ? ZPL_TAU_OVER_4 + a : -ZPL_TAU_OVER_4 + a;
    }
}

zpl_f32 zpl_exp(zpl_f32 a) {
    union {
        zpl_f32 f;
        int i;
    } u, v;
    u.i = (int)(6051102 * a + 1056478197);
    v.i = (int)(1056478197 - 6051102 * a);
    return u.f / v.f;
}

zpl_f32 zpl_log(zpl_f32 a) {
    union {
        zpl_f32 f;
        int i;
    } u = { a };
    return (u.i - 1064866805) * 8.262958405176314e-8f; /* 1 / 12102203.0; */
}

zpl_f32 zpl_pow(zpl_f32 a, zpl_f32 b) {
    int flipped = 0, e;
    zpl_f32 f, r = 1.0f;
    if (b < 0) {
        flipped = 1;
        b = -b;
    }

    e = (int)b;
    f = zpl_exp(b - e);

    while (e) {
        if (e & 1) r *= a;
        a *= a;
        e >>= 1;
    }

    r *= f;
    return flipped ? 1.0f / r : r;
}

#else

zpl_f32 zpl_rsqrt(zpl_f32 a)              { return 1.0f / __builtin_sqrt(a); }
zpl_f32 zpl_sqrt(zpl_f32 a)               { return __builtin_sqrt(a); }
zpl_f32 zpl_sin(zpl_f32 radians)          { return __builtin_sinf(radians); }
zpl_f32 zpl_cos(zpl_f32 radians)          { return __builtin_cosf(radians); }
zpl_f32 zpl_tan(zpl_f32 radians)          { return __builtin_tanf(radians); }
zpl_f32 zpl_arcsin(zpl_f32 a)             { return __builtin_asinf(a); }
zpl_f32 zpl_arccos(zpl_f32 a)             { return __builtin_acosf(a); }
zpl_f32 zpl_arctan(zpl_f32 a)             { return __builtin_atanf(a); }
zpl_f32 zpl_arctan2(zpl_f32 y, zpl_f32 x) { return __builtin_atan2f(y, x); }

zpl_f32 zpl_exp(zpl_f32 x) { return __builtin_expf(x); }
zpl_f32 zpl_log(zpl_f32 x) { return __builtin_logf(x); }

// TODO: Should this be zpl_exp(y * zpl_log(x)) ???
zpl_f32 zpl_pow(zpl_f32 x, zpl_f32 y) { return __builtin_powf(x, y); }

#endif

#else
zpl_f32 zpl_rsqrt(zpl_f32 a)                { return 1.0f / sqrtf(a); }
zpl_f32 zpl_sqrt(zpl_f32 a)                 { return sqrtf(a); };
zpl_f32 zpl_sin(zpl_f32 radians)            { return sinf(radians); };
zpl_f32 zpl_cos(zpl_f32 radians)            { return cosf(radians); };
zpl_f32 zpl_tan(zpl_f32 radians)            { return tanf(radians); };
zpl_f32 zpl_arcsin(zpl_f32 a)               { return asinf(a); };
zpl_f32 zpl_arccos(zpl_f32 a)               { return acosf(a); };
zpl_f32 zpl_arctan(zpl_f32 a)               { return atanf(a); };
zpl_f32 zpl_arctan2(zpl_f32 y, zpl_f32 x)   { return atan2f(y, x); };

zpl_f32 zpl_exp(zpl_f32 x)            { return expf(x); }
zpl_f32 zpl_log(zpl_f32 x)            { return logf(x); }
zpl_f32 zpl_pow(zpl_f32 x, zpl_f32 y) { return powf(x, y); }
#endif

zpl_f32 zpl_exp2(zpl_f32 x) { return zpl_exp(ZPL_LOG_TWO * x); }
zpl_f32 zpl_log2(zpl_f32 x) { return zpl_log(x) / ZPL_LOG_TWO; }

zpl_f32 zpl_fast_exp(zpl_f32 x) {
    /* NOTE: Only works in the range -1 <= x <= +1 */
    zpl_f32 e = 1.0f + x * (1.0f + x * 0.5f * (1.0f + x * 0.3333333333f * (1.0f + x * 0.25f * (1.0f + x * 0.2f))));
    return e;
}

zpl_f32 zpl_fast_exp2(zpl_f32 x) { return zpl_fast_exp(ZPL_LOG_TWO * x); }

zpl_f32 zpl_round(zpl_f32 x) { return (float)((x >= 0.0f) ? zpl_floor(x + 0.5f) : zpl_ceil(x - 0.5f)); }
zpl_f32 zpl_floor(zpl_f32 x) { return (float)((x >= 0.0f) ? (int)x              : (int)(x - 0.9999999999999999f)); }
zpl_f32 zpl_ceil(zpl_f32 x)  { return (float)((x <  0.0f) ? (int)x              : ((int)x) + 1); }

zpl_f32 zpl_half_to_float(zpl_half value) {
    union {
        unsigned int i;
        zpl_f32 f;
    } result;
    int s = (value >> 15) & 0x001;
    int e = (value >> 10) & 0x01f;
    int m = value & 0x3ff;

    if (e == 0) {
        if (m == 0) {
            /* Plus or minus zero */
            result.i = (unsigned int)(s << 31);
            return result.f;
        } else {
            /* Denormalized number */
            while (!(m & 0x00000400)) {
                m <<= 1;
                e -= 1;
            }

            e += 1;
            m &= ~0x00000400;
        }
    } else if (e == 31) {
        if (m == 0) {
            /* Positive or negative infinity */
            result.i = (unsigned int)((s << 31) | 0x7f800000);
            return result.f;
        } else {
            /* Nan */
            result.i = (unsigned int)((s << 31) | 0x7f800000 | (m << 13));
            return result.f;
        }
    }

    e = e + (127 - 15);
    m = m << 13;

    result.i = (unsigned int)((s << 31) | (e << 23) | m);
    return result.f;
}

zpl_half zpl_float_to_half(zpl_f32 value) {
    union {
        unsigned int i;
        zpl_f32 f;
    } v;
    int i, s, e, m;

    v.f = value;
    i = (int)v.i;

    s = (i >> 16) & 0x00008000;
    e = ((i >> 23) & 0x000000ff) - (127 - 15);
    m = i & 0x007fffff;

    if (e <= 0) {
        if (e < -10) return (zpl_half)s;
        m = (m | 0x00800000) >> (1 - e);

        if (m & 0x00001000) m += 0x00002000;

        return (zpl_half)(s | (m >> 13));
    } else if (e == 0xff - (127 - 15)) {
        if (m == 0) {
            return (zpl_half)(s | 0x7c00); /* NOTE: infinity */
        } else {
            /* NOTE: NAN */
            m >>= 13;
            return (zpl_half)(s | 0x7c00 | m | (m == 0));
        }
    } else {
        if (m & 0x00001000) {
            m += 0x00002000;
            if (m & 0x00800000) {
                m = 0;
                e += 1;
            }
        }

        if (e > 30) {
            zpl_f32 volatile f = 1e12f;
            int j;
            for (j = 0; j < 10; j++) f *= f; /* NOTE: Cause overflow */

            return (zpl_half)(s | 0x7c00);
        }

        return (zpl_half)(s | (e << 10) | (m >> 13));
    }
}

#define ZPL_VEC2_2OP(a, c, post) \
    a->x = c.x post;             \
    a->y = c.y post;

#define ZPL_VEC2_3OP(a, b, op, c, post) \
    a->x = b.x op c.x post;             \
    a->y = b.y op c.y post;

#define ZPL_VEC3_2OP(a, c, post) \
    a->x = c.x post;             \
    a->y = c.y post;             \
    a->z = c.z post;

#define ZPL_VEC3_3OP(a, b, op, c, post) \
    a->x = b.x op c.x post;             \
    a->y = b.y op c.y post;             \
    a->z = b.z op c.z post;

#define ZPL_VEC4_2OP(a, c, post) \
    a->x = c.x post;             \
    a->y = c.y post;             \
    a->z = c.z post;             \
    a->w = c.w post;

#define ZPL_VEC4_3OP(a, b, op, c, post) \
    a->x = b.x op c.x post;             \
    a->y = b.y op c.y post;             \
    a->z = b.z op c.z post;             \
    a->w = b.w op c.w post;

zpl_vec2 zpl_vec2f_zero(void) {
    zpl_vec2 v = { 0, 0 };
    return v;
}
zpl_vec2 zpl_vec2f(zpl_f32 x, zpl_f32 y) {
    zpl_vec2 v;
    v.x = x;
    v.y = y;
    return v;
}
zpl_vec2 zpl_vec2fv(zpl_f32 x[2]) {
    zpl_vec2 v;
    v.x = x[0];
    v.y = x[1];
    return v;
}

zpl_vec3 zpl_vec3f_zero(void) {
    zpl_vec3 v = { 0, 0, 0 };
    return v;
}
zpl_vec3 zpl_vec3f(zpl_f32 x, zpl_f32 y, zpl_f32 z) {
    zpl_vec3 v;
    v.x = x;
    v.y = y;
    v.z = z;
    return v;
}
zpl_vec3 zpl_vec3fv(zpl_f32 x[3]) {
    zpl_vec3 v;
    v.x = x[0];
    v.y = x[1];
    v.z = x[2];
    return v;
}

zpl_vec4 zpl_vec4f_zero(void) {
    zpl_vec4 v = { 0, 0, 0, 0 };
    return v;
}
zpl_vec4 zpl_vec4f(zpl_f32 x, zpl_f32 y, zpl_f32 z, zpl_f32 w) {
    zpl_vec4 v;
    v.x = x;
    v.y = y;
    v.z = z;
    v.w = w;
    return v;
}
zpl_vec4 zpl_vec4fv(zpl_f32 x[4]) {
    zpl_vec4 v;
    v.x = x[0];
    v.y = x[1];
    v.z = x[2];
    v.w = x[3];
    return v;
}

void zpl_vec2_add(zpl_vec2 *d, zpl_vec2 v0, zpl_vec2 v1) { ZPL_VEC2_3OP(d, v0, +, v1, +0); }
void zpl_vec2_sub(zpl_vec2 *d, zpl_vec2 v0, zpl_vec2 v1) { ZPL_VEC2_3OP(d, v0, -, v1, +0); }
void zpl_vec2_mul(zpl_vec2 *d, zpl_vec2 v, zpl_f32 s)    { ZPL_VEC2_2OP(d, v, *s); }
void zpl_vec2_div(zpl_vec2 *d, zpl_vec2 v, zpl_f32 s)    { ZPL_VEC2_2OP(d, v, / s); }

void zpl_vec3_add(zpl_vec3 *d, zpl_vec3 v0, zpl_vec3 v1) { ZPL_VEC3_3OP(d, v0, +, v1, +0); }
void zpl_vec3_sub(zpl_vec3 *d, zpl_vec3 v0, zpl_vec3 v1) { ZPL_VEC3_3OP(d, v0, -, v1, +0); }
void zpl_vec3_mul(zpl_vec3 *d, zpl_vec3 v, zpl_f32 s)    { ZPL_VEC3_2OP(d, v, *s); }
void zpl_vec3_div(zpl_vec3 *d, zpl_vec3 v, zpl_f32 s)    { ZPL_VEC3_2OP(d, v, / s); }

void zpl_vec4_add(zpl_vec4 *d, zpl_vec4 v0, zpl_vec4 v1) { ZPL_VEC4_3OP(d, v0, +, v1, +0); }
void zpl_vec4_sub(zpl_vec4 *d, zpl_vec4 v0, zpl_vec4 v1) { ZPL_VEC4_3OP(d, v0, -, v1, +0); }
void zpl_vec4_mul(zpl_vec4 *d, zpl_vec4 v, zpl_f32 s)    { ZPL_VEC4_2OP(d, v, *s); }
void zpl_vec4_div(zpl_vec4 *d, zpl_vec4 v, zpl_f32 s)    { ZPL_VEC4_2OP(d, v, / s); }

void zpl_vec2_addeq(zpl_vec2 *d, zpl_vec2 v) { ZPL_VEC2_3OP(d, (*d), +, v, +0); }
void zpl_vec2_subeq(zpl_vec2 *d, zpl_vec2 v) { ZPL_VEC2_3OP(d, (*d), -, v, +0); }
void zpl_vec2_muleq(zpl_vec2 *d, zpl_f32 s)  { ZPL_VEC2_2OP(d, (*d), *s); }
void zpl_vec2_diveq(zpl_vec2 *d, zpl_f32 s)  { ZPL_VEC2_2OP(d, (*d), / s); }

void zpl_vec3_addeq(zpl_vec3 *d, zpl_vec3 v) { ZPL_VEC3_3OP(d, (*d), +, v, +0); }
void zpl_vec3_subeq(zpl_vec3 *d, zpl_vec3 v) { ZPL_VEC3_3OP(d, (*d), -, v, +0); }
void zpl_vec3_muleq(zpl_vec3 *d, zpl_f32 s)  { ZPL_VEC3_2OP(d, (*d), *s); }
void zpl_vec3_diveq(zpl_vec3 *d, zpl_f32 s)  { ZPL_VEC3_2OP(d, (*d), / s); }

void zpl_vec4_addeq(zpl_vec4 *d, zpl_vec4 v) { ZPL_VEC4_3OP(d, (*d), +, v, +0); }
void zpl_vec4_subeq(zpl_vec4 *d, zpl_vec4 v) { ZPL_VEC4_3OP(d, (*d), -, v, +0); }
void zpl_vec4_muleq(zpl_vec4 *d, zpl_f32 s)  { ZPL_VEC4_2OP(d, (*d), *s); }
void zpl_vec4_diveq(zpl_vec4 *d, zpl_f32 s)  { ZPL_VEC4_2OP(d, (*d), / s); }

#undef ZPL_VEC2_2OP
#undef ZPL_VEC2_3OP
#undef ZPL_VEC3_3OP
#undef ZPL_VEC3_2OP
#undef ZPL_VEC4_2OP
#undef ZPL_VEC4_3OP

zpl_f32 zpl_vec2_dot(zpl_vec2 v0, zpl_vec2 v1) { return v0.x * v1.x + v0.y * v1.y; }
zpl_f32 zpl_vec3_dot(zpl_vec3 v0, zpl_vec3 v1) { return v0.x * v1.x + v0.y * v1.y + v0.z * v1.z; }
zpl_f32 zpl_vec4_dot(zpl_vec4 v0, zpl_vec4 v1) { return v0.x * v1.x + v0.y * v1.y + v0.z * v1.z + v0.w * v1.w; }

void zpl_vec2_cross(zpl_f32 *d, zpl_vec2 v0, zpl_vec2 v1) { *d = v0.x * v1.y - v1.x * v0.y; }
void zpl_vec3_cross(zpl_vec3 *d, zpl_vec3 v0, zpl_vec3 v1) {
    d->x = v0.y * v1.z - v0.z * v1.y;
    d->y = v0.z * v1.x - v0.x * v1.z;
    d->z = v0.x * v1.y - v0.y * v1.x;
}

zpl_f32 zpl_vec2_mag2(zpl_vec2 v) { return zpl_vec2_dot(v, v); }
zpl_f32 zpl_vec3_mag2(zpl_vec3 v) { return zpl_vec3_dot(v, v); }
zpl_f32 zpl_vec4_mag2(zpl_vec4 v) { return zpl_vec4_dot(v, v); }

/* TODO: Create custom sqrt function */
zpl_f32 zpl_vec2_mag(zpl_vec2 v) { return zpl_sqrt(zpl_vec2_dot(v, v)); }
zpl_f32 zpl_vec3_mag(zpl_vec3 v) { return zpl_sqrt(zpl_vec3_dot(v, v)); }
zpl_f32 zpl_vec4_mag(zpl_vec4 v) { return zpl_sqrt(zpl_vec4_dot(v, v)); }

void zpl_vec2_norm(zpl_vec2 *d, zpl_vec2 v) {
    zpl_f32 inv_mag = zpl_rsqrt(zpl_vec2_dot(v, v));
    zpl_vec2_mul(d, v, inv_mag);
}
void zpl_vec3_norm(zpl_vec3 *d, zpl_vec3 v) {
    zpl_f32 mag = zpl_vec3_mag(v);
    zpl_vec3_div(d, v, mag);
}
void zpl_vec4_norm(zpl_vec4 *d, zpl_vec4 v) {
    zpl_f32 mag = zpl_vec4_mag(v);
    zpl_vec4_div(d, v, mag);
}

void zpl_vec2_norm0(zpl_vec2 *d, zpl_vec2 v) {
    zpl_f32 mag = zpl_vec2_mag(v);
    if (mag > 0)
        zpl_vec2_div(d, v, mag);
    else
        *d = zpl_vec2f_zero( );
}
void zpl_vec3_norm0(zpl_vec3 *d, zpl_vec3 v) {
    zpl_f32 mag = zpl_vec3_mag(v);
    if (mag > 0)
        zpl_vec3_div(d, v, mag);
    else
        *d = zpl_vec3f_zero( );
}
void zpl_vec4_norm0(zpl_vec4 *d, zpl_vec4 v) {
    zpl_f32 mag = zpl_vec4_mag(v);
    if (mag > 0)
        zpl_vec4_div(d, v, mag);
    else
        *d = zpl_vec4f_zero( );
}

void zpl_vec2_reflect(zpl_vec2 *d, zpl_vec2 i, zpl_vec2 n) {
    zpl_vec2 b = n;
    zpl_vec2_muleq(&b, 2.0f * zpl_vec2_dot(n, i));
    zpl_vec2_sub(d, i, b);
}

void zpl_vec3_reflect(zpl_vec3 *d, zpl_vec3 i, zpl_vec3 n) {
    zpl_vec3 b = n;
    zpl_vec3_muleq(&b, 2.0f * zpl_vec3_dot(n, i));
    zpl_vec3_sub(d, i, b);
}

void zpl_vec2_refract(zpl_vec2 *d, zpl_vec2 i, zpl_vec2 n, zpl_f32 eta) {
    zpl_vec2 a, b;
    zpl_f32 dv, k;

    dv = zpl_vec2_dot(n, i);
    k = 1.0f - eta * eta * (1.0f - dv * dv);
    zpl_vec2_mul(&a, i, eta);
    zpl_vec2_mul(&b, n, eta * dv * zpl_sqrt(k));
    zpl_vec2_sub(d, a, b);
    zpl_vec2_muleq(d, (float)(k >= 0.0f));
}

void zpl_vec3_refract(zpl_vec3 *d, zpl_vec3 i, zpl_vec3 n, zpl_f32 eta) {
    zpl_vec3 a, b;
    zpl_f32 dv, k;

    dv = zpl_vec3_dot(n, i);
    k = 1.0f - eta * eta * (1.0f - dv * dv);
    zpl_vec3_mul(&a, i, eta);
    zpl_vec3_mul(&b, n, eta * dv * zpl_sqrt(k));
    zpl_vec3_sub(d, a, b);
    zpl_vec3_muleq(d, (float)(k >= 0.0f));
}

zpl_f32 zpl_vec2_aspect_ratio(zpl_vec2 v) { return (v.y < 0.0001f) ? 0.0f : v.x / v.y; }

void zpl_mat2_transpose(zpl_mat2 *m) { zpl_float22_transpose(zpl_float22_m(m)); }
void zpl_mat2_identity(zpl_mat2 *m) { zpl_float22_identity(zpl_float22_m(m)); }
void zpl_mat2_mul(zpl_mat2 *out, zpl_mat2 *m1, zpl_mat2 *m2) {
    zpl_float22_mul(zpl_float22_m(out), zpl_float22_m(m1), zpl_float22_m(m2));
}

void zpl_float22_identity(zpl_f32 m[2][2]) {
    m[0][0] = 1;
    m[0][1] = 0;
    m[1][0] = 0;
    m[1][1] = 1;
}

void zpl_mat2_mul_vec2(zpl_vec2 *out, zpl_mat2 *m, zpl_vec2 in) { zpl_float22_mul_vec2(out, zpl_float22_m(m), in); }

zpl_mat2 *zpl_mat2_v(zpl_vec2 m[2])   { return (zpl_mat2 *)m; }
zpl_mat2 *zpl_mat2_f(zpl_f32 m[2][2]) { return (zpl_mat2 *)m; }

zpl_float2 *zpl_float22_m(zpl_mat2 *m)   { return (zpl_float2 *)m; }
zpl_float2 *zpl_float22_v(zpl_vec2 m[2]) { return (zpl_float2 *)m; }
zpl_float2 *zpl_float22_4(zpl_f32 m[4])  { return (zpl_float2 *)m; }

void zpl_float22_transpose(zpl_f32 (*vec)[2]) {
    int i, j;
    for (j = 0; j < 2; j++) {
        for (i = j + 1; i < 2; i++) {
            zpl_f32 t = vec[i][j];
            vec[i][j] = vec[j][i];
            vec[j][i] = t;
        }
    }
}

void zpl_float22_mul(zpl_f32 (*out)[2], zpl_f32 (*mat1)[2], zpl_f32 (*mat2)[2]) {
    int i, j;
    zpl_f32 temp1[2][2], temp2[2][2];
    if (mat1 == out) {
        zpl__memcpy_4byte(temp1, mat1, sizeof(temp1));
        mat1 = temp1;
    }
    if (mat2 == out) {
        zpl__memcpy_4byte(temp2, mat2, sizeof(temp2));
        mat2 = temp2;
    }
    for (j = 0; j < 2; j++) {
        for (i = 0; i < 2; i++) { out[j][i] = mat1[0][i] * mat2[j][0] + mat1[1][i] * mat2[j][1]; }
    }
}

void zpl_float22_mul_vec2(zpl_vec2 *out, zpl_f32 m[2][2], zpl_vec2 v) {
    out->x = m[0][0] * v.x + m[0][1] * v.y;
    out->y = m[1][0] * v.x + m[1][1] * v.y;
}

zpl_f32 zpl_mat2_determinate(zpl_mat2 *m) {
    zpl_float2 *e = zpl_float22_m(m);
    return e[0][0] * e[1][1] - e[1][0] * e[0][1];
}

void zpl_mat2_inverse(zpl_mat2 *out, zpl_mat2 *in) {
    zpl_float2 *o = zpl_float22_m(out);
    zpl_float2 *i = zpl_float22_m(in);

    zpl_f32 ood = 1.0f / zpl_mat2_determinate(in);

    o[0][0] = +i[1][1] * ood;
    o[0][1] = -i[0][1] * ood;
    o[1][0] = -i[1][0] * ood;
    o[1][1] = +i[0][0] * ood;
}

void zpl_mat3_transpose(zpl_mat3 *m) { zpl_float33_transpose(zpl_float33_m(m)); }
void zpl_mat3_identity(zpl_mat3 *m)  { zpl_float33_identity(zpl_float33_m(m)); }

void zpl_mat3_mul(zpl_mat3 *out, zpl_mat3 *m1, zpl_mat3 *m2) {
    zpl_float33_mul(zpl_float33_m(out), zpl_float33_m(m1), zpl_float33_m(m2));
}

void zpl_float33_identity(zpl_f32 m[3][3]) {
    m[0][0] = 1;
    m[0][1] = 0;
    m[0][2] = 0;
    m[1][0] = 0;
    m[1][1] = 1;
    m[1][2] = 0;
    m[2][0] = 0;
    m[2][1] = 0;
    m[2][2] = 1;
}

void zpl_mat3_mul_vec3(zpl_vec3 *out, zpl_mat3 *m, zpl_vec3 in) { zpl_float33_mul_vec3(out, zpl_float33_m(m), in); }

zpl_mat3 *zpl_mat3_v(zpl_vec3 m[3])   { return (zpl_mat3 *)m; }
zpl_mat3 *zpl_mat3_f(zpl_f32 m[3][3]) { return (zpl_mat3 *)m; }

zpl_float3 *zpl_float33_m(zpl_mat3 *m)   { return (zpl_float3 *)m; }
zpl_float3 *zpl_float33_v(zpl_vec3 m[3]) { return (zpl_float3 *)m; }
zpl_float3 *zpl_float33_9(zpl_f32 m[9])  { return (zpl_float3 *)m; }

void zpl_float33_transpose(zpl_f32 (*vec)[3]) {
    int i, j;
    for (j = 0; j < 3; j++) {
        for (i = j + 1; i < 3; i++) {
            zpl_f32 t = vec[i][j];
            vec[i][j] = vec[j][i];
            vec[j][i] = t;
        }
    }
}

void zpl_float33_mul(zpl_f32 (*out)[3], zpl_f32 (*mat1)[3], zpl_f32 (*mat2)[3]) {
    int i, j;
    zpl_f32 temp1[3][3], temp2[3][3];
    if (mat1 == out) {
        zpl__memcpy_4byte(temp1, mat1, sizeof(temp1));
        mat1 = temp1;
    }
    if (mat2 == out) {
        zpl__memcpy_4byte(temp2, mat2, sizeof(temp2));
        mat2 = temp2;
    }
    for (j = 0; j < 3; j++) {
        for (i = 0; i < 3; i++) {
            out[j][i] = mat1[0][i] * mat2[j][0] + mat1[1][i] * mat2[j][1] + mat1[2][i] * mat2[j][2];
        }
    }
}

void zpl_float33_mul_vec3(zpl_vec3 *out, zpl_f32 m[3][3], zpl_vec3 v) {
    out->x = m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z;
    out->y = m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z;
    out->z = m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z;
}

zpl_f32 zpl_mat3_determinate(zpl_mat3 *m) {
    zpl_float3 *e = zpl_float33_m(m);
    zpl_f32 d =
        +e[0][0] * (e[1][1] * e[2][2] - e[1][2] * e[2][1])
        -e[0][1] * (e[1][0] * e[2][2] - e[1][2] * e[2][0])
        +e[0][2] * (e[1][0] * e[2][1] - e[1][1] * e[2][0]);
    return d;
}

void zpl_mat3_inverse(zpl_mat3 *out, zpl_mat3 *in) {
    zpl_float3 *o = zpl_float33_m(out);
    zpl_float3 *i = zpl_float33_m(in);

    zpl_f32 ood = 1.0f / zpl_mat3_determinate(in);

    o[0][0] = +(i[1][1] * i[2][2] - i[2][1] * i[1][2]) * ood;
    o[0][1] = -(i[1][0] * i[2][2] - i[2][0] * i[1][2]) * ood;
    o[0][2] = +(i[1][0] * i[2][1] - i[2][0] * i[1][1]) * ood;
    o[1][0] = -(i[0][1] * i[2][2] - i[2][1] * i[0][2]) * ood;
    o[1][1] = +(i[0][0] * i[2][2] - i[2][0] * i[0][2]) * ood;
    o[1][2] = -(i[0][0] * i[2][1] - i[2][0] * i[0][1]) * ood;
    o[2][0] = +(i[0][1] * i[1][2] - i[1][1] * i[0][2]) * ood;
    o[2][1] = -(i[0][0] * i[1][2] - i[1][0] * i[0][2]) * ood;
    o[2][2] = +(i[0][0] * i[1][1] - i[1][0] * i[0][1]) * ood;
}

void zpl_mat4_transpose(zpl_mat4 *m) { zpl_float44_transpose(zpl_float44_m(m)); }
void zpl_mat4_identity(zpl_mat4 *m)  { zpl_float44_identity(zpl_float44_m(m)); }

void zpl_mat4_mul(zpl_mat4 *out, zpl_mat4 *m1, zpl_mat4 *m2) {
    zpl_float44_mul(zpl_float44_m(out), zpl_float44_m(m1), zpl_float44_m(m2));
}

void zpl_float44_identity(zpl_f32 m[4][4]) {
    m[0][0] = 1;
    m[0][1] = 0;
    m[0][2] = 0;
    m[0][3] = 0;
    m[1][0] = 0;
    m[1][1] = 1;
    m[1][2] = 0;
    m[1][3] = 0;
    m[2][0] = 0;
    m[2][1] = 0;
    m[2][2] = 1;
    m[2][3] = 0;
    m[3][0] = 0;
    m[3][1] = 0;
    m[3][2] = 0;
    m[3][3] = 1;
}

void zpl_mat4_mul_vec4(zpl_vec4 *out, zpl_mat4 *m, zpl_vec4 in) { zpl_float44_mul_vec4(out, zpl_float44_m(m), in); }

zpl_mat4 *zpl_mat4_v(zpl_vec4 m[4])   { return (zpl_mat4 *)m; }
zpl_mat4 *zpl_mat4_f(zpl_f32 m[4][4]) { return (zpl_mat4 *)m; }

zpl_float4 *zpl_float44_m(zpl_mat4 *m)    { return (zpl_float4 *)m; }
zpl_float4 *zpl_float44_v(zpl_vec4 m[4])  { return (zpl_float4 *)m; }
zpl_float4 *zpl_float44_16(zpl_f32 m[16]) { return (zpl_float4 *)m; }

void zpl_float44_transpose(zpl_f32 (*vec)[4]) {
    zpl_f32 tmp;
    tmp = vec[1][0];
    vec[1][0] = vec[0][1];
    vec[0][1] = tmp;
    tmp = vec[2][0];
    vec[2][0] = vec[0][2];
    vec[0][2] = tmp;
    tmp = vec[3][0];
    vec[3][0] = vec[0][3];
    vec[0][3] = tmp;
    tmp = vec[2][1];
    vec[2][1] = vec[1][2];
    vec[1][2] = tmp;
    tmp = vec[3][1];
    vec[3][1] = vec[1][3];
    vec[1][3] = tmp;
    tmp = vec[3][2];
    vec[3][2] = vec[2][3];
    vec[2][3] = tmp;
}

void zpl_float44_mul(zpl_f32 (*out)[4], zpl_f32 (*mat1)[4], zpl_f32 (*mat2)[4]) {
    int i, j;
    zpl_f32 temp1[4][4], temp2[4][4];
    if (mat1 == out) {
        zpl__memcpy_4byte(temp1, mat1, sizeof(temp1));
        mat1 = temp1;
    }
    if (mat2 == out) {
        zpl__memcpy_4byte(temp2, mat2, sizeof(temp2));
        mat2 = temp2;
    }
    for (j = 0; j < 4; j++) {
        for (i = 0; i < 4; i++) {
            out[j][i] =
                mat1[0][i] * mat2[j][0] + mat1[1][i] * mat2[j][1]
               +mat1[2][i] * mat2[j][2] + mat1[3][i] * mat2[j][3];
        }
    }
}

void zpl_float44_mul_vec4(zpl_vec4 *out, zpl_f32 m[4][4], zpl_vec4 v) {
    out->x = m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w;
    out->y = m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w;
    out->z = m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z + m[3][2] * v.w;
    out->w = m[0][3] * v.x + m[1][3] * v.y + m[2][3] * v.z + m[3][3] * v.w;
}

void zpl_mat4_inverse(zpl_mat4 *out, zpl_mat4 *in) {
    zpl_float4 *o = zpl_float44_m(out);
    zpl_float4 *m = zpl_float44_m(in);

    zpl_f32 ood;

    zpl_f32 sf00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
    zpl_f32 sf01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
    zpl_f32 sf02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
    zpl_f32 sf03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
    zpl_f32 sf04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
    zpl_f32 sf05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
    zpl_f32 sf06 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
    zpl_f32 sf07 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
    zpl_f32 sf08 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
    zpl_f32 sf09 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
    zpl_f32 sf10 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
    zpl_f32 sf11 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
    zpl_f32 sf12 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
    zpl_f32 sf13 = m[1][2] * m[2][3] - m[2][2] * m[1][3];
    zpl_f32 sf14 = m[1][1] * m[2][3] - m[2][1] * m[1][3];
    zpl_f32 sf15 = m[1][1] * m[2][2] - m[2][1] * m[1][2];
    zpl_f32 sf16 = m[1][0] * m[2][3] - m[2][0] * m[1][3];
    zpl_f32 sf17 = m[1][0] * m[2][2] - m[2][0] * m[1][2];
    zpl_f32 sf18 = m[1][0] * m[2][1] - m[2][0] * m[1][1];

    o[0][0] = +(m[1][1] * sf00 - m[1][2] * sf01 + m[1][3] * sf02);
    o[1][0] = -(m[1][0] * sf00 - m[1][2] * sf03 + m[1][3] * sf04);
    o[2][0] = +(m[1][0] * sf01 - m[1][1] * sf03 + m[1][3] * sf05);
    o[3][0] = -(m[1][0] * sf02 - m[1][1] * sf04 + m[1][2] * sf05);

    o[0][1] = -(m[0][1] * sf00 - m[0][2] * sf01 + m[0][3] * sf02);
    o[1][1] = +(m[0][0] * sf00 - m[0][2] * sf03 + m[0][3] * sf04);
    o[2][1] = -(m[0][0] * sf01 - m[0][1] * sf03 + m[0][3] * sf05);
    o[3][1] = +(m[0][0] * sf02 - m[0][1] * sf04 + m[0][2] * sf05);

    o[0][2] = +(m[0][1] * sf06 - m[0][2] * sf07 + m[0][3] * sf08);
    o[1][2] = -(m[0][0] * sf06 - m[0][2] * sf09 + m[0][3] * sf10);
    o[2][2] = +(m[0][0] * sf11 - m[0][1] * sf09 + m[0][3] * sf12);
    o[3][2] = -(m[0][0] * sf08 - m[0][1] * sf10 + m[0][2] * sf12);

    o[0][3] = -(m[0][1] * sf13 - m[0][2] * sf14 + m[0][3] * sf15);
    o[1][3] = +(m[0][0] * sf13 - m[0][2] * sf16 + m[0][3] * sf17);
    o[2][3] = -(m[0][0] * sf14 - m[0][1] * sf16 + m[0][3] * sf18);
    o[3][3] = +(m[0][0] * sf15 - m[0][1] * sf17 + m[0][2] * sf18);

    ood = 1.0f / (m[0][0] * o[0][0] + m[0][1] * o[1][0] + m[0][2] * o[2][0] + m[0][3] * o[3][0]);

    o[0][0] *= ood; o[1][0] *= ood; o[2][0] *= ood; o[3][0] *= ood;
    o[0][1] *= ood; o[1][1] *= ood; o[2][1] *= ood; o[3][1] *= ood;
    o[0][2] *= ood; o[1][2] *= ood; o[2][2] *= ood; o[3][2] *= ood;
    o[0][3] *= ood; o[1][3] *= ood; o[2][3] *= ood; o[3][3] *= ood;
}

void zpl_mat4_translate(zpl_mat4 *out, zpl_vec3 v) {
    zpl_mat4_identity(out);
    out->col[3].xyz = v;
    out->col[3].w = 1;
}

void zpl_mat4_rotate(zpl_mat4 *out, zpl_vec3 v, zpl_f32 angle_radians) {
    zpl_f32 c, s;
    zpl_vec3 axis, t;
    zpl_float4 *rot;

    c = zpl_cos(angle_radians);
    s = zpl_sin(angle_radians);

    zpl_vec3_norm(&axis, v);
    zpl_vec3_mul(&t, axis, 1.0f - c);

    zpl_mat4_identity(out);
    rot = zpl_float44_m(out);

    rot[0][0] = c + t.x * axis.x;
    rot[0][1] = 0 + t.x * axis.y + s * axis.z;
    rot[0][2] = 0 + t.x * axis.z - s * axis.y;
    rot[0][3] = 0;

    rot[1][0] = 0 + t.y * axis.x - s * axis.z;
    rot[1][1] = c + t.y * axis.y;
    rot[1][2] = 0 + t.y * axis.z + s * axis.x;
    rot[1][3] = 0;

    rot[2][0] = 0 + t.z * axis.x + s * axis.y;
    rot[2][1] = 0 + t.z * axis.y - s * axis.x;
    rot[2][2] = c + t.z * axis.z;
    rot[2][3] = 0;
}

void zpl_mat4_scale(zpl_mat4 *out, zpl_vec3 v) {
    zpl_mat4_identity(out);
    out->e[0]  = v.x;
    out->e[5]  = v.y;
    out->e[10] = v.z;
}

void zpl_mat4_scalef(zpl_mat4 *out, zpl_f32 s) {
    zpl_mat4_identity(out);
    out->e[0]  = s;
    out->e[5]  = s;
    out->e[10] = s;
}

void zpl_mat4_ortho2d(zpl_mat4 *out, zpl_f32 left, zpl_f32 right, zpl_f32 bottom, zpl_f32 top) {
    zpl_float4 *m;
    zpl_mat4_identity(out);
    m = zpl_float44_m(out);

    m[0][0] = 2.0f / (right - left);
    m[1][1] = 2.0f / (top - bottom);
    m[2][2] = -1.0f;
    m[3][0] = -(right + left) / (right - left);
    m[3][1] = -(top + bottom) / (top - bottom);
}

void zpl_mat4_ortho3d(zpl_mat4 *out, zpl_f32 left, zpl_f32 right, zpl_f32 bottom, zpl_f32 top, zpl_f32 z_near, zpl_f32 z_far) {
    zpl_float4 *m;
    zpl_mat4_identity(out);
    m = zpl_float44_m(out);

    m[0][0] = +2.0f / (right - left);
    m[1][1] = +2.0f / (top - bottom);
    m[2][2] = -2.0f / (z_far - z_near);
    m[3][0] = -(right + left) / (right - left);
    m[3][1] = -(top + bottom) / (top - bottom);
    m[3][2] = -(z_far + z_near) / (z_far - z_near);
}

void zpl_mat4_perspective(zpl_mat4 *out, zpl_f32 fovy, zpl_f32 aspect, zpl_f32 z_near, zpl_f32 z_far) {
    zpl_f32 tan_half_fovy = zpl_tan(0.5f * fovy);
    zpl_mat4 zero_mat = { 0 };
    zpl_float4 *m = zpl_float44_m(out);
    *out = zero_mat;

    m[0][0] = 1.0f / (aspect * tan_half_fovy);
    m[1][1] = 1.0f / (tan_half_fovy);
    m[2][2] = -(z_far + z_near) / (z_far - z_near);
    m[2][3] = -1.0f;
    m[3][2] = -2.0f * z_far * z_near / (z_far - z_near);
}

void zpl_mat4_infinite_perspective(zpl_mat4 *out, zpl_f32 fovy, zpl_f32 aspect, zpl_f32 z_near) {
    zpl_f32 range = zpl_tan(0.5f * fovy) * z_near;
    zpl_f32 left = -range * aspect;
    zpl_f32 right = range * aspect;
    zpl_f32 bottom = -range;
    zpl_f32 top = range;
    zpl_mat4 zero_mat = { 0 };
    zpl_float4 *m = zpl_float44_m(out);
    *out = zero_mat;

    m[0][0] = (2.0f * z_near) / (right - left);
    m[1][1] = (2.0f * z_near) / (top - bottom);
    m[2][2] = -1.0f;
    m[2][3] = -1.0f;
    m[3][2] = -2.0f * z_near;
}

void zpl_mat4_look_at(zpl_mat4 *out, zpl_vec3 eye, zpl_vec3 centre, zpl_vec3 up) {
    zpl_vec3 f, s, u;
    zpl_float4 *m;

    zpl_vec3_sub(&f, centre, eye);
    zpl_vec3_norm(&f, f);

    zpl_vec3_cross(&s, f, up);
    zpl_vec3_norm(&s, s);

    zpl_vec3_cross(&u, s, f);

    zpl_mat4_identity(out);
    m = zpl_float44_m(out);

    m[0][0] = +s.x;
    m[1][0] = +s.y;
    m[2][0] = +s.z;

    m[0][1] = +u.x;
    m[1][1] = +u.y;
    m[2][1] = +u.z;

    m[0][2] = -f.x;
    m[1][2] = -f.y;
    m[2][2] = -f.z;

    m[3][0] = -zpl_vec3_dot(s, eye);
    m[3][1] = -zpl_vec3_dot(u, eye);
    m[3][2] = +zpl_vec3_dot(f, eye);
}

zpl_quat zpl_quatf(zpl_f32 x, zpl_f32 y, zpl_f32 z, zpl_f32 w) {
    zpl_quat q;
    q.x = x;
    q.y = y;
    q.z = z;
    q.w = w;
    return q;
}
zpl_quat zpl_quatfv(zpl_f32 e[4]) {
    zpl_quat q;
    q.x = e[0];
    q.y = e[1];
    q.z = e[2];
    q.w = e[3];
    return q;
}

zpl_quat zpl_quat_axis_angle(zpl_vec3 axis, zpl_f32 angle_radians) {
    zpl_quat q;
    zpl_vec3_norm(&q.xyz, axis);
    zpl_vec3_muleq(&q.xyz, zpl_sin(0.5f * angle_radians));
    q.w = zpl_cos(0.5f * angle_radians);
    return q;
}

zpl_quat zpl_quat_euler_angles(zpl_f32 pitch, zpl_f32 yaw, zpl_f32 roll) {
    /* TODO: Do without multiplication, i.e. make it faster */
    zpl_quat q, p, y, r;
    p = zpl_quat_axis_angle(zpl_vec3f(1, 0, 0), pitch);
    y = zpl_quat_axis_angle(zpl_vec3f(0, 1, 0), yaw);
    r = zpl_quat_axis_angle(zpl_vec3f(0, 0, 1), roll);

    zpl_quat_mul(&q, y, p);
    zpl_quat_muleq(&q, r);

    return q;
}

zpl_quat zpl_quat_identity(void) {
    zpl_quat q = { 0, 0, 0, 1 };
    return q;
}

void zpl_quat_add(zpl_quat *d, zpl_quat q0, zpl_quat q1) { zpl_vec4_add(&d->xyzw, q0.xyzw, q1.xyzw); }
void zpl_quat_sub(zpl_quat *d, zpl_quat q0, zpl_quat q1) { zpl_vec4_sub(&d->xyzw, q0.xyzw, q1.xyzw); }

void zpl_quat_mul(zpl_quat *d, zpl_quat q0, zpl_quat q1) {
    d->x = q0.w * q1.x + q0.x * q1.w + q0.y * q1.z - q0.z * q1.y;
    d->y = q0.w * q1.y - q0.x * q1.z + q0.y * q1.w + q0.z * q1.x;
    d->z = q0.w * q1.z + q0.x * q1.y - q0.y * q1.x + q0.z * q1.w;
    d->w = q0.w * q1.w - q0.x * q1.x - q0.y * q1.y - q0.z * q1.z;
}

void zpl_quat_div(zpl_quat *d, zpl_quat q0, zpl_quat q1) {
    zpl_quat iq1;
    zpl_quat_inverse(&iq1, q1);
    zpl_quat_mul(d, q0, iq1);
}

void zpl_quat_mulf(zpl_quat *d, zpl_quat q0, zpl_f32 s) { zpl_vec4_mul(&d->xyzw, q0.xyzw, s); }
void zpl_quat_divf(zpl_quat *d, zpl_quat q0, zpl_f32 s) { zpl_vec4_div(&d->xyzw, q0.xyzw, s); }

void zpl_quat_addeq(zpl_quat *d, zpl_quat q) { zpl_vec4_addeq(&d->xyzw, q.xyzw); }
void zpl_quat_subeq(zpl_quat *d, zpl_quat q) { zpl_vec4_subeq(&d->xyzw, q.xyzw); }
void zpl_quat_muleq(zpl_quat *d, zpl_quat q) { zpl_quat_mul(d, *d, q); }
void zpl_quat_diveq(zpl_quat *d, zpl_quat q) { zpl_quat_div(d, *d, q); }

void zpl_quat_muleqf(zpl_quat *d, zpl_f32 s) { zpl_vec4_muleq(&d->xyzw, s); }
void zpl_quat_diveqf(zpl_quat *d, zpl_f32 s) { zpl_vec4_diveq(&d->xyzw, s); }

zpl_f32 zpl_quat_dot(zpl_quat q0, zpl_quat q1) {
    zpl_f32 r = zpl_vec3_dot(q0.xyz, q1.xyz) + q0.w * q1.w;
    return r;
}
zpl_f32 zpl_quat_mag(zpl_quat q) {
    zpl_f32 r = zpl_sqrt(zpl_quat_dot(q, q));
    return r;
}

void zpl_quat_norm(zpl_quat *d, zpl_quat q) { zpl_quat_divf(d, q, zpl_quat_mag(q)); }

void zpl_quat_conj(zpl_quat *d, zpl_quat q) {
    d->xyz = zpl_vec3f(-q.x, -q.y, -q.z);
    d->w = q.w;
}
void zpl_quat_inverse(zpl_quat *d, zpl_quat q) {
    zpl_quat_conj(d, q);
    zpl_quat_diveqf(d, zpl_quat_dot(q, q));
}

void zpl_quat_axis(zpl_vec3 *axis, zpl_quat q) {
    zpl_quat n;
    zpl_quat_norm(&n, q);
    zpl_vec3_div(axis, n.xyz, zpl_sin(zpl_arccos(q.w)));
}

zpl_f32 zpl_quat_angle(zpl_quat q) {
    zpl_f32 mag   = zpl_quat_mag(q);
    zpl_f32 c     = q.w * (1.0f / mag);
    zpl_f32 angle = 2.0f * zpl_arccos(c);
    return angle;
}

zpl_f32 zpl_quat_roll(zpl_quat q) {
    return zpl_arctan2(2.0f * q.x * q.y + q.z * q.w, q.x * q.x + q.w * q.w - q.y * q.y - q.z * q.z);
}
zpl_f32 zpl_quat_pitch(zpl_quat q) {
    return zpl_arctan2(2.0f * q.y * q.z + q.w * q.x, q.w * q.w - q.x * q.x - q.y * q.y + q.z * q.z);
}
zpl_f32 zpl_quat_yaw(zpl_quat q) { return zpl_arcsin(-2.0f * (q.x * q.z - q.w * q.y)); }

void zpl_quat_rotate_vec3(zpl_vec3 *d, zpl_quat q, zpl_vec3 v) {
    /* zpl_vec3 t = 2.0f * cross(q.xyz, v);
     * *d = q.w*t + v + cross(q.xyz, t);
     */
    zpl_vec3 t, p;
    zpl_vec3_cross(&t, q.xyz, v);
    zpl_vec3_muleq(&t, 2.0f);

    zpl_vec3_cross(&p, q.xyz, t);

    zpl_vec3_mul(d, t, q.w);
    zpl_vec3_addeq(d, v);
    zpl_vec3_addeq(d, p);
}

void zpl_mat4_from_quat(zpl_mat4 *out, zpl_quat q) {
    zpl_float4 *m;
    zpl_quat a;
    zpl_f32 xx, yy, zz, xy, xz, yz, wx, wy, wz;

    zpl_quat_norm(&a, q);
    xx = a.x * a.x;
    yy = a.y * a.y;
    zz = a.z * a.z;
    xy = a.x * a.y;
    xz = a.x * a.z;
    yz = a.y * a.z;
    wx = a.w * a.x;
    wy = a.w * a.y;
    wz = a.w * a.z;

    zpl_mat4_identity(out);
    m = zpl_float44_m(out);

    m[0][0] = 1.0f - 2.0f * (yy + zz);
    m[0][1] = 2.0f * (xy + wz);
    m[0][2] = 2.0f * (xz - wy);

    m[1][0] = 2.0f * (xy - wz);
    m[1][1] = 1.0f - 2.0f * (xx + zz);
    m[1][2] = 2.0f * (yz + wx);

    m[2][0] = 2.0f * (xz + wy);
    m[2][1] = 2.0f * (yz - wx);
    m[2][2] = 1.0f - 2.0f * (xx + yy);
}

void zpl_quat_from_mat4(zpl_quat *out, zpl_mat4 *mat) {
    zpl_float4 *m;
    zpl_f32 four_x_squared_minus_1, four_y_squared_minus_1, four_z_squared_minus_1, four_w_squared_minus_1,
    four_biggest_squared_minus_1;
    int biggest_index = 0;
    zpl_f32 biggest_value, mult;

    m = zpl_float44_m(mat);

    four_x_squared_minus_1 = m[0][0] - m[1][1] - m[2][2];
    four_y_squared_minus_1 = m[1][1] - m[0][0] - m[2][2];
    four_z_squared_minus_1 = m[2][2] - m[0][0] - m[1][1];
    four_w_squared_minus_1 = m[0][0] + m[1][1] + m[2][2];

    four_biggest_squared_minus_1 = four_w_squared_minus_1;
    if (four_x_squared_minus_1 > four_biggest_squared_minus_1) {
        four_biggest_squared_minus_1 = four_x_squared_minus_1;
        biggest_index = 1;
    }
    if (four_y_squared_minus_1 > four_biggest_squared_minus_1) {
        four_biggest_squared_minus_1 = four_y_squared_minus_1;
        biggest_index = 2;
    }
    if (four_z_squared_minus_1 > four_biggest_squared_minus_1) {
        four_biggest_squared_minus_1 = four_z_squared_minus_1;
        biggest_index = 3;
    }

    biggest_value = zpl_sqrt(four_biggest_squared_minus_1 + 1.0f) * 0.5f;
    mult = 0.25f / biggest_value;

    switch (biggest_index) {
        case 0:
            out->w = biggest_value;
            out->x = (m[1][2] - m[2][1]) * mult;
            out->y = (m[2][0] - m[0][2]) * mult;
            out->z = (m[0][1] - m[1][0]) * mult;
            break;
        case 1:
            out->w = (m[1][2] - m[2][1]) * mult;
            out->x = biggest_value;
            out->y = (m[0][1] + m[1][0]) * mult;
            out->z = (m[2][0] + m[0][2]) * mult;
            break;
        case 2:
            out->w = (m[2][0] - m[0][2]) * mult;
            out->x = (m[0][1] + m[1][0]) * mult;
            out->y = biggest_value;
            out->z = (m[1][2] + m[2][1]) * mult;
            break;
        case 3:
            out->w = (m[0][1] - m[1][0]) * mult;
            out->x = (m[2][0] + m[0][2]) * mult;
            out->y = (m[1][2] + m[2][1]) * mult;
            out->z = biggest_value;
            break;
    }
}

zpl_f32 zpl_lerp(zpl_f32 a, zpl_f32 b, zpl_f32 t) { return a * (1.0f - t) + b * t; }
zpl_f32 zpl_unlerp(zpl_f32 t, zpl_f32 a, zpl_f32 b) { return (t - a) / (b - a); }
zpl_f32 zpl_smooth_step(zpl_f32 a, zpl_f32 b, zpl_f32 t) {
    zpl_f32 x = (t - a) / (b - a);
    return x * x * (3.0f - 2.0f * x);
}
zpl_f32 zpl_smoother_step(zpl_f32 a, zpl_f32 b, zpl_f32 t) {
    zpl_f32 x = (t - a) / (b - a);
    return x * x * x * (x * (6.0f * x - 15.0f) + 10.0f);
}

#define ZPL_VEC_LERPN(N, d, a, b, t)     \
    zpl_vec##N db;                       \
    zpl_vec##N##_sub(&db, b, a);         \
    zpl_vec##N##_muleq(&db, t);          \
    zpl_vec##N##_add(d, a, db)

void zpl_vec2_lerp(zpl_vec2 *d, zpl_vec2 a, zpl_vec2 b, zpl_f32 t) { ZPL_VEC_LERPN(2, d, a, b, t); }
void zpl_vec3_lerp(zpl_vec3 *d, zpl_vec3 a, zpl_vec3 b, zpl_f32 t) { ZPL_VEC_LERPN(3, d, a, b, t); }
void zpl_vec4_lerp(zpl_vec4 *d, zpl_vec4 a, zpl_vec4 b, zpl_f32 t) { ZPL_VEC_LERPN(4, d, a, b, t); }

#undef ZPL_VEC_LERPN

void zpl_vec2_cslerp(zpl_vec2 *d, zpl_vec2 a, zpl_vec2 v0, zpl_vec2 b, zpl_vec2 v1, zpl_f32 t) {
    zpl_f32 t2 = t * t;
    zpl_f32 ti = (t - 1);
    zpl_f32 ti2 = ti * ti;

    zpl_f32 h00 = (1 + 2 * t) * ti2;
    zpl_f32 h10 = t * ti2;
    zpl_f32 h01 = t2 * (3 - 2 * t);
    zpl_f32 h11 = t2 * ti;

    d->x = h00 * a.x + h10 * v0.x + h01 * b.x + h11 * v1.x;
    d->y = h00 * a.y + h10 * v0.y + h01 * b.y + h11 * v1.y;
}

void zpl_vec3_cslerp(zpl_vec3 *d, zpl_vec3 a, zpl_vec3 v0, zpl_vec3 b, zpl_vec3 v1, zpl_f32 t) {
    zpl_f32 t2 = t * t;
    zpl_f32 ti = (t - 1);
    zpl_f32 ti2 = ti * ti;

    zpl_f32 h00 = (1 + 2 * t) * ti2;
    zpl_f32 h10 = t * ti2;
    zpl_f32 h01 = t2 * (3 - 2 * t);
    zpl_f32 h11 = t2 * ti;

    d->x = h00 * a.x + h10 * v0.x + h01 * b.x + h11 * v1.x;
    d->y = h00 * a.y + h10 * v0.y + h01 * b.y + h11 * v1.y;
    d->z = h00 * a.z + h10 * v0.z + h01 * b.z + h11 * v1.z;
}

void zpl_vec2_dcslerp(zpl_vec2 *d, zpl_vec2 a, zpl_vec2 v0, zpl_vec2 b, zpl_vec2 v1, zpl_f32 t) {
    zpl_f32 t2 = t * t;

    zpl_f32 dh00 = 6 * t2 - 6 * t;
    zpl_f32 dh10 = 3 * t2 - 4 * t + 1;
    zpl_f32 dh01 = -6 * t2 + 6 * t;
    zpl_f32 dh11 = 3 * t2 - 2 * t;

    d->x = dh00 * a.x + dh10 * v0.x + dh01 * b.x + dh11 * v1.x;
    d->y = dh00 * a.y + dh10 * v0.y + dh01 * b.y + dh11 * v1.y;
}

void zpl_vec3_dcslerp(zpl_vec3 *d, zpl_vec3 a, zpl_vec3 v0, zpl_vec3 b, zpl_vec3 v1, zpl_f32 t) {
    zpl_f32 t2 = t * t;

    zpl_f32 dh00 = 6 * t2 - 6 * t;
    zpl_f32 dh10 = 3 * t2 - 4 * t + 1;
    zpl_f32 dh01 = -6 * t2 + 6 * t;
    zpl_f32 dh11 = 3 * t2 - 2 * t;

    d->x = dh00 * a.x + dh10 * v0.x + dh01 * b.x + dh11 * v1.x;
    d->y = dh00 * a.y + dh10 * v0.y + dh01 * b.y + dh11 * v1.y;
    d->z = dh00 * a.z + dh10 * v0.z + dh01 * b.z + dh11 * v1.z;
}

void zpl_quat_lerp(zpl_quat *d, zpl_quat a, zpl_quat b, zpl_f32 t) { zpl_vec4_lerp(&d->xyzw, a.xyzw, b.xyzw, t); }
void zpl_quat_nlerp(zpl_quat *d, zpl_quat a, zpl_quat b, zpl_f32 t) {
    zpl_quat_lerp(d, a, b, t);
    zpl_quat_norm(d, *d);
}

void zpl_quat_slerp(zpl_quat *d, zpl_quat a, zpl_quat b, zpl_f32 t) {
    zpl_quat x, y, z;
    zpl_f32 cos_theta, angle;
    zpl_f32 s1, s0, is;

    z = b;
    cos_theta = zpl_quat_dot(a, b);

    if (cos_theta < 0.0f) {
        z = zpl_quatf(-b.x, -b.y, -b.z, -b.w);
        cos_theta = -cos_theta;
    }

    if (cos_theta > 1.0f) {
        /* NOTE: Use lerp not nlerp as it's not a real angle or they are not normalized */
        zpl_quat_lerp(d, a, b, t);
    }

    angle = zpl_arccos(cos_theta);

    s1 = zpl_sin((1.0f - t) * angle);
    s0 = zpl_sin(t * angle);
    is = 1.0f / zpl_sin(angle);
    zpl_quat_mulf(&x, a, s1);
    zpl_quat_mulf(&y, z, s0);
    zpl_quat_add(d, x, y);
    zpl_quat_muleqf(d, is);
}

void zpl_quat_slerp_approx(zpl_quat *d, zpl_quat a, zpl_quat b, zpl_f32 t) {
    /* NOTE: Derived by taylor expanding the geometric interpolation equation
     *             Even works okay for nearly anti-parallel versors!!!
     */
    /* NOTE: Extra interations cannot be used as they require angle^4 which is not worth it to approximate */
    zpl_f32 tp = t + (1.0f - zpl_quat_dot(a, b)) / 3.0f * t * (-2.0f * t * t + 3.0f * t - 1.0f);
    zpl_quat_nlerp(d, a, b, tp);
}

void zpl_quat_nquad(zpl_quat *d, zpl_quat p, zpl_quat a, zpl_quat b, zpl_quat q, zpl_f32 t) {
    zpl_quat x, y;
    zpl_quat_nlerp(&x, p, q, t);
    zpl_quat_nlerp(&y, a, b, t);
    zpl_quat_nlerp(d, x, y, 2.0f * t * (1.0f - t));
}

void zpl_quat_squad(zpl_quat *d, zpl_quat p, zpl_quat a, zpl_quat b, zpl_quat q, zpl_f32 t) {
    zpl_quat x, y;
    zpl_quat_slerp(&x, p, q, t);
    zpl_quat_slerp(&y, a, b, t);
    zpl_quat_slerp(d, x, y, 2.0f * t * (1.0f - t));
}

void zpl_quat_squad_approx(zpl_quat *d, zpl_quat p, zpl_quat a, zpl_quat b, zpl_quat q, zpl_f32 t) {
    zpl_quat x, y;
    zpl_quat_slerp_approx(&x, p, q, t);
    zpl_quat_slerp_approx(&y, a, b, t);
    zpl_quat_slerp_approx(d, x, y, 2.0f * t * (1.0f - t));
}

zpl_rect2 zpl_rect2f(zpl_vec2 pos, zpl_vec2 dim) {
    zpl_rect2 r;
    r.pos = pos;
    r.dim = dim;
    return r;
}

zpl_rect3 zpl_rect3f(zpl_vec3 pos, zpl_vec3 dim) {
    zpl_rect3 r;
    r.pos = pos;
    r.dim = dim;
    return r;
}

int zpl_rect2_contains(zpl_rect2 a, zpl_f32 x, zpl_f32 y) {
    zpl_f32 min_x = zpl_min(a.pos.x, a.pos.x + a.dim.x);
    zpl_f32 max_x = zpl_max(a.pos.x, a.pos.x + a.dim.x);
    zpl_f32 min_y = zpl_min(a.pos.y, a.pos.y + a.dim.y);
    zpl_f32 max_y = zpl_max(a.pos.y, a.pos.y + a.dim.y);
    int result    =        (x >= min_x) & (x < max_x) & (y >= min_y) & (y < max_y);
    return result;
}

int zpl_rect2_contains_vec2(zpl_rect2 a, zpl_vec2 p) { return zpl_rect2_contains(a, p.x, p.y); }

int zpl_rect2_intersects(zpl_rect2 a, zpl_rect2 b) {
    zpl_rect2 r = { 0 };
    return zpl_rect2_intersection_result(a, b, &r);
}

int zpl_rect2_intersection_result(zpl_rect2 a, zpl_rect2 b, zpl_rect2 *intersection) {
    zpl_f32 a_min_x = zpl_min(a.pos.x, a.pos.x + a.dim.x);
    zpl_f32 a_max_x = zpl_max(a.pos.x, a.pos.x + a.dim.x);
    zpl_f32 a_min_y = zpl_min(a.pos.y, a.pos.y + a.dim.y);
    zpl_f32 a_max_y = zpl_max(a.pos.y, a.pos.y + a.dim.y);

    zpl_f32 b_min_x = zpl_min(b.pos.x, b.pos.x + b.dim.x);
    zpl_f32 b_max_x = zpl_max(b.pos.x, b.pos.x + b.dim.x);
    zpl_f32 b_min_y = zpl_min(b.pos.y, b.pos.y + b.dim.y);
    zpl_f32 b_max_y = zpl_max(b.pos.y, b.pos.y + b.dim.y);

    zpl_f32 x0 = zpl_max(a_min_x, b_min_x);
    zpl_f32 y0 = zpl_max(a_min_y, b_min_y);
    zpl_f32 x1 = zpl_min(a_max_x, b_max_x);
    zpl_f32 y1 = zpl_min(a_max_y, b_max_y);

    if ((x0 < x1) && (y0 < y1)) {
        zpl_rect2 r = zpl_rect2f(zpl_vec2f(x0, y0), zpl_vec2f(x1 - x0, y1 - y0));
        *intersection = r;
        return 1;
    } else {
        zpl_rect2 r = { 0 };
        *intersection = r;
        return 0;
    }
}


#if defined(__cplusplus)
}
#endif

#if defined(ZPL_COMPILER_MSVC)
#pragma warning(pop)
#endif

#if defined(__GCC__) || defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif

#endif // ZPL_IMPLEMENTATION

//<<header.c>>
//<<mem.c>>
//<<threads.c>>
//<<sort.c>>
//<<string.c>>
//<<containers.c>>
//<<hashtable.c>>
//<<file.c>>
//<<print.c>>
//<<time.c>>
//<<misc.c>>
//<<opts.c>>
//<<math.c>>

#if !defined(ZPL_PREFIX_TYPES)
typedef zpl_u8 u8;
typedef zpl_i8 i8;
typedef zpl_u16 u16;
typedef zpl_i16 i16;
typedef zpl_u32 u32;
typedef zpl_i32 i32;
typedef zpl_u64 u64;
typedef zpl_i64 i64;
typedef zpl_b8 b8;
typedef zpl_b16 b16;
typedef zpl_b32 b32;
typedef zpl_f32 f32;
typedef zpl_f64 f64;
typedef zpl_rune rune;
typedef zpl_usize usize;
typedef zpl_isize isize;
typedef zpl_uintptr uintptr;
typedef zpl_intptr intptr;
#endif // ZPL_PREFIX_TYPES

#endif // ZPL_INCLUDE_ZPL_H

///////////////////////////////////////////////////////////////
//
// Code Snippets
//

/*


#ifndef FOO_H
#define FOO_H

#ifdef __cplusplus
extern "C" {
#endif



#ifdef __cplusplus
}
#endif

#if defined(FOO_IMPLEMENTATION) && !defined(FOO_IMPLEMENTATION_DONE)
#define FOO_IMPLEMENTATION_DONE

#ifdef __cplusplus
extern "C" {
#endif



#ifdef __cplusplus
}
#endif

#endif // FOO_IMPLEMENTATION
#endif // FOO_H


 */
